/*
Copyright(c) 2012 Company Name
*/
Ext.define("Ext.data.JsonP", {
    singleton: true,
    statics: {
        requestCount: 0,
        requests: {}
    },
    timeout: 30000,
    disableCaching: true,
    disableCachingParam: "_dc",
    callbackKey: "callback",
    request: function(n) {
        n = Ext.apply({},
        n);
        if (!n.url) {
            Ext.Error.raise("A url must be specified for a JSONP request.")
        }
        var j = this,
        d = Ext.isDefined(n.disableCaching) ? n.disableCaching: j.disableCaching,
        g = n.disableCachingParam || j.disableCachingParam,
        c = ++j.statics().requestCount,
        l = n.callbackName || "callback" + c,
        h = n.callbackKey || j.callbackKey,
        m = Ext.isDefined(n.timeout) ? n.timeout: j.timeout,
        e = Ext.apply({},
        n.params),
        b = n.url,
        a = Ext.isSandboxed ? Ext.getUniqueGlobalNamespace() : "Ext",
        f,
        k;
        e[h] = a + ".data.JsonP." + l;
        if (d) {
            e[g] = new Date().getTime()
        }
        k = j.createScript(b, e);
        j.statics().requests[c] = f = {
            url: b,
            params: e,
            script: k,
            id: c,
            scope: n.scope,
            success: n.success,
            failure: n.failure,
            callback: n.callback,
            callbackName: l
        };
        if (m > 0) {
            f.timeout = setTimeout(Ext.bind(j.handleTimeout, j, [f]), m)
        }
        j.setupErrorHandling(f);
        j[l] = Ext.bind(j.handleResponse, j, [f], true);
        Ext.getHead().appendChild(k);
        return f
    },
    abort: function(b) {
        var c = this.statics().requests,
        a;
        if (b) {
            if (!b.id) {
                b = c[b]
            }
            this.abort(b)
        } else {
            for (a in c) {
                if (c.hasOwnProperty(a)) {
                    this.abort(c[a])
                }
            }
        }
    },
    setupErrorHandling: function(a) {
        a.script.onerror = Ext.bind(this.handleError, this, [a])
    },
    handleAbort: function(a) {
        a.errorType = "abort";
        this.handleResponse(null, a)
    },
    handleError: function(a) {
        a.errorType = "error";
        this.handleResponse(null, a)
    },
    cleanupErrorHandling: function(a) {
        a.script.onerror = null
    },
    handleTimeout: function(a) {
        a.errorType = "timeout";
        this.handleResponse(null, a)
    },
    handleResponse: function(a, b) {
        var c = true;
        if (b.timeout) {
            clearTimeout(b.timeout)
        }
        delete this[b.callbackName];
        delete this.statics()[b.id];
        this.cleanupErrorHandling(b);
        Ext.fly(b.script).remove();
        if (b.errorType) {
            c = false;
            Ext.callback(b.failure, b.scope, [b.errorType])
        } else {
            Ext.callback(b.success, b.scope, [a])
        }
        Ext.callback(b.callback, b.scope, [c, a, b.errorType])
    },
    createScript: function(b, c) {
        var a = document.createElement("script");
        a.setAttribute("src", Ext.urlAppend(b, Ext.Object.toQueryString(c)));
        a.setAttribute("async", true);
        a.setAttribute("type", "text/javascript");
        return a
    }
});
Ext.define("Ext.Template", {
    requires: ["Ext.DomHelper", "Ext.util.Format"],
    inheritableStatics: {
        from: function(b, a) {
            b = Ext.getDom(b);
            return new this(b.value || b.innerHTML, a || "")
        }
    },
    constructor: function(d) {
        var f = this,
        b = arguments,
        a = [],
        c = 0,
        e = b.length,
        g;
        f.initialConfig = {};
        if (e > 1) {
            for (; c < e; c++) {
                g = b[c];
                if (typeof g == "object") {
                    Ext.apply(f.initialConfig, g);
                    Ext.apply(f, g)
                } else {
                    a.push(g)
                }
            }
            d = a.join("")
        } else {
            if (Ext.isArray(d)) {
                a.push(d.join(""))
            } else {
                a.push(d)
            }
        }
        f.html = a.join("");
        if (f.compiled) {
            f.compile()
        }
    },
    isTemplate: true,
    disableFormats: false,
    re: /\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,
    applyTemplate: function(a) {
        var f = this,
        c = f.disableFormats !== true,
        e = Ext.util.Format,
        b = f;
        if (f.compiled) {
            return f.compiled(a)
        }
        function d(g, j, k, h) {
            if (k && c) {
                if (h) {
                    h = [a[j]].concat(Ext.functionFactory("return [" + h + "];")())
                } else {
                    h = [a[j]]
                }
                if (k.substr(0, 5) == "this.") {
                    return b[k.substr(5)].apply(b, h)
                } else {
                    return e[k].apply(e, h)
                }
            } else {
                return a[j] !== undefined ? a[j] : ""
            }
        }
        return f.html.replace(f.re, d)
    },
    set: function(a, c) {
        var b = this;
        b.html = a;
        b.compiled = null;
        return c ? b.compile() : b
    },
    compileARe: /\\/g,
    compileBRe: /(\r\n|\n)/g,
    compileCRe: /'/g,
    compile: function() {
        var me = this,
        fm = Ext.util.Format,
        useFormat = me.disableFormats !== true,
        body, bodyReturn;
        function fn(m, name, format, args) {
            if (format && useFormat) {
                args = args ? "," + args: "";
                if (format.substr(0, 5) != "this.") {
                    format = "fm." + format + "("
                } else {
                    format = "this." + format.substr(5) + "("
                }
            } else {
                args = "";
                format = "(values['" + name + "'] == undefined ? '' : "
            }
            return "'," + format + "values['" + name + "']" + args + ") ,'"
        }
        bodyReturn = me.html.replace(me.compileARe, "\\\\").replace(me.compileBRe, "\\n").replace(me.compileCRe, "\\'").replace(me.re, fn);
        body = "this.compiled = function(values){ return ['" + bodyReturn + "'].join('');};";
        eval(body);
        return me
    },
    insertFirst: function(b, a, c) {
        return this.doInsert("afterBegin", b, a, c)
    },
    insertBefore: function(b, a, c) {
        return this.doInsert("beforeBegin", b, a, c)
    },
    insertAfter: function(b, a, c) {
        return this.doInsert("afterEnd", b, a, c)
    },
    append: function(b, a, c) {
        return this.doInsert("beforeEnd", b, a, c)
    },
    doInsert: function(c, e, b, a) {
        e = Ext.getDom(e);
        var d = Ext.DomHelper.insertHtml(c, e, this.applyTemplate(b));
        return a ? Ext.get(d, true) : d
    },
    overwrite: function(b, a, c) {
        b = Ext.getDom(b);
        b.innerHTML = this.applyTemplate(a);
        return c ? Ext.get(b.firstChild, true) : b.firstChild
    }
},
function() {
    this.createAlias("apply", "applyTemplate")
});
Ext.define("Ext.form.field.VTypes", (function() {
    var c = /^[a-zA-Z_]+$/,
    d = /^[a-zA-Z0-9_]+$/,
    b = /^(\w+)([\-+.][\w]+)*@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/,
    a = /(((^https?)|(^ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i;
    return {
        singleton: true,
        alternateClassName: "Ext.form.VTypes",
        email: function(e) {
            return b.test(e)
        },
        emailText: 'This field should be an e-mail address in the format "user@example.com"',
        emailMask: /[a-z0-9_\.\-@\+]/i,
        url: function(e) {
            return a.test(e)
        },
        urlText: 'This field should be a URL in the format "http://www.example.com"',
        alpha: function(e) {
            return c.test(e)
        },
        alphaText: "This field should only contain letters and _",
        alphaMask: /[a-z_]/i,
        alphanum: function(e) {
            return d.test(e)
        },
        alphanumText: "This field should only contain letters, numbers and _",
        alphanumMask: /[a-z0-9_]/i
    }
})());
Ext.define("Ext.util.KeyMap", {
    alternateClassName: "Ext.KeyMap",
    constructor: function(b, d, a) {
        var c = this;
        Ext.apply(c, {
            el: Ext.get(b),
            eventName: a || c.eventName,
            bindings: []
        });
        if (d) {
            c.addBinding(d)
        }
        c.enable()
    },
    eventName: "keydown",
    addBinding: function(g) {
        if (Ext.isArray(g)) {
            Ext.each(g, this.addBinding, this);
            return
        }
        var f = g.key,
        h = false,
        d, e, b, c, a;
        if (Ext.isString(f)) {
            e = [];
            b = f.toUpperCase();
            for (c = 0, a = b.length; c < a; ++c) {
                e.push(b.charCodeAt(c))
            }
            f = e;
            h = true
        }
        if (!Ext.isArray(f)) {
            f = [f]
        }
        if (!h) {
            for (c = 0, a = f.length; c < a; ++c) {
                d = f[c];
                if (Ext.isString(d)) {
                    f[c] = d.toUpperCase().charCodeAt(0)
                }
            }
        }
        this.bindings.push(Ext.apply({
            keyCode: f
        },
        g))
    },
    handleKeyDown: function(c) {
        if (this.enabled) {
            var d = this.bindings,
            b = 0,
            a = d.length;
            c = this.processEvent(c);
            for (; b < a; ++b) {
                this.processBinding(d[b], c)
            }
        }
    },
    processEvent: function(a) {
        return a
    },
    processBinding: function(f, a) {
        if (this.checkModifiers(f, a)) {
            var g = a.getKey(),
            j = f.fn || f.handler,
            k = f.scope || this,
            h = f.keyCode,
            b = f.defaultEventAction,
            c,
            e,
            d = new Ext.EventObjectImpl(a);
            for (c = 0, e = h.length; c < e; ++c) {
                if (g === h[c]) {
                    if (j.call(k, g, a) !== true && b) {
                        d[b]()
                    }
                    break
                }
            }
        }
    },
    checkModifiers: function(h, f) {
        var d = ["shift", "ctrl", "alt"],
        c = 0,
        a = d.length,
        g,
        b;
        for (; c < a; ++c) {
            b = d[c];
            g = h[b];
            if (! (g === undefined || (g === f[b + "Key"]))) {
                return false
            }
        }
        return true
    },
    on: function(b, d, c) {
        var g, a, e, f;
        if (Ext.isObject(b) && !Ext.isArray(b)) {
            g = b.key;
            a = b.shift;
            e = b.ctrl;
            f = b.alt
        } else {
            g = b
        }
        this.addBinding({
            key: g,
            shift: a,
            ctrl: e,
            alt: f,
            fn: d,
            scope: c
        })
    },
    isEnabled: function() {
        return this.enabled
    },
    enable: function() {
        var a = this;
        if (!a.enabled) {
            a.el.on(a.eventName, a.handleKeyDown, a);
            a.enabled = true
        }
    },
    disable: function() {
        var a = this;
        if (a.enabled) {
            a.el.removeListener(a.eventName, a.handleKeyDown, a);
            a.enabled = false
        }
    },
    setDisabled: function(a) {
        if (a) {
            this.disable()
        } else {
            this.enable()
        }
    },
    destroy: function(b) {
        var a = this;
        a.bindings = [];
        a.disable();
        if (b === true) {
            a.el.remove()
        }
        delete a.el
    }
});
Ext.define("Ext.util.Observable", {
    requires: ["Ext.util.Event"],
    statics: {
        releaseCapture: function(a) {
            a.fireEvent = this.prototype.fireEvent
        },
        capture: function(c, b, a) {
            c.fireEvent = Ext.Function.createInterceptor(c.fireEvent, b, a)
        },
        observe: function(a, b) {
            if (a) {
                if (!a.isObservable) {
                    Ext.applyIf(a, new this());
                    this.capture(a.prototype, a.fireEvent, a)
                }
                if (Ext.isObject(b)) {
                    a.on(b)
                }
                return a
            }
        }
    },
    isObservable: true,
    constructor: function(a) {
        var b = this;
        Ext.apply(b, a);
        if (b.listeners) {
            b.on(b.listeners);
            delete b.listeners
        }
        b.events = b.events || {};
        if (b.bubbleEvents) {
            b.enableBubble(b.bubbleEvents)
        }
    },
    eventOptionsRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|element|vertical|horizontal|freezeEvent)$/,
    addManagedListener: function(h, d, f, e, c) {
        var g = this,
        a = g.managedListeners = g.managedListeners || [],
        b;
        if (typeof d !== "string") {
            c = d;
            for (d in c) {
                if (c.hasOwnProperty(d)) {
                    b = c[d];
                    if (!g.eventOptionsRe.test(d)) {
                        g.addManagedListener(h, d, b.fn || b, b.scope || c.scope, b.fn ? b: c)
                    }
                }
            }
        } else {
            a.push({
                item: h,
                ename: d,
                fn: f,
                scope: e,
                options: c
            });
            h.on(d, f, e, c)
        }
    },
    removeManagedListener: function(h, c, f, j) {
        var e = this,
        k, b, g, a, d;
        if (typeof c !== "string") {
            k = c;
            for (c in k) {
                if (k.hasOwnProperty(c)) {
                    b = k[c];
                    if (!e.eventOptionsRe.test(c)) {
                        e.removeManagedListener(h, c, b.fn || b, b.scope || k.scope)
                    }
                }
            }
        }
        g = e.managedListeners ? e.managedListeners.slice() : [];
        for (d = 0, a = g.length; d < a; d++) {
            e.removeManagedListenerItem(false, g[d], h, c, f, j)
        }
    },
    fireEvent: function(b) {
        var c = b.toLowerCase(),
        d = this.events,
        e = d && d[c],
        a = e && e.bubble;
        return this.continueFireEvent(c, Ext.Array.slice(arguments, 1), a)
    },
    continueFireEvent: function(c, e, b) {
        var g = this,
        a, f, d = true;
        do {
            if (g.eventsSuspended === true) {
                if ((a = g.eventQueue)) {
                    a.push([c, e, b])
                }
                return d
            } else {
                f = g.events[c];
                if (f && f != true) {
                    if ((d = f.fire.apply(f, e)) === false) {
                        break
                    }
                }
            }
        } while ( b && ( g = g . getBubbleParent ()));
        return d
    },
    getBubbleParent: function() {
        var b = this,
        a = b.getBubbleTarget && b.getBubbleTarget();
        if (a && a.isObservable) {
            return a
        }
        return null
    },
    addListener: function(c, e, d, b) {
        var g = this,
        a, f;
        if (typeof c !== "string") {
            b = c;
            for (c in b) {
                if (b.hasOwnProperty(c)) {
                    a = b[c];
                    if (!g.eventOptionsRe.test(c)) {
                        g.addListener(c, a.fn || a, a.scope || b.scope, a.fn ? a: b)
                    }
                }
            }
        } else {
            c = c.toLowerCase();
            g.events[c] = g.events[c] || true;
            f = g.events[c] || true;
            if (Ext.isBoolean(f)) {
                g.events[c] = f = new Ext.util.Event(g, c)
            }
            f.addListener(e, d, Ext.isObject(b) ? b: {})
        }
    },
    removeListener: function(c, e, d) {
        var g = this,
        b, f, a;
        if (typeof c !== "string") {
            a = c;
            for (c in a) {
                if (a.hasOwnProperty(c)) {
                    b = a[c];
                    if (!g.eventOptionsRe.test(c)) {
                        g.removeListener(c, b.fn || b, b.scope || a.scope)
                    }
                }
            }
        } else {
            c = c.toLowerCase();
            f = g.events[c];
            if (f && f.isEvent) {
                f.removeListener(e, d)
            }
        }
    },
    clearListeners: function() {
        var b = this.events,
        c, a;
        for (a in b) {
            if (b.hasOwnProperty(a)) {
                c = b[a];
                if (c.isEvent) {
                    c.clearListeners()
                }
            }
        }
        this.clearManagedListeners()
    },
    purgeListeners: function() {
        if (Ext.global.console) {
            Ext.global.console.warn("Observable: purgeListeners has been deprecated. Please use clearListeners.")
        }
        return this.clearListeners.apply(this, arguments)
    },
    clearManagedListeners: function() {
        var b = this.managedListeners || [],
        c = 0,
        a = b.length;
        for (; c < a; c++) {
            this.removeManagedListenerItem(true, b[c])
        }
        this.managedListeners = []
    },
    removeManagedListenerItem: function(b, a, f, c, e, d) {
        if (b || (a.item === f && a.ename === c && (!e || a.fn === e) && (!d || a.scope === d))) {
            a.item.un(a.ename, a.fn, a.scope);
            if (!b) {
                Ext.Array.remove(this.managedListeners, a)
            }
        }
    },
    purgeManagedListeners: function() {
        if (Ext.global.console) {
            Ext.global.console.warn("Observable: purgeManagedListeners has been deprecated. Please use clearManagedListeners.")
        }
        return this.clearManagedListeners.apply(this, arguments)
    },
    addEvents: function(e) {
        var d = this,
        b, a, c;
        d.events = d.events || {};
        if (Ext.isString(e)) {
            b = arguments;
            c = b.length;
            while (c--) {
                d.events[b[c]] = d.events[b[c]] || true
            }
        } else {
            Ext.applyIf(d.events, e)
        }
    },
    hasListener: function(a) {
        var b = this.events[a.toLowerCase()];
        return b && b.isEvent === true && b.listeners.length > 0
    },
    suspendEvents: function(a) {
        this.eventsSuspended = true;
        if (a && !this.eventQueue) {
            this.eventQueue = []
        }
    },
    resumeEvents: function() {
        var a = this,
        b = a.eventQueue;
        a.eventsSuspended = false;
        delete a.eventQueue;
        if (b) {
            Ext.each(b,
            function(c) {
                a.continueFireEvent.apply(a, c)
            })
        }
    },
    relayEvents: function(c, e, h) {
        h = h || "";
        var g = this,
        a = e.length,
        d = 0,
        f, b;
        for (; d < a; d++) {
            f = e[d].substr(h.length);
            b = h + f;
            g.events[b] = g.events[b] || true;
            c.on(f, g.createRelayer(b))
        }
    },
    createRelayer: function(a) {
        var b = this;
        return function() {
            return b.fireEvent.apply(b, [a].concat(Array.prototype.slice.call(arguments, 0, -1)))
        }
    },
    enableBubble: function(a) {
        var b = this;
        if (!Ext.isEmpty(a)) {
            a = Ext.isArray(a) ? a: Ext.Array.toArray(arguments);
            Ext.each(a,
            function(c) {
                c = c.toLowerCase();
                var d = b.events[c] || true;
                if (Ext.isBoolean(d)) {
                    d = new Ext.util.Event(b, c);
                    b.events[c] = d
                }
                d.bubble = true
            })
        }
    }
},
function() {
    this.createAlias({
        on: "addListener",
        un: "removeListener",
        mon: "addManagedListener",
        mun: "removeManagedListener"
    });
    this.observeClass = this.observe;
    Ext.apply(Ext.util.Observable.prototype,
    function() {
        function a(j) {
            var h = (this.methodEvents = this.methodEvents || {})[j],
            d,
            c,
            f,
            g = this;
            if (!h) {
                this.methodEvents[j] = h = {};
                h.originalFn = this[j];
                h.methodName = j;
                h.before = [];
                h.after = [];
                var b = function(l, k, e) {
                    if ((c = l.apply(k || g, e)) !== undefined) {
                        if (typeof c == "object") {
                            if (c.returnValue !== undefined) {
                                d = c.returnValue
                            } else {
                                d = c
                            }
                            f = !!c.cancel
                        } else {
                            if (c === false) {
                                f = true
                            } else {
                                d = c
                            }
                        }
                    }
                };
                this[j] = function() {
                    var l = Array.prototype.slice.call(arguments, 0),
                    k,
                    m,
                    e;
                    d = c = undefined;
                    f = false;
                    for (m = 0, e = h.before.length; m < e; m++) {
                        k = h.before[m];
                        b(k.fn, k.scope, l);
                        if (f) {
                            return d
                        }
                    }
                    if ((c = h.originalFn.apply(g, l)) !== undefined) {
                        d = c
                    }
                    for (m = 0, e = h.after.length; m < e; m++) {
                        k = h.after[m];
                        b(k.fn, k.scope, l);
                        if (f) {
                            return d
                        }
                    }
                    return d
                }
            }
            return h
        }
        return {
            beforeMethod: function(d, c, b) {
                a.call(this, d).before.push({
                    fn: c,
                    scope: b
                })
            },
            afterMethod: function(d, c, b) {
                a.call(this, d).after.push({
                    fn: c,
                    scope: b
                })
            },
            removeMethodListener: function(h, f, d) {
                var g = this.getMethodEvent(h),
                c,
                b;
                for (c = 0, b = g.before.length; c < b; c++) {
                    if (g.before[c].fn == f && g.before[c].scope == d) {
                        Ext.Array.erase(g.before, c, 1);
                        return
                    }
                }
                for (c = 0, b = g.after.length; c < b; c++) {
                    if (g.after[c].fn == f && g.after[c].scope == d) {
                        Ext.Array.erase(g.after, c, 1);
                        return
                    }
                }
            },
            toggleEventLogging: function(b) {
                Ext.util.Observable[b ? "capture": "releaseCapture"](this,
                function(c) {
                    if (Ext.isDefined(Ext.global.console)) {
                        Ext.global.console.log(c, arguments)
                    }
                })
            }
        }
    } ())
});
Ext.define("Ext.util.TextMetrics", {
    statics: {
        shared: null,
        measure: function(a, d, e) {
            var b = this,
            c = b.shared;
            if (!c) {
                c = b.shared = new b(a, e)
            }
            c.bind(a);
            c.setFixedWidth(e || "auto");
            return c.getSize(d)
        },
        destroy: function() {
            var a = this;
            Ext.destroy(a.shared);
            a.shared = null
        }
    },
    constructor: function(a, c) {
        var b = this.measure = Ext.getBody().createChild({
            cls: "x-textmetrics"
        });
        this.el = Ext.get(a);
        b.position("absolute");
        b.setLeftTop( - 1000, -1000);
        b.hide();
        if (c) {
            b.setWidth(c)
        }
    },
    getSize: function(c) {
        var b = this.measure,
        a;
        b.update(c);
        a = b.getSize();
        b.update("");
        return a
    },
    bind: function(a) {
        var b = this;
        b.el = Ext.get(a);
        b.measure.setStyle(b.el.getStyles("font-size", "font-style", "font-weight", "font-family", "line-height", "text-transform", "letter-spacing"))
    },
    setFixedWidth: function(a) {
        this.measure.setWidth(a)
    },
    getWidth: function(a) {
        this.measure.dom.style.width = "auto";
        return this.getSize(a).width
    },
    getHeight: function(a) {
        return this.getSize(a).height
    },
    destroy: function() {
        var a = this;
        a.measure.remove();
        delete a.el;
        delete a.measure
    }
},
function() {
    Ext.Element.addMethods({
        getTextWidth: function(c, b, a) {
            return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.value(c, this.dom.innerHTML, true)).width, b || 0, a || 1000000)
        }
    })
});
Ext.define("Ext.data.IdGenerator", {
    isGenerator: true,
    constructor: function(a) {
        var b = this;
        Ext.apply(b, a);
        if (b.id) {
            Ext.data.IdGenerator.all[b.id] = b
        }
    },
    getRecId: function(a) {
        return a.modelName + "-" + a.internalId
    },
    statics: {
        all: {},
        get: function(a) {
            var c, d, b;
            if (typeof a == "string") {
                d = b = a;
                a = null
            } else {
                if (a.isGenerator) {
                    return a
                } else {
                    d = a.id || a.type;
                    b = a.type
                }
            }
            c = this.all[d];
            if (!c) {
                c = Ext.create("idgen." + b, a)
            }
            return c
        }
    }
});
Ext.define("Ext.data.Operation", {
    synchronous: true,
    action: undefined,
    filters: undefined,
    sorters: undefined,
    group: undefined,
    start: undefined,
    limit: undefined,
    batch: undefined,
    callback: undefined,
    scope: undefined,
    started: false,
    running: false,
    complete: false,
    success: undefined,
    exception: false,
    error: undefined,
    actionCommitRecordsRe: /^(?:create|update)$/i,
    actionSkipSyncRe: /^destroy$/i,
    constructor: function(a) {
        Ext.apply(this, a || {})
    },
    commitRecords: function(b) {
        var f = this,
        g, c, d, e, a;
        if (!f.actionSkipSyncRe.test(f.action)) {
            d = f.records;
            if (d && d.length) {
                g = Ext.create("Ext.util.MixedCollection", true,
                function(h) {
                    return h.getId()
                });
                g.addAll(d);
                for (c = b ? b.length: 0; c--;) {
                    e = b[c];
                    a = g.get(e.getId());
                    if (a) {
                        a.beginEdit();
                        a.set(e.data);
                        a.endEdit(true)
                    }
                }
                if (f.actionCommitRecordsRe.test(f.action)) {
                    for (c = d.length; c--;) {
                        d[c].commit()
                    }
                }
            }
        }
    },
    setStarted: function() {
        this.started = true;
        this.running = true
    },
    setCompleted: function() {
        this.complete = true;
        this.running = false
    },
    setSuccessful: function() {
        this.success = true
    },
    setException: function(a) {
        this.exception = true;
        this.success = false;
        this.running = false;
        this.error = a
    },
    hasException: function() {
        return this.exception === true
    },
    getError: function() {
        return this.error
    },
    getRecords: function() {
        var a = this.getResultSet();
        return (a === undefined ? this.records: a.records)
    },
    getResultSet: function() {
        return this.resultSet
    },
    isStarted: function() {
        return this.started === true
    },
    isRunning: function() {
        return this.running === true
    },
    isComplete: function() {
        return this.complete === true
    },
    wasSuccessful: function() {
        return this.isComplete() && this.success === true
    },
    setBatch: function(a) {
        this.batch = a
    },
    allowWrite: function() {
        return this.action != "read"
    }
});
Ext.define("Ext.data.Association", {
    primaryKey: "id",
    defaultReaderType: "json",
    statics: {
        create: function(a) {
            if (!a.isAssociation) {
                if (Ext.isString(a)) {
                    a = {
                        type: a
                    }
                }
                switch (a.type) {
                case "belongsTo":
                    return Ext.create("Ext.data.BelongsToAssociation", a);
                case "hasMany":
                    return Ext.create("Ext.data.HasManyAssociation", a);
                default:
                    Ext.Error.raise('Unknown Association type: "' + a.type + '"')
                }
            }
            return a
        }
    },
    constructor: function(b) {
        Ext.apply(this, b);
        var c = Ext.ModelManager.types,
        d = b.ownerModel,
        f = b.associatedModel,
        e = c[d],
        g = c[f],
        a;
        if (e === undefined) {
            Ext.Error.raise("The configured ownerModel was not valid (you tried " + d + ")")
        }
        if (g === undefined) {
            Ext.Error.raise("The configured associatedModel was not valid (you tried " + f + ")")
        }
        this.ownerModel = e;
        this.associatedModel = g;
        Ext.applyIf(this, {
            ownerName: d,
            associatedName: f
        })
    },
    getReader: function() {
        var c = this,
        a = c.reader,
        b = c.associatedModel;
        if (a) {
            if (Ext.isString(a)) {
                a = {
                    type: a
                }
            }
            if (a.isReader) {
                a.setModel(b)
            } else {
                Ext.applyIf(a, {
                    model: b,
                    type: c.defaultReaderType
                })
            }
            c.reader = Ext.createByAlias("reader." + a.type, a)
        }
        return c.reader || null
    }
});
Ext.define("Ext.data.validations", {
    singleton: true,
    presenceMessage: "must be present",
    lengthMessage: "is the wrong length",
    formatMessage: "is the wrong format",
    inclusionMessage: "is not included in the list of acceptable values",
    exclusionMessage: "is not an acceptable value",
    emailMessage: "is not a valid email address",
    emailRe: /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/,
    presence: function(a, b) {
        if (b === undefined) {
            b = a
        }
        return !! b || b === 0
    },
    length: function(b, e) {
        if (e === undefined || e === null) {
            return false
        }
        var d = e.length,
        c = b.min,
        a = b.max;
        if ((c && d < c) || (a && d > a)) {
            return false
        } else {
            return true
        }
    },
    email: function(b, a) {
        return Ext.data.validations.emailRe.test(a)
    },
    format: function(a, b) {
        return !! (a.matcher && a.matcher.test(b))
    },
    inclusion: function(a, b) {
        return a.list && Ext.Array.indexOf(a.list, b) != -1
    },
    exclusion: function(a, b) {
        return a.list && Ext.Array.indexOf(a.list, b) == -1
    }
});
Ext.define("Ext.form.field.Field", {
    isFormField: true,
    disabled: false,
    submitValue: true,
    validateOnChange: true,
    suspendCheckChange: 0,
    initField: function() {
        this.addEvents("change", "validitychange", "dirtychange");
        this.initValue()
    },
    initValue: function() {
        var a = this;
        a.originalValue = a.lastValue = a.value;
        a.suspendCheckChange++;
        a.setValue(a.value);
        a.suspendCheckChange--
    },
    getName: function() {
        return this.name
    },
    getValue: function() {
        return this.value
    },
    setValue: function(b) {
        var a = this;
        a.value = b;
        a.checkChange();
        return a
    },
    isEqual: function(b, a) {
        return String(b) === String(a)
    },
    isEqualAsString: function(b, a) {
        return String(Ext.value(b, "")) === String(Ext.value(a, ""))
    },
    getSubmitData: function() {
        var a = this,
        b = null;
        if (!a.disabled && a.submitValue && !a.isFileUpload()) {
            b = {};
            b[a.getName()] = "" + a.getValue()
        }
        return b
    },
    getModelData: function() {
        var a = this,
        b = null;
        if (!a.disabled && !a.isFileUpload()) {
            b = {};
            b[a.getName()] = a.getValue()
        }
        return b
    },
    reset: function() {
        var a = this;
        a.setValue(a.originalValue);
        a.clearInvalid();
        delete a.wasValid
    },
    resetOriginalValue: function() {
        this.originalValue = this.getValue();
        this.checkDirty()
    },
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var c = this,
            b = c.getValue(),
            a = c.lastValue;
            if (!c.isEqual(b, a) && !c.isDestroyed) {
                c.lastValue = b;
                c.fireEvent("change", c, b, a);
                c.onChange(b, a)
            }
        }
    },
    onChange: function(b, a) {
        if (this.validateOnChange) {
            this.validate()
        }
        this.checkDirty()
    },
    isDirty: function() {
        var a = this;
        return ! a.disabled && !a.isEqual(a.getValue(), a.originalValue)
    },
    checkDirty: function() {
        var a = this,
        b = a.isDirty();
        if (b !== a.wasDirty) {
            a.fireEvent("dirtychange", a, b);
            a.onDirtyChange(b);
            a.wasDirty = b
        }
    },
    onDirtyChange: Ext.emptyFn,
    getErrors: function(a) {
        return []
    },
    isValid: function() {
        var a = this;
        return a.disabled || Ext.isEmpty(a.getErrors())
    },
    validate: function() {
        var a = this,
        b = a.isValid();
        if (b !== a.wasValid) {
            a.wasValid = b;
            a.fireEvent("validitychange", a, b)
        }
        return b
    },
    batchChanges: function(a) {
        try {
            this.suspendCheckChange++;
            a()
        } catch(b) {
            throw b
        } finally {
            this.suspendCheckChange--
        }
        this.checkChange()
    },
    isFileUpload: function() {
        return false
    },
    extractFileInput: function() {
        return null
    },
    markInvalid: Ext.emptyFn,
    clearInvalid: Ext.emptyFn
});
Ext.define("Ext.util.Offset", {
    statics: {
        fromObject: function(a) {
            return new this(a.x, a.y)
        }
    },
    constructor: function(a, b) {
        this.x = (a != null && !isNaN(a)) ? a: 0;
        this.y = (b != null && !isNaN(b)) ? b: 0;
        return this
    },
    copy: function() {
        return new Ext.util.Offset(this.x, this.y)
    },
    copyFrom: function(a) {
        this.x = a.x;
        this.y = a.y
    },
    toString: function() {
        return "Offset[" + this.x + "," + this.y + "]"
    },
    equals: function(a) {
        if (! (a instanceof this.statics())) {
            Ext.Error.raise("Offset must be an instance of Ext.util.Offset")
        }
        return (this.x == a.x && this.y == a.y)
    },
    round: function(b) {
        if (!isNaN(b)) {
            var a = Math.pow(10, b);
            this.x = Math.round(this.x * a) / a;
            this.y = Math.round(this.y * a) / a
        } else {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y)
        }
    },
    isZero: function() {
        return this.x == 0 && this.y == 0
    }
});
Ext.define("Ext.dd.DragTracker", {
    uses: ["Ext.util.Region"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    active: false,
    trackOver: false,
    tolerance: 5,
    autoStart: false,
    constructor: function(a) {
        Ext.apply(this, a);
        this.addEvents("mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "beforedragstart", "dragstart", "dragend", "drag");
        this.dragRegion = Ext.create("Ext.util.Region", 0, 0, 0, 0);
        if (this.el) {
            this.initEl(this.el)
        }
        this.mixins.observable.constructor.call(this);
        if (this.disabled) {
            this.disable()
        }
    },
    initEl: function(a) {
        this.el = Ext.get(a);
        this.handle = Ext.get(this.delegate);
        this.delegate = this.handle ? undefined: this.delegate;
        if (!this.handle) {
            this.handle = this.el
        }
        this.mon(this.handle, {
            mousedown: this.onMouseDown,
            delegate: this.delegate,
            scope: this
        });
        if (this.trackOver || this.overCls) {
            this.mon(this.handle, {
                mouseover: this.onMouseOver,
                mouseout: this.onMouseOut,
                delegate: this.delegate,
                scope: this
            })
        }
    },
    disable: function() {
        this.disabled = true
    },
    enable: function() {
        this.disabled = false
    },
    destroy: function() {
        this.clearListeners();
        delete this.el
    },
    onMouseOver: function(c, b) {
        var a = this;
        if (!a.disabled) {
            if (Ext.EventManager.contains(c) || a.delegate) {
                a.mouseIsOut = false;
                if (a.overCls) {
                    a.el.addCls(a.overCls)
                }
                a.fireEvent("mouseover", a, c, a.delegate ? c.getTarget(a.delegate, b) : a.handle)
            }
        }
    },
    onMouseOut: function(a) {
        if (this.mouseIsDown) {
            this.mouseIsOut = true
        } else {
            if (this.overCls) {
                this.el.removeCls(this.overCls)
            }
            this.fireEvent("mouseout", this, a)
        }
    },
    onMouseDown: function(b, a) {
        if (this.disabled || b.dragTracked) {
            return
        }
        this.dragTarget = this.delegate ? a: this.handle.dom;
        this.startXY = this.lastXY = b.getXY();
        this.startRegion = Ext.fly(this.dragTarget).getRegion();
        if (this.fireEvent("mousedown", this, b) === false || this.fireEvent("beforedragstart", this, b) === false || this.onBeforeStart(b) === false) {
            return
        }
        this.mouseIsDown = true;
        b.dragTracked = true;
        if (this.preventDefault !== false) {
            b.preventDefault()
        }
        Ext.getDoc().on({
            scope: this,
            mouseup: this.onMouseUp,
            mousemove: this.onMouseMove,
            selectstart: this.stopSelect
        });
        if (this.autoStart) {
            this.timer = Ext.defer(this.triggerStart, this.autoStart === true ? 1000 : this.autoStart, this, [b])
        }
    },
    onMouseMove: function(d, c) {
        if (this.active && Ext.isIE && !d.browserEvent.button) {
            d.preventDefault();
            this.onMouseUp(d);
            return
        }
        d.preventDefault();
        var b = d.getXY(),
        a = this.startXY;
        this.lastXY = b;
        if (!this.active) {
            if (Math.max(Math.abs(a[0] - b[0]), Math.abs(a[1] - b[1])) > this.tolerance) {
                this.triggerStart(d)
            } else {
                return
            }
        }
        if (this.fireEvent("mousemove", this, d) === false) {
            this.onMouseUp(d)
        } else {
            this.onDrag(d);
            this.fireEvent("drag", this, d)
        }
    },
    onMouseUp: function(a) {
        this.mouseIsDown = false;
        if (this.mouseIsOut) {
            this.mouseIsOut = false;
            this.onMouseOut(a)
        }
        a.preventDefault();
        this.fireEvent("mouseup", this, a);
        this.endDrag(a)
    },
    endDrag: function(c) {
        var b = Ext.getDoc(),
        a = this.active;
        b.un("mousemove", this.onMouseMove, this);
        b.un("mouseup", this.onMouseUp, this);
        b.un("selectstart", this.stopSelect, this);
        this.clearStart();
        this.active = false;
        if (a) {
            this.onEnd(c);
            this.fireEvent("dragend", this, c)
        }
        delete this._constrainRegion;
        delete Ext.EventObject.dragTracked
    },
    triggerStart: function(a) {
        this.clearStart();
        this.active = true;
        this.onStart(a);
        this.fireEvent("dragstart", this, a)
    },
    clearStart: function() {
        if (this.timer) {
            clearTimeout(this.timer);
            delete this.timer
        }
    },
    stopSelect: function(a) {
        a.stopEvent();
        return false
    },
    onBeforeStart: function(a) {},
    onStart: function(a) {},
    onDrag: function(a) {},
    onEnd: function(a) {},
    getDragTarget: function() {
        return this.dragTarget
    },
    getDragCt: function() {
        return this.el
    },
    getConstrainRegion: function() {
        if (this.constrainTo) {
            if (this.constrainTo instanceof Ext.util.Region) {
                return this.constrainTo
            }
            if (!this._constrainRegion) {
                this._constrainRegion = Ext.fly(this.constrainTo).getViewRegion()
            }
        } else {
            if (!this._constrainRegion) {
                this._constrainRegion = this.getDragCt().getViewRegion()
            }
        }
        return this._constrainRegion
    },
    getXY: function(a) {
        return a ? this.constrainModes[a](this, this.lastXY) : this.lastXY
    },
    getOffset: function(c) {
        var b = this.getXY(c),
        a = this.startXY;
        return [b[0] - a[0], b[1] - a[1]]
    },
    constrainModes: {
        point: function(b, d) {
            var c = b.dragRegion,
            a = b.getConstrainRegion();
            if (!a) {
                return d
            }
            c.x = c.left = c[0] = c.right = d[0];
            c.y = c.top = c[1] = c.bottom = d[1];
            c.constrainTo(a);
            return [c.left, c.top]
        },
        dragTarget: function(c, f) {
            var b = c.startXY,
            e = c.startRegion.copy(),
            a = c.getConstrainRegion(),
            d;
            if (!a) {
                return f
            }
            e.translateBy(f[0] - b[0], f[1] - b[1]);
            if (e.right > a.right) {
                f[0] += d = (a.right - e.right);
                e.left += d
            }
            if (e.left < a.left) {
                f[0] += (a.left - e.left)
            }
            if (e.bottom > a.bottom) {
                f[1] += d = (a.bottom - e.bottom);
                e.top += d
            }
            if (e.top < a.top) {
                f[1] += (a.top - e.top)
            }
            return f
        }
    }
});
Ext.define("Ext.util.Memento",
function() {
    function d(g, f, h) {
        g[h] = f[h]
    }
    function c(g, f, h) {
        delete g[h]
    }
    function e(h, g, j) {
        var f = h[j];
        if (f || h.hasOwnProperty(j)) {
            a(g, j, f)
        }
    }
    function a(g, h, f) {
        if (Ext.isDefined(f)) {
            g[h] = f
        } else {
            delete g[h]
        }
    }
    function b(f, j, h, g) {
        if (j) {
            if (Ext.isArray(g)) {
                Ext.each(g,
                function(k) {
                    f(j, h, k)
                })
            } else {
                f(j, h, g)
            }
        }
    }
    return {
        data: null,
        target: null,
        constructor: function(g, f) {
            if (g) {
                this.target = g;
                if (f) {
                    this.capture(f)
                }
            }
        },
        capture: function(f, g) {
            b(d, this.data || (this.data = {}), g || this.target, f)
        },
        remove: function(f) {
            b(c, this.data, null, f)
        },
        restore: function(g, f, h) {
            b(e, this.data, h || this.target, g);
            if (f !== false) {
                this.remove(g)
            }
        },
        restoreAll: function(f, j) {
            var h = this,
            g = j || this.target;
            Ext.Object.each(h.data,
            function(l, k) {
                a(g, l, k)
            });
            if (f !== false) {
                delete h.data
            }
        }
    }
} ());
Ext.define("Ext.util.HashMap", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    constructor: function(a) {
        a = a || {};
        var c = this,
        b = a.keyFn;
        c.addEvents("add", "clear", "remove", "replace");
        c.mixins.observable.constructor.call(c, a);
        c.clear(true);
        if (b) {
            c.getKey = b
        }
    },
    getCount: function() {
        return this.length
    },
    getData: function(a, b) {
        if (b === undefined) {
            b = a;
            a = this.getKey(b)
        }
        return [a, b]
    },
    getKey: function(a) {
        return a.id
    },
    add: function(a, d) {
        var b = this,
        c;
        if (arguments.length === 1) {
            d = a;
            a = b.getKey(d)
        }
        if (b.containsKey(a)) {
            return b.replace(a, d)
        }
        c = b.getData(a, d);
        a = c[0];
        d = c[1];
        b.map[a] = d; ++b.length;
        b.fireEvent("add", b, a, d);
        return d
    },
    replace: function(b, d) {
        var c = this,
        e = c.map,
        a;
        if (!c.containsKey(b)) {
            c.add(b, d)
        }
        a = e[b];
        e[b] = d;
        c.fireEvent("replace", c, b, d, a);
        return d
    },
    remove: function(b) {
        var a = this.findKey(b);
        if (a !== undefined) {
            return this.removeAtKey(a)
        }
        return false
    },
    removeAtKey: function(a) {
        var b = this,
        c;
        if (b.containsKey(a)) {
            c = b.map[a];
            delete b.map[a]; --b.length;
            b.fireEvent("remove", b, a, c);
            return true
        }
        return false
    },
    get: function(a) {
        return this.map[a]
    },
    clear: function(a) {
        var b = this;
        b.map = {};
        b.length = 0;
        if (a !== true) {
            b.fireEvent("clear", b)
        }
        return b
    },
    containsKey: function(a) {
        return this.map[a] !== undefined
    },
    contains: function(a) {
        return this.containsKey(this.findKey(a))
    },
    getKeys: function() {
        return this.getArray(true)
    },
    getValues: function() {
        return this.getArray(false)
    },
    getArray: function(d) {
        var a = [],
        b,
        c = this.map;
        for (b in c) {
            if (c.hasOwnProperty(b)) {
                a.push(d ? b: c[b])
            }
        }
        return a
    },
    each: function(d, c) {
        var a = Ext.apply({},
        this.map),
        b,
        e = this.length;
        c = c || this;
        for (b in a) {
            if (a.hasOwnProperty(b)) {
                if (d.call(c, b, a[b], e) === false) {
                    break
                }
            }
        }
        return this
    },
    clone: function() {
        var c = new this.self(),
        b = this.map,
        a;
        c.suspendEvents();
        for (a in b) {
            if (b.hasOwnProperty(a)) {
                c.add(a, b[a])
            }
        }
        c.resumeEvents();
        return c
    },
    findKey: function(b) {
        var a, c = this.map;
        for (a in c) {
            if (c.hasOwnProperty(a) && c[a] === b) {
                return a
            }
        }
        return undefined
    }
});
Ext.define("Ext.ComponentQuery", {
    singleton: true,
    uses: ["Ext.ComponentManager"]
},
function() {
    var g = this,
    k = ["var r = [],", "i = 0,", "it = items,", "l = it.length,", "c;", "for (; i < l; i++) {", "c = it[i];", "if (c.{0}) {", "r.push(c);", "}", "}", "return r;"].join(""),
    e = function(p, o) {
        return o.method.apply(this, [p].concat(o.args))
    },
    a = function(q, u) {
        var o = [],
        r = 0,
        t = q.length,
        s,
        p = u !== ">";
        for (; r < t; r++) {
            s = q[r];
            if (s.getRefItems) {
                o = o.concat(s.getRefItems(p))
            }
        }
        return o
    },
    f = function(p) {
        var o = [],
        q = 0,
        s = p.length,
        r;
        for (; q < s; q++) {
            r = p[q];
            while ( !! (r = (r.ownerCt || r.floatParent))) {
                o.push(r)
            }
        }
        return o
    },
    m = function(p, u, t) {
        if (u === "*") {
            return p.slice()
        } else {
            var o = [],
            q = 0,
            s = p.length,
            r;
            for (; q < s; q++) {
                r = p[q];
                if (r.isXType(u, t)) {
                    o.push(r)
                }
            }
            return o
        }
    },
    j = function(p, s) {
        var u = Ext.Array,
        o = [],
        q = 0,
        t = p.length,
        r;
        for (; q < t; q++) {
            r = p[q];
            if (r.el ? r.el.hasCls(s) : u.contains(r.initCls(), s)) {
                o.push(r)
            }
        }
        return o
    },
    n = function(q, v, p, u) {
        var o = [],
        r = 0,
        t = q.length,
        s;
        for (; r < t; r++) {
            s = q[r];
            if (!u ? !!s[v] : (String(s[v]) === u)) {
                o.push(s)
            }
        }
        return o
    },
    d = function(p, t) {
        var o = [],
        q = 0,
        s = p.length,
        r;
        for (; q < s; q++) {
            r = p[q];
            if (r.getItemId() === t) {
                o.push(r)
            }
        }
        return o
    },
    l = function(o, p, q) {
        return g.pseudos[p](o, q)
    },
    h = /^(\s?([>\^])\s?|\s|$)/,
    c = /^(#)?([\w\-]+|\*)(?:\((true|false)\))?/,
    b = [{
        re: /^\.([\w\-]+)(?:\((true|false)\))?/,
        method: m
    },
    {
        re: /^(?:[\[](?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]])/,
        method: n
    },
    {
        re: /^#([\w\-]+)/,
        method: d
    },
    {
        re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/,
        method: l
    },
    {
        re: /^(?:\{([^\}]+)\})/,
        method: k
    }];
    g.Query = Ext.extend(Object, {
        constructor: function(o) {
            o = o || {};
            Ext.apply(this, o)
        },
        execute: function(p) {
            var r = this.operations,
            s = 0,
            t = r.length,
            q, o;
            if (!p) {
                o = Ext.ComponentManager.all.getArray()
            } else {
                if (Ext.isArray(p)) {
                    o = p
                }
            }
            for (; s < t; s++) {
                q = r[s];
                if (q.mode === "^") {
                    o = f(o || [p])
                } else {
                    if (q.mode) {
                        o = a(o || [p], q.mode)
                    } else {
                        o = e(o || a([p]), q)
                    }
                }
                if (s === t - 1) {
                    return o
                }
            }
            return []
        },
        is: function(q) {
            var p = this.operations,
            t = Ext.isArray(q) ? q: [q],
            o = t.length,
            u = p[p.length - 1],
            s,
            r;
            t = e(t, u);
            if (t.length === o) {
                if (p.length > 1) {
                    for (r = 0, s = t.length; r < s; r++) {
                        if (Ext.Array.indexOf(this.execute(), t[r]) === -1) {
                            return false
                        }
                    }
                }
                return true
            }
            return false
        }
    });
    Ext.apply(this, {
        cache: {},
        pseudos: {
            not: function(u, o) {
                var v = Ext.ComponentQuery,
                s = 0,
                t = u.length,
                r = [],
                q = -1,
                p;
                for (; s < t; ++s) {
                    p = u[s];
                    if (!v.is(p, o)) {
                        r[++q] = p
                    }
                }
                return r
            },
            last: function(o) {
                return o[o.length - 1]
            }
        },
        query: function(p, w) {
            var x = p.split(","),
            o = x.length,
            q = 0,
            r = [],
            y = [],
            v = {},
            t,
            s,
            u;
            for (; q < o; q++) {
                p = Ext.String.trim(x[q]);
                t = this.cache[p];
                if (!t) {
                    this.cache[p] = t = this.parse(p)
                }
                r = r.concat(t.execute(w))
            }
            if (o > 1) {
                s = r.length;
                for (q = 0; q < s; q++) {
                    u = r[q];
                    if (!v[u.id]) {
                        y.push(u);
                        v[u.id] = true
                    }
                }
                r = y
            }
            return r
        },
        is: function(p, o) {
            if (!o) {
                return true
            }
            var q = this.cache[o];
            if (!q) {
                this.cache[o] = q = this.parse(o)
            }
            return q.is(p)
        },
        parse: function(r) {
            var p = [],
            q = b.length,
            v,
            s,
            w,
            x,
            y,
            t,
            u,
            o;
            while (r && v !== r) {
                v = r;
                s = r.match(c);
                if (s) {
                    w = s[1];
                    if (w === "#") {
                        p.push({
                            method: d,
                            args: [Ext.String.trim(s[2])]
                        })
                    } else {
                        if (w === ".") {
                            p.push({
                                method: j,
                                args: [Ext.String.trim(s[2])]
                            })
                        } else {
                            p.push({
                                method: m,
                                args: [Ext.String.trim(s[2]), Boolean(s[3])]
                            })
                        }
                    }
                    r = r.replace(s[0], "")
                }
                while (! (x = r.match(h))) {
                    for (t = 0; r && t < q; t++) {
                        u = b[t];
                        y = r.match(u.re);
                        o = u.method;
                        if (y) {
                            p.push({
                                method: Ext.isString(u.method) ? Ext.functionFactory("items", Ext.String.format.apply(Ext.String, [o].concat(y.slice(1)))) : u.method,
                                args: y.slice(1)
                            });
                            r = r.replace(y[0], "");
                            break
                        }
                        if (t === (q - 1)) {
                            Ext.Error.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"')
                        }
                    }
                }
                if (x[1]) {
                    p.push({
                        mode: x[2] || x[1]
                    });
                    r = r.replace(x[0], "")
                }
            }
            return new g.Query({
                operations: p
            })
        }
    })
});
Ext.define("Ext.util.KeyNav", {
    alternateClassName: "Ext.KeyNav",
    requires: ["Ext.util.KeyMap"],
    statics: {
        keyOptions: {
            left: 37,
            right: 39,
            up: 38,
            down: 40,
            space: 32,
            pageUp: 33,
            pageDown: 34,
            del: 46,
            backspace: 8,
            home: 36,
            end: 35,
            enter: 13,
            esc: 27,
            tab: 9
        }
    },
    constructor: function(b, a) {
        this.setConfig(b, a || {})
    },
    setConfig: function(d, a) {
        if (this.map) {
            this.map.destroy()
        }
        var f = Ext.create("Ext.util.KeyMap", d, null, this.getKeyEvent("forceKeyDown" in a ? a.forceKeyDown: this.forceKeyDown)),
        e = Ext.util.KeyNav.keyOptions,
        c = a.scope || this,
        b;
        this.map = f;
        for (b in e) {
            if (e.hasOwnProperty(b)) {
                if (a[b]) {
                    f.addBinding({
                        scope: c,
                        key: e[b],
                        handler: Ext.Function.bind(this.handleEvent, c, [a[b]], true),
                        defaultEventAction: a.defaultEventAction || this.defaultEventAction
                    })
                }
            }
        }
        f.disable();
        if (!a.disabled) {
            f.enable()
        }
    },
    handleEvent: function(c, b, a) {
        return a.call(this, b)
    },
    disabled: false,
    defaultEventAction: "stopEvent",
    forceKeyDown: false,
    destroy: function(a) {
        this.map.destroy(a);
        delete this.map
    },
    enable: function() {
        this.map.enable();
        this.disabled = false
    },
    disable: function() {
        this.map.disable();
        this.disabled = true
    },
    setDisabled: function(a) {
        this.map.setDisabled(a);
        this.disabled = a
    },
    getKeyEvent: function(a) {
        return (a || Ext.EventManager.useKeyDown) ? "keydown": "keypress"
    }
});
Ext.define("Ext.util.Floating", {
    uses: ["Ext.Layer", "Ext.window.Window"],
    focusOnToFront: true,
    shadow: "sides",
    constructor: function(a) {
        var b = this;
        b.floating = true;
        b.el = Ext.create("Ext.Layer", Ext.apply({},
        a, {
            hideMode: b.hideMode,
            hidden: b.hidden,
            shadow: Ext.isDefined(b.shadow) ? b.shadow: "sides",
            shadowOffset: b.shadowOffset,
            constrain: false,
            shim: b.shim === false ? false: undefined
        }), b.el)
    },
    onFloatRender: function() {
        var a = this;
        a.zIndexParent = a.getZIndexParent();
        a.setFloatParent(a.ownerCt);
        delete a.ownerCt;
        if (a.zIndexParent) {
            a.zIndexParent.registerFloatingItem(a)
        } else {
            Ext.WindowManager.register(a)
        }
    },
    setFloatParent: function(b) {
        var a = this;
        if (a.floatParent) {
            a.mun(a.floatParent, {
                hide: a.onFloatParentHide,
                show: a.onFloatParentShow,
                scope: a
            })
        }
        a.floatParent = b;
        if (b) {
            a.mon(a.floatParent, {
                hide: a.onFloatParentHide,
                show: a.onFloatParentShow,
                scope: a
            })
        }
        if ((a.constrain || a.constrainHeader) && !a.constrainTo) {
            a.constrainTo = b ? b.getTargetEl() : a.container
        }
    },
    onFloatParentHide: function() {
        var a = this;
        if (a.hideOnParentHide !== false) {
            a.showOnParentShow = a.isVisible();
            a.hide()
        }
    },
    onFloatParentShow: function() {
        if (this.showOnParentShow) {
            delete this.showOnParentShow;
            this.show()
        }
    },
    getZIndexParent: function() {
        var a = this.ownerCt,
        b;
        if (a) {
            while (a) {
                b = a;
                a = a.ownerCt
            }
            if (b.floating) {
                return b
            }
        }
    },
    setZIndex: function(a) {
        var b = this;
        b.el.setZIndex(a);
        a += 10;
        if (b.floatingItems) {
            a = Math.floor(b.floatingItems.setBase(a) / 100) * 100 + 10000
        }
        return a
    },
    doConstrain: function(b) {
        var c = this,
        a = c.getConstrainVector(b || c.el.getScopeParent()),
        d;
        if (a) {
            d = c.getPosition();
            d[0] += a[0];
            d[1] += a[1];
            c.setPosition(d)
        }
    },
    getConstrainVector: function(b) {
        var c = this,
        a;
        if (c.constrain || c.constrainHeader) {
            a = c.constrainHeader ? c.header.el: c.el;
            b = b || (c.floatParent && c.floatParent.getTargetEl()) || c.container;
            return a.getConstrainVector(b)
        }
    },
    alignTo: function(b, a, c) {
        if (b.isComponent) {
            b = b.getEl()
        }
        var d = this.el.getAlignToXY(b, a, c);
        this.setPagePosition(d);
        return this
    },
    toFront: function(b) {
        var a = this;
        if (a.zIndexParent) {
            a.zIndexParent.toFront(true)
        }
        if (a.zIndexManager.bringToFront(a)) {
            if (!Ext.isDefined(b)) {
                b = !a.focusOnToFront
            }
            if (!b) {
                a.focus(false, true)
            }
        }
        return a
    },
    setActive: function(b, c) {
        var a = this;
        if (b) {
            if (a.el.shadow && !a.maximized) {
                a.el.enableShadow(true)
            }
            a.fireEvent("activate", a)
        } else {
            if ((a instanceof Ext.window.Window) && (c instanceof Ext.window.Window)) {
                a.el.disableShadow()
            }
            a.fireEvent("deactivate", a)
        }
    },
    toBack: function() {
        this.zIndexManager.sendToBack(this);
        return this
    },
    center: function() {
        var a = this,
        b = a.el.getAlignToXY(a.container, "c-c");
        a.setPagePosition(b);
        return a
    },
    syncShadow: function() {
        if (this.floating) {
            this.el.sync(true)
        }
    },
    fitContainer: function() {
        var c = this.floatParent,
        a = c ? c.getTargetEl() : this.container,
        b = a.getViewSize(false);
        this.setSize(b)
    }
});
Ext.define("Ext.layout.container.boxOverflow.None", {
    alternateClassName: "Ext.layout.boxOverflow.None",
    constructor: function(b, a) {
        this.layout = b;
        Ext.apply(this, a || {})
    },
    handleOverflow: Ext.emptyFn,
    clearOverflow: Ext.emptyFn,
    onRemove: Ext.emptyFn,
    getItem: function(a) {
        return this.layout.owner.getComponent(a)
    },
    onRemove: Ext.emptyFn
});
Ext.define("Ext.data.SortTypes", {
    singleton: true,
    none: function(a) {
        return a
    },
    stripTagsRE: /<\/?[^>]+>/gi,
    asText: function(a) {
        return String(a).replace(this.stripTagsRE, "")
    },
    asUCText: function(a) {
        return String(a).toUpperCase().replace(this.stripTagsRE, "")
    },
    asUCString: function(a) {
        return String(a).toUpperCase()
    },
    asDate: function(a) {
        if (!a) {
            return 0
        }
        if (Ext.isDate(a)) {
            return a.getTime()
        }
        return Date.parse(String(a))
    },
    asFloat: function(a) {
        var b = parseFloat(String(a).replace(/,/g, ""));
        return isNaN(b) ? 0 : b
    },
    asInt: function(a) {
        var b = parseInt(String(a).replace(/,/g, ""), 10);
        return isNaN(b) ? 0 : b
    }
});
Ext.define("Ext.panel.Proxy", {
    alternateClassName: "Ext.dd.PanelProxy",
    constructor: function(a, b) {
        this.panel = a;
        this.id = this.panel.id + "-ddproxy";
        Ext.apply(this, b)
    },
    insertProxy: true,
    setStatus: Ext.emptyFn,
    reset: Ext.emptyFn,
    update: Ext.emptyFn,
    stop: Ext.emptyFn,
    sync: Ext.emptyFn,
    getEl: function() {
        return this.ghost.el
    },
    getGhost: function() {
        return this.ghost
    },
    getProxy: function() {
        return this.proxy
    },
    hide: function() {
        if (this.ghost) {
            if (this.proxy) {
                this.proxy.remove();
                delete this.proxy
            }
            this.panel.unghost(null, false);
            delete this.ghost
        }
    },
    show: function() {
        if (!this.ghost) {
            var a = this.panel.getSize();
            this.panel.el.setVisibilityMode(Ext.Element.DISPLAY);
            this.ghost = this.panel.ghost();
            if (this.insertProxy) {
                this.proxy = this.panel.el.insertSibling({
                    cls: Ext.baseCSSPrefix + "panel-dd-spacer"
                });
                this.proxy.setSize(a)
            }
        }
    },
    repair: function(b, c, a) {
        this.hide();
        if (typeof c == "function") {
            c.call(a || this)
        }
    },
    moveProxy: function(a, b) {
        if (this.proxy) {
            a.insertBefore(this.proxy.dom, b)
        }
    }
});
Ext.define("Ext.fx.CubicBezier", {
    singleton: true,
    cubicBezierAtTime: function(o, d, b, n, m, h) {
        var j = 3 * d,
        l = 3 * (n - d) - j,
        a = 1 - j - l,
        g = 3 * b,
        k = 3 * (m - b) - g,
        p = 1 - g - k;
        function f(q) {
            return ((a * q + l) * q + j) * q
        }
        function c(q, s) {
            var r = e(q, s);
            return ((p * r + k) * r + g) * r
        }
        function e(q, y) {
            var w, v, t, r, u, s;
            for (t = q, s = 0; s < 8; s++) {
                r = f(t) - q;
                if (Math.abs(r) < y) {
                    return t
                }
                u = (3 * a * t + 2 * l) * t + j;
                if (Math.abs(u) < 0.000001) {
                    break
                }
                t = t - r / u
            }
            w = 0;
            v = 1;
            t = q;
            if (t < w) {
                return w
            }
            if (t > v) {
                return v
            }
            while (w < v) {
                r = f(t);
                if (Math.abs(r - q) < y) {
                    return t
                }
                if (q > r) {
                    w = t
                } else {
                    v = t
                }
                t = (v - w) / 2 + w
            }
            return t
        }
        return c(o, 1 / (200 * h))
    },
    cubicBezier: function(b, e, a, c) {
        var d = function(f) {
            return Ext.fx.CubicBezier.cubicBezierAtTime(f, b, e, a, c, 1)
        };
        d.toCSS3 = function() {
            return "cubic-bezier(" + [b, e, a, c].join(",") + ")"
        };
        d.reverse = function() {
            return Ext.fx.CubicBezier.cubicBezier(1 - a, 1 - c, 1 - b, 1 - e)
        };
        return d
    }
});
Ext.define("Ext.ZIndexManager", {
    alternateClassName: "Ext.WindowGroup",
    statics: {
        zBase: 9000
    },
    constructor: function(a) {
        var b = this;
        b.list = {};
        b.zIndexStack = [];
        b.front = null;
        if (a) {
            if (a.isContainer) {
                a.on("resize", b._onContainerResize, b);
                b.zseed = Ext.Number.from(a.getEl().getStyle("zIndex"), b.getNextZSeed());
                b.targetEl = a.getTargetEl();
                b.container = a
            } else {
                Ext.EventManager.onWindowResize(b._onContainerResize, b);
                b.zseed = b.getNextZSeed();
                b.targetEl = Ext.get(a)
            }
        } else {
            Ext.EventManager.onWindowResize(b._onContainerResize, b);
            b.zseed = b.getNextZSeed();
            Ext.onDocumentReady(function() {
                b.targetEl = Ext.getBody()
            })
        }
    },
    getNextZSeed: function() {
        return (Ext.ZIndexManager.zBase += 10000)
    },
    setBase: function(a) {
        this.zseed = a;
        return this.assignZIndices()
    },
    assignZIndices: function() {
        var c = this.zIndexStack,
        b = c.length,
        e = 0,
        f = this.zseed,
        d;
        for (; e < b; e++) {
            d = c[e];
            if (d && !d.hidden) {
                f = d.setZIndex(f)
            }
        }
        this._activateLast();
        return f
    },
    _setActiveChild: function(a) {
        if (a !== this.front) {
            if (this.front) {
                this.front.setActive(false, a)
            }
            this.front = a;
            if (a) {
                a.setActive(true);
                if (a.modal) {
                    this._showModalMask(a)
                }
            }
        }
    },
    _activateLast: function(a) {
        var b, d = false,
        c;
        for (c = this.zIndexStack.length - 1; c >= 0; --c) {
            b = this.zIndexStack[c];
            if (!b.hidden) {
                if (!d) {
                    this._setActiveChild(b);
                    d = true
                }
                if (b.modal) {
                    this._showModalMask(b);
                    return
                }
            }
        }
        this._hideModalMask();
        if (!d) {
            this._setActiveChild(null)
        }
    },
    _showModalMask: function(a) {
        var d = a.el.getStyle("zIndex") - 4,
        b = a.floatParent ? a.floatParent.getTargetEl() : Ext.get(a.getEl().dom.parentNode),
        c;
        if (!b) {
            Ext.global.console && Ext.global.console.warn && Ext.global.console.warn("mask target could not be found. Mask cannot be shown");
            return
        }
        c = b.getBox();
        if (!this.mask) {
            this.mask = Ext.getBody().createChild({
                cls: Ext.baseCSSPrefix + "mask"
            });
            this.mask.setVisibilityMode(Ext.Element.DISPLAY);
            this.mask.on("click", this._onMaskClick, this)
        }
        if (b.dom === document.body) {
            c.height = Ext.Element.getViewHeight()
        }
        b.addCls(Ext.baseCSSPrefix + "body-masked");
        this.mask.setBox(c);
        this.mask.setStyle("zIndex", d);
        this.mask.show()
    },
    _hideModalMask: function() {
        if (this.mask && this.mask.dom.parentNode) {
            Ext.get(this.mask.dom.parentNode).removeCls(Ext.baseCSSPrefix + "body-masked");
            this.mask.hide()
        }
    },
    _onMaskClick: function() {
        if (this.front) {
            this.front.focus()
        }
    },
    _onContainerResize: function() {
        if (this.mask && this.mask.isVisible()) {
            this.mask.setSize(Ext.get(this.mask.dom.parentNode).getViewSize(true))
        }
    },
    register: function(a) {
        if (a.zIndexManager) {
            a.zIndexManager.unregister(a)
        }
        a.zIndexManager = this;
        this.list[a.id] = a;
        this.zIndexStack.push(a);
        a.on("hide", this._activateLast, this)
    },
    unregister: function(a) {
        delete a.zIndexManager;
        if (this.list && this.list[a.id]) {
            delete this.list[a.id];
            a.un("hide", this._activateLast);
            Ext.Array.remove(this.zIndexStack, a);
            this._activateLast(a)
        }
    },
    get: function(a) {
        return typeof a == "object" ? a: this.list[a]
    },
    bringToFront: function(a) {
        a = this.get(a);
        if (a !== this.front) {
            Ext.Array.remove(this.zIndexStack, a);
            this.zIndexStack.push(a);
            this.assignZIndices();
            return true
        }
        if (a.modal) {
            this._showModalMask(a)
        }
        return false
    },
    sendToBack: function(a) {
        a = this.get(a);
        Ext.Array.remove(this.zIndexStack, a);
        this.zIndexStack.unshift(a);
        this.assignZIndices();
        return a
    },
    hideAll: function() {
        for (var a in this.list) {
            if (this.list[a].isComponent && this.list[a].isVisible()) {
                this.list[a].hide()
            }
        }
    },
    hide: function() {
        var b = 0,
        c = this.zIndexStack.length,
        a;
        this.tempHidden = [];
        for (; b < c; b++) {
            a = this.zIndexStack[b];
            if (a.isVisible()) {
                this.tempHidden.push(a);
                a.hide()
            }
        }
    },
    show: function() {
        var c = 0,
        d = this.tempHidden.length,
        b, a, e;
        for (; c < d; c++) {
            b = this.tempHidden[c];
            a = b.x;
            e = b.y;
            b.show();
            b.setPosition(a, e)
        }
        delete this.tempHidden
    },
    getActive: function() {
        return this.front
    },
    getBy: function(e, d) {
        var f = [],
        c = 0,
        a = this.zIndexStack.length,
        b;
        for (; c < a; c++) {
            b = this.zIndexStack[c];
            if (e.call(d || b, b) !== false) {
                f.push(b)
            }
        }
        return f
    },
    each: function(c, b) {
        var a;
        for (var d in this.list) {
            a = this.list[d];
            if (a.isComponent && c.call(b || a, a) === false) {
                return
            }
        }
    },
    eachBottomUp: function(e, d) {
        var b, a = this.zIndexStack,
        c, f;
        for (c = 0, f = a.length; c < f; c++) {
            b = a[c];
            if (b.isComponent && e.call(d || b, b) === false) {
                return
            }
        }
    },
    eachTopDown: function(e, d) {
        var b, a = this.zIndexStack,
        c;
        for (c = a.length; c-->0;) {
            b = a[c];
            if (b.isComponent && e.call(d || b, b) === false) {
                return
            }
        }
    },
    destroy: function() {
        this.each(function(a) {
            a.destroy()
        });
        delete this.zIndexStack;
        delete this.list;
        delete this.container;
        delete this.targetEl
    }
},
function() {
    Ext.WindowManager = Ext.WindowMgr = new this()
});
Ext.define("Ext.layout.Layout", {
    isLayout: true,
    initialized: false,
    statics: {
        create: function(b, c) {
            var a;
            if (b instanceof Ext.layout.Layout) {
                return Ext.createByAlias("layout." + b)
            } else {
                if (!b || typeof b === "string") {
                    a = b || c;
                    b = {}
                } else {
                    a = b.type || c
                }
                return Ext.createByAlias("layout." + a, b || {})
            }
        }
    },
    constructor: function(a) {
        this.id = Ext.id(null, this.type + "-");
        Ext.apply(this, a)
    },
    layout: function() {
        var a = this;
        a.layoutBusy = true;
        a.initLayout();
        if (a.beforeLayout.apply(a, arguments) !== false) {
            a.layoutCancelled = false;
            a.onLayout.apply(a, arguments);
            a.childrenChanged = false;
            a.owner.needsLayout = false;
            a.layoutBusy = false;
            a.afterLayout.apply(a, arguments)
        } else {
            a.layoutCancelled = true
        }
        a.layoutBusy = false;
        a.doOwnerCtLayouts()
    },
    beforeLayout: function() {
        this.renderChildren();
        return true
    },
    renderChildren: function() {
        this.renderItems(this.getLayoutItems(), this.getRenderTarget())
    },
    renderItems: function(a, f) {
        var e = this,
        d = a.length,
        b = 0,
        c;
        for (; b < d; b++) {
            c = a[b];
            if (c && !c.rendered) {
                e.renderItem(c, f, b)
            } else {
                if (!e.isValidParent(c, f, b)) {
                    e.moveItem(c, f, b)
                } else {
                    e.configureItem(c)
                }
            }
        }
    },
    isValidParent: function(b, c, a) {
        var d = b.el ? b.el.dom: Ext.getDom(b);
        if (d && c && c.dom) {
            if (Ext.isNumber(a) && d !== c.dom.childNodes[a]) {
                return false
            }
            return (d.parentNode == (c.dom || c))
        }
        return false
    },
    renderItem: function(c, d, a) {
        var b = this;
        if (!c.rendered) {
            if (b.itemCls) {
                c.addCls(b.itemCls)
            }
            if (b.owner.itemCls) {
                c.addCls(b.owner.itemCls)
            }
            c.render(d, a);
            b.configureItem(c);
            b.childrenChanged = true
        }
    },
    moveItem: function(b, c, a) {
        c = c.dom || c;
        if (typeof a == "number") {
            a = c.childNodes[a]
        }
        c.insertBefore(b.el.dom, a || null);
        b.container = Ext.get(c);
        this.configureItem(b);
        this.childrenChanged = true
    },
    initLayout: function() {
        var a = this,
        b = a.targetCls;
        if (!a.initialized && !Ext.isEmpty(b)) {
            a.getTarget().addCls(b)
        }
        a.initialized = true
    },
    setOwner: function(a) {
        this.owner = a
    },
    getLayoutItems: function() {
        return []
    },
    configureItem: Ext.emptyFn,
    onLayout: Ext.emptyFn,
    afterLayout: Ext.emptyFn,
    onRemove: Ext.emptyFn,
    onDestroy: Ext.emptyFn,
    doOwnerCtLayouts: Ext.emptyFn,
    afterRemove: function(c) {
        var b = c.el,
        a = this.owner,
        e = this.itemCls,
        d = a.itemCls;
        if (c.rendered && !c.isDestroyed) {
            if (e) {
                b.removeCls(e)
            }
            if (d) {
                b.removeCls(d)
            }
        }
        delete c.layoutManagedWidth;
        delete c.layoutManagedHeight
    },
    destroy: function() {
        var b = this.targetCls,
        a;
        if (!Ext.isEmpty(b)) {
            a = this.getTarget();
            if (a) {
                a.removeCls(b)
            }
        }
        this.onDestroy()
    }
});
Ext.define("Ext.util.Sorter", {
    direction: "ASC",
    constructor: function(a) {
        var b = this;
        Ext.apply(b, a);
        if (b.property === undefined && b.sorterFn === undefined) {
            Ext.Error.raise("A Sorter requires either a property or a sorter function")
        }
        b.updateSortFunction()
    },
    createSortFunction: function(b) {
        var c = this,
        d = c.property,
        e = c.direction || "ASC",
        a = e.toUpperCase() == "DESC" ? -1 : 1;
        return function(g, f) {
            return a * b.call(c, g, f)
        }
    },
    defaultSorterFn: function(d, c) {
        var b = this,
        a = b.transform,
        f = b.getRoot(d)[b.property],
        e = b.getRoot(c)[b.property];
        if (a) {
            f = a(f);
            e = a(e)
        }
        return f > e ? 1 : (f < e ? -1 : 0)
    },
    getRoot: function(a) {
        return this.root === undefined ? a: a[this.root]
    },
    setDirection: function(b) {
        var a = this;
        a.direction = b;
        a.updateSortFunction()
    },
    toggle: function() {
        var a = this;
        a.direction = Ext.String.toggle(a.direction, "ASC", "DESC");
        a.updateSortFunction()
    },
    updateSortFunction: function(a) {
        var b = this;
        a = a || b.sorterFn || b.defaultSorterFn;
        b.sort = b.createSortFunction(a)
    }
});
Ext.define("Ext.util.Filter", {
    anyMatch: false,
    exactMatch: false,
    caseSensitive: false,
    constructor: function(a) {
        var b = this;
        Ext.apply(b, a);
        b.filter = b.filter || b.filterFn;
        if (b.filter === undefined) {
            if (b.property === undefined || b.value === undefined) {} else {
                b.filter = b.createFilterFn()
            }
            b.filterFn = b.filter
        }
    },
    createFilterFn: function() {
        var a = this,
        c = a.createValueMatcher(),
        b = a.property;
        return function(d) {
            var e = a.getRoot.call(a, d)[b];
            return c === null ? e === null: c.test(e)
        }
    },
    getRoot: function(b) {
        var a = this.root;
        return a === undefined ? b: b[a]
    },
    createValueMatcher: function() {
        var d = this,
        e = d.value,
        f = d.anyMatch,
        c = d.exactMatch,
        a = d.caseSensitive,
        b = Ext.String.escapeRegex;
        if (e === null) {
            return e
        }
        if (!e.exec) {
            e = String(e);
            if (f === true) {
                e = b(e)
            } else {
                e = "^" + b(e);
                if (c === true) {
                    e += "$"
                }
            }
            e = new RegExp(e, a ? "": "i")
        }
        return e
    }
});
Ext.define("Ext.util.Animate", {
    uses: ["Ext.fx.Manager", "Ext.fx.Anim"],
    animate: function(a) {
        var b = this;
        if (Ext.fx.Manager.hasFxBlock(b.id)) {
            return b
        }
        Ext.fx.Manager.queueFx(Ext.create("Ext.fx.Anim", b.anim(a)));
        return this
    },
    anim: function(a) {
        if (!Ext.isObject(a)) {
            return (a) ? {}: false
        }
        var b = this;
        if (a.stopAnimation) {
            b.stopAnimation()
        }
        Ext.applyIf(a, Ext.fx.Manager.getFxDefaults(b.id));
        return Ext.apply({
            target: b,
            paused: true
        },
        a)
    },
    stopFx: Ext.Function.alias(Ext.util.Animate, "stopAnimation"),
    stopAnimation: function() {
        Ext.fx.Manager.stopAnimation(this.id);
        return this
    },
    syncFx: function() {
        Ext.fx.Manager.setFxDefaults(this.id, {
            concurrent: true
        });
        return this
    },
    sequenceFx: function() {
        Ext.fx.Manager.setFxDefaults(this.id, {
            concurrent: false
        });
        return this
    },
    hasActiveFx: Ext.Function.alias(Ext.util.Animate, "getActiveAnimation"),
    getActiveAnimation: function() {
        return Ext.fx.Manager.getActiveAnimation(this.id)
    }
},
function() {
    Ext.applyIf(Ext.Element.prototype, this.prototype);
    Ext.CompositeElementLite.importElementMethods()
});
Ext.define("Ext.data.Connection", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    statics: {
        requestId: 0
    },
    url: null,
    async: true,
    method: null,
    username: "",
    password: "",
    disableCaching: true,
    withCredentials: false,
    cors: false,
    disableCachingParam: "_dc",
    timeout: 30000,
    useDefaultHeader: true,
    defaultPostHeader: "application/x-www-form-urlencoded; charset=UTF-8",
    useDefaultXhrHeader: true,
    defaultXhrHeader: "XMLHttpRequest",
    constructor: function(a) {
        a = a || {};
        Ext.apply(this, a);
        this.addEvents("beforerequest", "requestcomplete", "requestexception");
        this.requests = {};
        this.mixins.observable.constructor.call(this)
    },
    request: function(k) {
        k = k || {};
        var f = this,
        j = k.scope || window,
        e = k.username || f.username,
        g = k.password || f.password || "",
        b, c, d, a, h;
        if (f.fireEvent("beforerequest", f, k) !== false) {
            c = f.setOptions(k, j);
            if (this.isFormUpload(k) === true) {
                this.upload(k.form, c.url, c.data, k);
                return null
            }
            if (k.autoAbort === true || f.autoAbort) {
                f.abort()
            }
            if ((k.cors === true || f.cors === true) && Ext.isIe && Ext.ieVersion >= 8) {
                h = new XDomainRequest()
            } else {
                h = this.getXhrInstance()
            }
            b = k.async !== false ? (k.async || f.async) : false;
            if (e) {
                h.open(c.method, c.url, b, e, g)
            } else {
                h.open(c.method, c.url, b)
            }
            if (k.withCredentials === true || f.withCredentials === true) {
                h.withCredentials = true
            }
            a = f.setupHeaders(h, k, c.data, c.params);
            d = {
                id: ++Ext.data.Connection.requestId,
                xhr: h,
                headers: a,
                options: k,
                async: b,
                timeout: setTimeout(function() {
                    d.timedout = true;
                    f.abort(d)
                },
                k.timeout || f.timeout)
            };
            f.requests[d.id] = d;
            f.latestId = d.id;
            if (b) {
                h.onreadystatechange = Ext.Function.bind(f.onStateChange, f, [d])
            }
            h.send(c.data);
            if (!b) {
                return this.onComplete(d)
            }
            return d
        } else {
            Ext.callback(k.callback, k.scope, [k, undefined, undefined]);
            return null
        }
    },
    upload: function(d, b, h, k) {
        d = Ext.getDom(d);
        k = k || {};
        var c = Ext.id(),
        f = document.createElement("iframe"),
        j = [],
        g = "multipart/form-data",
        e = {
            target: d.target,
            method: d.method,
            encoding: d.encoding,
            enctype: d.enctype,
            action: d.action
        },
        a;
        Ext.fly(f).set({
            id: c,
            name: c,
            cls: Ext.baseCSSPrefix + "hide-display",
            src: Ext.SSL_SECURE_URL
        });
        document.body.appendChild(f);
        if (document.frames) {
            document.frames[c].name = c
        }
        Ext.fly(d).set({
            target: c,
            method: "POST",
            enctype: g,
            encoding: g,
            action: b || e.action
        });
        if (h) {
            Ext.iterate(Ext.Object.fromQueryString(h),
            function(l, m) {
                a = document.createElement("input");
                Ext.fly(a).set({
                    type: "hidden",
                    value: m,
                    name: l
                });
                d.appendChild(a);
                j.push(a)
            })
        }
        Ext.fly(f).on("load", Ext.Function.bind(this.onUploadComplete, this, [f, k]), null, {
            single: true
        });
        d.submit();
        Ext.fly(d).set(e);
        Ext.each(j,
        function(l) {
            Ext.removeNode(l)
        })
    },
    onUploadComplete: function(h, b) {
        var c = this,
        a = {
            responseText: "",
            responseXML: null
        },
        g,
        f;
        try {
            g = h.contentWindow.document || h.contentDocument || window.frames[h.id].document;
            if (g) {
                if (g.body) {
                    if (/textarea/i.test((f = g.body.firstChild || {}).tagName)) {
                        a.responseText = f.value
                    } else {
                        a.responseText = g.body.innerHTML
                    }
                }
                a.responseXML = g.XMLDocument || g
            }
        } catch(d) {}
        c.fireEvent("requestcomplete", c, a, b);
        Ext.callback(b.success, b.scope, [a, b]);
        Ext.callback(b.callback, b.scope, [b, true, a]);
        setTimeout(function() {
            Ext.removeNode(h)
        },
        100)
    },
    isFormUpload: function(a) {
        var b = this.getForm(a);
        if (b) {
            return (a.isUpload || (/multipart\/form-data/i).test(b.getAttribute("enctype")))
        }
        return false
    },
    getForm: function(a) {
        return Ext.getDom(a.form) || null
    },
    setOptions: function(l, k) {
        var h = this,
        e = l.params || {},
        g = h.extraParams,
        d = l.urlParams,
        c = l.url || h.url,
        j = l.jsonData,
        b, a, f;
        if (Ext.isFunction(e)) {
            e = e.call(k, l)
        }
        if (Ext.isFunction(c)) {
            c = c.call(k, l)
        }
        c = this.setupUrl(l, c);
        if (!c) {
            Ext.Error.raise({
                options: l,
                msg: "No URL specified"
            })
        }
        f = l.rawData || l.xmlData || j || null;
        if (j && !Ext.isPrimitive(j)) {
            f = Ext.encode(f)
        }
        if (Ext.isObject(e)) {
            e = Ext.Object.toQueryString(e)
        }
        if (Ext.isObject(g)) {
            g = Ext.Object.toQueryString(g)
        }
        e = e + ((g) ? ((e) ? "&": "") + g: "");
        d = Ext.isObject(d) ? Ext.Object.toQueryString(d) : d;
        e = this.setupParams(l, e);
        b = (l.method || h.method || ((e || f) ? "POST": "GET")).toUpperCase();
        this.setupMethod(l, b);
        a = l.disableCaching !== false ? (l.disableCaching || h.disableCaching) : false;
        if (b === "GET" && a) {
            c = Ext.urlAppend(c, (l.disableCachingParam || h.disableCachingParam) + "=" + (new Date().getTime()))
        }
        if ((b == "GET" || f) && e) {
            c = Ext.urlAppend(c, e);
            e = null
        }
        if (d) {
            c = Ext.urlAppend(c, d)
        }
        return {
            url: c,
            method: b,
            data: f || e || null
        }
    },
    setupUrl: function(b, a) {
        var c = this.getForm(b);
        if (c) {
            a = a || c.action
        }
        return a
    },
    setupParams: function(a, d) {
        var c = this.getForm(a),
        b;
        if (c && !this.isFormUpload(a)) {
            b = Ext.Element.serializeForm(c);
            d = d ? (d + "&" + b) : b
        }
        return d
    },
    setupMethod: function(a, b) {
        if (this.isFormUpload(a)) {
            return "POST"
        }
        return b
    },
    setupHeaders: function(m, n, d, c) {
        var h = this,
        b = Ext.apply({},
        n.headers || {},
        h.defaultHeaders || {}),
        l = h.defaultPostHeader,
        j = n.jsonData,
        a = n.xmlData,
        k,
        f;
        if (!b["Content-Type"] && (d || c)) {
            if (d) {
                if (n.rawData) {
                    l = "text/plain"
                } else {
                    if (a && Ext.isDefined(a)) {
                        l = "text/xml"
                    } else {
                        if (j && Ext.isDefined(j)) {
                            l = "application/json"
                        }
                    }
                }
            }
            b["Content-Type"] = l
        }
        if (h.useDefaultXhrHeader && !b["X-Requested-With"]) {
            b["X-Requested-With"] = h.defaultXhrHeader
        }
        try {
            for (k in b) {
                if (b.hasOwnProperty(k)) {
                    f = b[k];
                    m.setRequestHeader(k, f)
                }
            }
        } catch(g) {
            h.fireEvent("exception", k, f)
        }
        return b
    },
    getXhrInstance: (function() {
        var b = [function() {
            return new XMLHttpRequest()
        },
        function() {
            return new ActiveXObject("MSXML2.XMLHTTP.3.0")
        },
        function() {
            return new ActiveXObject("MSXML2.XMLHTTP")
        },
        function() {
            return new ActiveXObject("Microsoft.XMLHTTP")
        }],
        c = 0,
        a = b.length,
        f;
        for (; c < a; ++c) {
            try {
                f = b[c];
                f();
                break
            } catch(d) {}
        }
        return f
    })(),
    isLoading: function(a) {
        if (!a) {
            a = this.getLatest()
        }
        if (! (a && a.xhr)) {
            return false
        }
        var b = a.xhr.readyState;
        return ! (b === 0 || b == 4)
    },
    abort: function(b) {
        var a = this;
        if (!b) {
            b = a.getLatest()
        }
        if (b && a.isLoading(b)) {
            b.xhr.onreadystatechange = null;
            b.xhr.abort();
            a.clearTimeout(b);
            if (!b.timedout) {
                b.aborted = true
            }
            a.onComplete(b);
            a.cleanup(b)
        }
    },
    abortAll: function() {
        var b = this.requests,
        a;
        for (a in b) {
            if (b.hasOwnProperty(a)) {
                this.abort(b[a])
            }
        }
    },
    getLatest: function() {
        var b = this.latestId,
        a;
        if (b) {
            a = this.requests[b]
        }
        return a || null
    },
    onStateChange: function(a) {
        if (a.xhr.readyState == 4) {
            this.clearTimeout(a);
            this.onComplete(a);
            this.cleanup(a)
        }
    },
    clearTimeout: function(a) {
        clearTimeout(a.timeout);
        delete a.timeout
    },
    cleanup: function(a) {
        a.xhr = null;
        delete a.xhr
    },
    onComplete: function(f) {
        var d = this,
        c = f.options,
        a, h, b;
        try {
            a = d.parseStatus(f.xhr.status)
        } catch(g) {
            a = {
                success: false,
                isException: false
            }
        }
        h = a.success;
        if (h) {
            b = d.createResponse(f);
            d.fireEvent("requestcomplete", d, b, c);
            Ext.callback(c.success, c.scope, [b, c])
        } else {
            if (a.isException || f.aborted || f.timedout) {
                b = d.createException(f)
            } else {
                b = d.createResponse(f)
            }
            d.fireEvent("requestexception", d, b, c);
            Ext.callback(c.failure, c.scope, [b, c])
        }
        Ext.callback(c.callback, c.scope, [c, h, b]);
        delete d.requests[f.id];
        return b
    },
    parseStatus: function(a) {
        a = a == 1223 ? 204 : a;
        var c = (a >= 200 && a < 300) || a == 304,
        b = false;
        if (!c) {
            switch (a) {
            case 12002:
            case 12029:
            case 12030:
            case 12031:
            case 12152:
            case 13030:
                b = true;
                break
            }
        }
        return {
            success: c,
            isException: b
        }
    },
    createResponse: function(c) {
        var h = c.xhr,
        a = {},
        j = h.getAllResponseHeaders().replace(/\r\n/g, "\n").split("\n"),
        d = j.length,
        k,
        e,
        g,
        f,
        b;
        while (d--) {
            k = j[d];
            e = k.indexOf(":");
            if (e >= 0) {
                g = k.substr(0, e).toLowerCase();
                if (k.charAt(e + 1) == " ") {++e
                }
                a[g] = k.substr(e + 1)
            }
        }
        c.xhr = null;
        delete c.xhr;
        b = {
            request: c,
            requestId: c.id,
            status: h.status,
            statusText: h.statusText,
            getResponseHeader: function(l) {
                return a[l.toLowerCase()]
            },
            getAllResponseHeaders: function() {
                return a
            },
            responseText: h.responseText,
            responseXML: h.responseXML
        };
        h = null;
        return b
    },
    createException: function(a) {
        return {
            request: a,
            requestId: a.id,
            status: a.aborted ? -1 : 0,
            statusText: a.aborted ? "transaction aborted": "communication failure",
            aborted: a.aborted,
            timedout: a.timedout
        }
    }
});
Ext.define("Ext.dd.StatusProxy", {
    animRepair: false,
    constructor: function(a) {
        Ext.apply(this, a);
        this.id = this.id || Ext.id();
        this.proxy = Ext.createWidget("component", {
            floating: true,
            stateful: false,
            id: this.id,
            html: '<div class="' + Ext.baseCSSPrefix + 'dd-drop-icon"></div><div class="' + Ext.baseCSSPrefix + 'dd-drag-ghost"></div>',
            cls: Ext.baseCSSPrefix + "dd-drag-proxy " + this.dropNotAllowed,
            shadow: !a || a.shadow !== false,
            renderTo: document.body
        });
        this.el = this.proxy.el;
        this.el.show();
        this.el.setVisibilityMode(Ext.Element.VISIBILITY);
        this.el.hide();
        this.ghost = Ext.get(this.el.dom.childNodes[1]);
        this.dropStatus = this.dropNotAllowed
    },
    dropAllowed: Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    setStatus: function(a) {
        a = a || this.dropNotAllowed;
        if (this.dropStatus != a) {
            this.el.replaceCls(this.dropStatus, a);
            this.dropStatus = a
        }
    },
    reset: function(a) {
        this.el.dom.className = Ext.baseCSSPrefix + "dd-drag-proxy " + this.dropNotAllowed;
        this.dropStatus = this.dropNotAllowed;
        if (a) {
            this.ghost.update("")
        }
    },
    update: function(a) {
        if (typeof a == "string") {
            this.ghost.update(a)
        } else {
            this.ghost.update("");
            a.style.margin = "0";
            this.ghost.dom.appendChild(a)
        }
        var b = this.ghost.dom.firstChild;
        if (b) {
            Ext.fly(b).setStyle("float", "none")
        }
    },
    getEl: function() {
        return this.el
    },
    getGhost: function() {
        return this.ghost
    },
    hide: function(a) {
        this.proxy.hide();
        if (a) {
            this.reset(true)
        }
    },
    stop: function() {
        if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
            this.anim.stop()
        }
    },
    show: function() {
        this.proxy.show();
        this.proxy.toFront()
    },
    sync: function() {
        this.proxy.el.sync()
    },
    repair: function(b, c, a) {
        this.callback = c;
        this.scope = a;
        if (b && this.animRepair !== false) {
            this.el.addCls(Ext.baseCSSPrefix + "dd-drag-repair");
            this.el.hideUnders(true);
            this.anim = this.el.animate({
                duration: this.repairDuration || 500,
                easing: "ease-out",
                to: {
                    x: b[0],
                    y: b[1]
                },
                stopAnimation: true,
                callback: this.afterRepair,
                scope: this
            })
        } else {
            this.afterRepair()
        }
    },
    afterRepair: function() {
        this.hide(true);
        if (typeof this.callback == "function") {
            this.callback.call(this.scope || this)
        }
        this.callback = null;
        this.scope = null
    },
    destroy: function() {
        Ext.destroy(this.ghost, this.proxy, this.el)
    }
});
Ext.define("Ext.fx.Queue", {
    requires: ["Ext.util.HashMap"],
    constructor: function() {
        this.targets = Ext.create("Ext.util.HashMap");
        this.fxQueue = {}
    },
    getFxDefaults: function(a) {
        var b = this.targets.get(a);
        if (b) {
            return b.fxDefaults
        }
        return {}
    },
    setFxDefaults: function(a, c) {
        var b = this.targets.get(a);
        if (b) {
            b.fxDefaults = Ext.apply(b.fxDefaults || {},
            c)
        }
    },
    stopAnimation: function(b) {
        var d = this,
        a = d.getFxQueue(b),
        c = a.length;
        while (c) {
            a[c - 1].end();
            c--
        }
    },
    getActiveAnimation: function(b) {
        var a = this.getFxQueue(b);
        return (a && !!a.length) ? a[0] : false
    },
    hasFxBlock: function(b) {
        var a = this.getFxQueue(b);
        return a && a[0] && a[0].block
    },
    getFxQueue: function(b) {
        if (!b) {
            return false
        }
        var c = this,
        a = c.fxQueue[b],
        d = c.targets.get(b);
        if (!d) {
            return false
        }
        if (!a) {
            c.fxQueue[b] = [];
            if (d.type != "element") {
                d.target.on("destroy",
                function() {
                    c.fxQueue[b] = []
                })
            }
        }
        return c.fxQueue[b]
    },
    queueFx: function(d) {
        var c = this,
        e = d.target,
        a, b;
        if (!e) {
            return
        }
        a = c.getFxQueue(e.getId());
        b = a.length;
        if (b) {
            if (d.concurrent) {
                d.paused = false
            } else {
                a[b - 1].on("afteranimate",
                function() {
                    d.paused = false
                })
            }
        } else {
            d.paused = false
        }
        d.on("afteranimate",
        function() {
            Ext.Array.remove(a, d);
            if (d.remove) {
                if (e.type == "element") {
                    var f = Ext.get(e.id);
                    if (f) {
                        f.remove()
                    }
                }
            }
        },
        this);
        a.push(d)
    }
});
Ext.define("Ext.fx.target.Target", {
    isAnimTarget: true,
    constructor: function(a) {
        this.target = a;
        this.id = this.getId()
    },
    getId: function() {
        return this.target.id
    }
});
Ext.define("Ext.draw.Color", {
    colorToHexRe: /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/,
    rgbRe: /\s*rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)\s*/,
    hexRe: /\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/,
    lightnessFactor: 0.2,
    constructor: function(d, c, a) {
        var b = this,
        e = Ext.Number.constrain;
        b.r = e(d, 0, 255);
        b.g = e(c, 0, 255);
        b.b = e(a, 0, 255)
    },
    getRed: function() {
        return this.r
    },
    getGreen: function() {
        return this.g
    },
    getBlue: function() {
        return this.b
    },
    getRGB: function() {
        var a = this;
        return [a.r, a.g, a.b]
    },
    getHSL: function() {
        var j = this,
        a = j.r / 255,
        f = j.g / 255,
        k = j.b / 255,
        m = Math.max(a, f, k),
        d = Math.min(a, f, k),
        n = m - d,
        e,
        o = 0,
        c = 0.5 * (m + d);
        if (d != m) {
            o = (c < 0.5) ? n / (m + d) : n / (2 - m - d);
            if (a == m) {
                e = 60 * (f - k) / n
            } else {
                if (f == m) {
                    e = 120 + 60 * (k - a) / n
                } else {
                    e = 240 + 60 * (a - f) / n
                }
            }
            if (e < 0) {
                e += 360
            }
            if (e >= 360) {
                e -= 360
            }
        }
        return [e, o, c]
    },
    getLighter: function(b) {
        var a = this.getHSL();
        b = b || this.lightnessFactor;
        a[2] = Ext.Number.constrain(a[2] + b, 0, 1);
        return this.fromHSL(a[0], a[1], a[2])
    },
    getDarker: function(a) {
        a = a || this.lightnessFactor;
        return this.getLighter( - a)
    },
    toString: function() {
        var f = this,
        c = Math.round,
        e = c(f.r).toString(16),
        d = c(f.g).toString(16),
        a = c(f.b).toString(16);
        e = (e.length == 1) ? "0" + e: e;
        d = (d.length == 1) ? "0" + d: d;
        a = (a.length == 1) ? "0" + a: a;
        return ["#", e, d, a].join("")
    },
    toHex: function(b) {
        if (Ext.isArray(b)) {
            b = b[0]
        }
        if (!Ext.isString(b)) {
            return ""
        }
        if (b.substr(0, 1) === "#") {
            return b
        }
        var e = this.colorToHexRe.exec(b);
        if (Ext.isArray(e)) {
            var f = parseInt(e[2], 10),
            d = parseInt(e[3], 10),
            a = parseInt(e[4], 10),
            c = a | (d << 8) | (f << 16);
            return e[1] + "#" + ("000000" + c.toString(16)).slice( - 6)
        } else {
            return ""
        }
    },
    fromString: function(h) {
        var c, e, d, a, f = parseInt;
        if ((h.length == 4 || h.length == 7) && h.substr(0, 1) === "#") {
            c = h.match(this.hexRe);
            if (c) {
                e = f(c[1], 16) >> 0;
                d = f(c[2], 16) >> 0;
                a = f(c[3], 16) >> 0;
                if (h.length == 4) {
                    e += (e * 16);
                    d += (d * 16);
                    a += (a * 16)
                }
            }
        } else {
            c = h.match(this.rgbRe);
            if (c) {
                e = c[1];
                d = c[2];
                a = c[3]
            }
        }
        return (typeof e == "undefined") ? undefined: Ext.create("Ext.draw.Color", e, d, a)
    },
    getGrayscale: function() {
        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11
    },
    fromHSL: function(f, n, d) {
        var a, b, c, e, j = [],
        k = Math.abs,
        g = Math.floor;
        if (n == 0 || f == null) {
            j = [d, d, d]
        } else {
            f /= 60;
            a = n * (1 - k(2 * d - 1));
            b = a * (1 - k(f - 2 * g(f / 2) - 1));
            c = d - a / 2;
            switch (g(f)) {
            case 0:
                j = [a, b, 0];
                break;
            case 1:
                j = [b, a, 0];
                break;
            case 2:
                j = [0, a, b];
                break;
            case 3:
                j = [0, b, a];
                break;
            case 4:
                j = [b, 0, a];
                break;
            case 5:
                j = [a, 0, b];
                break
            }
            j = [j[0] + c, j[1] + c, j[2] + c]
        }
        return Ext.create("Ext.draw.Color", j[0] * 255, j[1] * 255, j[2] * 255)
    }
},
function() {
    var a = this.prototype;
    this.addStatics({
        fromHSL: function() {
            return a.fromHSL.apply(a, arguments)
        },
        fromString: function() {
            return a.fromString.apply(a, arguments)
        },
        toHex: function() {
            return a.toHex.apply(a, arguments)
        }
    })
});
Ext.define("Ext.data.writer.Writer", {
    alias: "writer.base",
    alternateClassName: ["Ext.data.DataWriter", "Ext.data.Writer"],
    writeAllFields: true,
    nameProperty: "name",
    constructor: function(a) {
        Ext.apply(this, a)
    },
    write: function(e) {
        var c = e.operation,
        b = c.records || [],
        a = b.length,
        d = 0,
        f = [];
        for (; d < a; d++) {
            f.push(this.getRecordData(b[d]))
        }
        return this.writeRecords(e, f)
    },
    getRecordData: function(e) {
        var j = e.phantom === true,
        b = this.writeAllFields || j,
        c = this.nameProperty,
        f = e.fields,
        d = {},
        h, a, g, k;
        if (b) {
            f.each(function(l) {
                if (l.persist) {
                    a = l[c] || l.name;
                    d[a] = e.get(l.name)
                }
            })
        } else {
            h = e.getChanges();
            for (k in h) {
                if (h.hasOwnProperty(k)) {
                    g = f.get(k);
                    a = g[c] || g.name;
                    d[a] = h[k]
                }
            }
            if (!j) {
                d[e.idProperty] = e.getId()
            }
        }
        return d
    }
});
Ext.define("Ext.data.ResultSet", {
    loaded: true,
    count: 0,
    total: 0,
    success: false,
    constructor: function(a) {
        Ext.apply(this, a);
        this.totalRecords = this.total;
        if (a.count === undefined) {
            this.count = this.records.length
        }
    }
});
Ext.define("Ext.state.Provider", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    prefix: "ext-",
    constructor: function(a) {
        a = a || {};
        var b = this;
        Ext.apply(b, a);
        b.addEvents("statechange");
        b.state = {};
        b.mixins.observable.constructor.call(b)
    },
    get: function(b, a) {
        return typeof this.state[b] == "undefined" ? a: this.state[b]
    },
    clear: function(a) {
        var b = this;
        delete b.state[a];
        b.fireEvent("statechange", b, a, null)
    },
    set: function(a, c) {
        var b = this;
        b.state[a] = c;
        b.fireEvent("statechange", b, a, c)
    },
    decodeValue: function(f) {
        var d = this,
        c = /^(a|n|d|b|s|o|e)\:(.*)$/,
        e = c.exec(unescape(f)),
        b,
        a,
        f,
        g;
        if (!e || !e[1]) {
            return
        }
        a = e[1];
        f = e[2];
        switch (a) {
        case "e":
            return null;
        case "n":
            return parseFloat(f);
        case "d":
            return new Date(Date.parse(f));
        case "b":
            return (f == "1");
        case "a":
            b = [];
            if (f != "") {
                Ext.each(f.split("^"),
                function(h) {
                    b.push(d.decodeValue(h))
                },
                d)
            }
            return b;
        case "o":
            b = {};
            if (f != "") {
                Ext.each(f.split("^"),
                function(h) {
                    g = h.split("=");
                    b[g[0]] = d.decodeValue(g[1])
                },
                d)
            }
            return b;
        default:
            return f
        }
    },
    encodeValue: function(e) {
        var f = "",
        d = 0,
        b, a, c;
        if (e == null) {
            return "e:1"
        } else {
            if (typeof e == "number") {
                b = "n:" + e
            } else {
                if (typeof e == "boolean") {
                    b = "b:" + (e ? "1": "0")
                } else {
                    if (Ext.isDate(e)) {
                        b = "d:" + e.toGMTString()
                    } else {
                        if (Ext.isArray(e)) {
                            for (a = e.length; d < a; d++) {
                                f += this.encodeValue(e[d]);
                                if (d != a - 1) {
                                    f += "^"
                                }
                            }
                            b = "a:" + f
                        } else {
                            if (typeof e == "object") {
                                for (c in e) {
                                    if (typeof e[c] != "function" && e[c] !== undefined) {
                                        f += c + "=" + this.encodeValue(e[c]) + "^"
                                    }
                                }
                                b = "o:" + f.substring(0, f.length - 1)
                            } else {
                                b = "s:" + e
                            }
                        }
                    }
                }
            }
        }
        return escape(b)
    }
});
Ext.define("Ext.XTemplate", {
    extend: "Ext.Template",
    argsRe: /<tpl\b[^>]*>((?:(?=([^<]+))\2|<(?!tpl\b[^>]*>))*?)<\/tpl>/,
    nameRe: /^<tpl\b[^>]*?for="(.*?)"/,
    ifRe: /^<tpl\b[^>]*?if="(.*?)"/,
    execRe: /^<tpl\b[^>]*?exec="(.*?)"/,
    constructor: function() {
        this.callParent(arguments);
        var x = this,
        h = x.html,
        u = x.argsRe,
        c = x.nameRe,
        s = x.ifRe,
        w = x.execRe,
        o = 0,
        j = [],
        n = "values",
        v = "parent",
        k = "xindex",
        l = "xcount",
        d = "return ",
        b = "with(values){ ",
        p,
        f,
        t,
        a,
        e,
        g,
        q,
        y,
        r;
        h = ["<tpl>", h, "</tpl>"].join("");
        while ((p = h.match(u))) {
            e = null;
            g = null;
            q = null;
            f = p[0].match(c);
            t = p[0].match(s);
            a = p[0].match(w);
            e = t ? t[1] : null;
            if (e) {
                g = Ext.functionFactory(n, v, k, l, b + "try{" + d + Ext.String.htmlDecode(e) + ";}catch(e){return;}}")
            }
            e = a ? a[1] : null;
            if (e) {
                q = Ext.functionFactory(n, v, k, l, b + Ext.String.htmlDecode(e) + ";}")
            }
            y = f ? f[1] : null;
            if (y) {
                if (y === ".") {
                    y = n
                } else {
                    if (y === "..") {
                        y = v
                    }
                }
                y = Ext.functionFactory(n, v, "try{" + b + d + y + ";}}catch(e){return;}")
            }
            j.push({
                id: o,
                target: y,
                exec: q,
                test: g,
                body: p[1] || ""
            });
            h = h.replace(p[0], "{xtpl" + o + "}");
            o = o + 1
        }
        for (r = j.length - 1; r >= 0; --r) {
            x.compileTpl(j[r])
        }
        x.master = j[j.length - 1];
        x.tpls = j
    },
    applySubTemplate: function(g, a, c, e, f) {
        var d = this,
        b = d.tpls[g];
        return b.compiled.call(d, a, c, e, f)
    },
    codeRe: /\{\[((?:\\\]|.|\n)*?)\]\}/g,
    re: /\{([\w-\.\#]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?\}/g,
    compileTpl: function(tpl) {
        var fm = Ext.util.Format,
        me = this,
        useFormat = me.disableFormats !== true,
        body, bodyReturn, evaluatedFn;
        function fn(m, name, format, args, math) {
            var v;
            if (name.substr(0, 4) == "xtpl") {
                return "',this.applySubTemplate(" + name.substr(4) + ", values, parent, xindex, xcount),'"
            }
            if (name == ".") {
                v = 'Ext.Array.indexOf(["string", "number", "boolean"], typeof values) > -1 || Ext.isDate(values) ? values : ""'
            } else {
                if (name == "#") {
                    v = "xindex"
                } else {
                    if (name.substr(0, 7) == "parent.") {
                        v = name
                    } else {
                        if (name.indexOf(".") != -1) {
                            v = "values." + name
                        } else {
                            v = "values['" + name + "']"
                        }
                    }
                }
            }
            if (math) {
                v = "(" + v + math + ")"
            }
            if (format && useFormat) {
                args = args ? "," + args: "";
                if (format.substr(0, 5) != "this.") {
                    format = "fm." + format + "("
                } else {
                    format = "this." + format.substr(5) + "("
                }
            } else {
                args = "";
                format = "(" + v + " === undefined ? '' : "
            }
            return "'," + format + v + args + "),'"
        }
        function codeFn(m, code) {
            return "',(" + code.replace(me.compileARe, "'") + "),'"
        }
        bodyReturn = tpl.body.replace(me.compileBRe, "\\n").replace(me.compileCRe, "\\'").replace(me.re, fn).replace(me.codeRe, codeFn);
        body = "evaluatedFn = function(values, parent, xindex, xcount){return ['" + bodyReturn + "'].join('');};";
        eval(body);
        tpl.compiled = function(values, parent, xindex, xcount) {
            var vs, length, buffer, i;
            if (tpl.test && !tpl.test.call(me, values, parent, xindex, xcount)) {
                return ""
            }
            vs = tpl.target ? tpl.target.call(me, values, parent) : values;
            if (!vs) {
                return ""
            }
            parent = tpl.target ? values: parent;
            if (tpl.target && Ext.isArray(vs)) {
                buffer = [];
                length = vs.length;
                if (tpl.exec) {
                    for (i = 0; i < length; i++) {
                        buffer[buffer.length] = evaluatedFn.call(me, vs[i], parent, i + 1, length);
                        tpl.exec.call(me, vs[i], parent, i + 1, length)
                    }
                } else {
                    for (i = 0; i < length; i++) {
                        buffer[buffer.length] = evaluatedFn.call(me, vs[i], parent, i + 1, length)
                    }
                }
                return buffer.join("")
            }
            if (tpl.exec) {
                tpl.exec.call(me, vs, parent, xindex, xcount)
            }
            return evaluatedFn.call(me, vs, parent, xindex, xcount)
        };
        return this
    },
    applyTemplate: function(a) {
        return this.master.compiled.call(this, a, {},
        1, 1)
    },
    compile: function() {
        return this
    }
},
function() {
    this.createAlias("apply", "applyTemplate")
});
Ext.define("Ext.app.Controller", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    onClassExtended: function(h, c) {
        var g = Ext.getClassName(h),
        d = g.match(/^(.*)\.controller\./);
        if (d !== null) {
            var a = Ext.Loader.getPrefix(g) || d[1],
            f = c.onBeforeClassCreated,
            j = [],
            b = ["model", "view", "store"],
            e;
            c.onBeforeClassCreated = function(s, m) {
                var n, p, k, q, l, o, r;
                for (n = 0, p = b.length; n < p; n++) {
                    k = b[n];
                    q = Ext.Array.from(m[k + "s"]);
                    for (l = 0, o = q.length; l < o; l++) {
                        r = q[l];
                        e = Ext.Loader.getPrefix(r);
                        if (e === "" || e === r) {
                            j.push(a + "." + k + "." + r)
                        } else {
                            j.push(r)
                        }
                    }
                }
                Ext.require(j, Ext.Function.pass(f, arguments, this))
            }
        }
    },
    constructor: function(a) {
        this.mixins.observable.constructor.call(this, a);
        Ext.apply(this, a || {});
        this.createGetters("model", this.models);
        this.createGetters("store", this.stores);
        this.createGetters("view", this.views);
        if (this.refs) {
            this.ref(this.refs)
        }
    },
    init: function(a) {},
    onLaunch: function(a) {},
    createGetters: function(b, a) {
        b = Ext.String.capitalize(b);
        Ext.Array.each(a,
        function(d) {
            var c = "get",
            e = d.split(".");
            Ext.Array.each(e,
            function(f) {
                c += Ext.String.capitalize(f)
            });
            c += b;
            if (!this[c]) {
                this[c] = Ext.Function.pass(this["get" + b], [d], this)
            }
            this[c](d)
        },
        this)
    },
    ref: function(a) {
        var b = this;
        a = Ext.Array.from(a);
        Ext.Array.each(a,
        function(e) {
            var d = e.ref,
            c = "get" + Ext.String.capitalize(d);
            if (!b[c]) {
                b[c] = Ext.Function.pass(b.getRef, [d, e], b)
            }
        })
    },
    getRef: function(e, f, b) {
        this.refCache = this.refCache || {};
        f = f || {};
        b = b || {};
        Ext.apply(f, b);
        if (f.forceCreate) {
            return Ext.ComponentManager.create(f, "component")
        }
        var d = this,
        a = f.selector,
        c = d.refCache[e];
        if (!c) {
            d.refCache[e] = c = Ext.ComponentQuery.query(f.selector)[0];
            if (!c && f.autoCreate) {
                d.refCache[e] = c = Ext.ComponentManager.create(f, "component")
            }
            if (c) {
                c.on("beforedestroy",
                function() {
                    d.refCache[e] = null
                })
            }
        }
        return c
    },
    control: function(a, b) {
        this.application.control(a, b, this)
    },
    getController: function(a) {
        return this.application.getController(a)
    },
    getStore: function(a) {
        return this.application.getStore(a)
    },
    getModel: function(a) {
        return this.application.getModel(a)
    },
    getView: function(a) {
        return this.application.getView(a)
    }
});
Ext.define("Ext.app.EventBus", {
    requires: ["Ext.util.Event"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    constructor: function() {
        this.mixins.observable.constructor.call(this);
        this.bus = {};
        var a = this;
        Ext.override(Ext.Component, {
            fireEvent: function(b) {
                if (Ext.util.Observable.prototype.fireEvent.apply(this, arguments) !== false) {
                    return a.dispatch.call(a, b, this, arguments)
                }
                return false
            }
        })
    },
    dispatch: function(k, f, j) {
        var g = this.bus,
        l = g[k],
        d,
        c,
        b,
        m,
        a,
        e,
        h;
        if (l) {
            for (d in l) {
                if (f.is(d)) {
                    c = l[d];
                    for (b in c) {
                        m = c[b];
                        for (e = 0, h = m.length; e < h; e++) {
                            a = m[e];
                            if (a.fire.apply(a, Array.prototype.slice.call(j, 1)) === false) {
                                return false
                            }
                        }
                    }
                }
            }
        }
    },
    control: function(d, f, c) {
        var b = this.bus,
        a, e;
        if (Ext.isString(d)) {
            a = d;
            d = {};
            d[a] = f;
            this.control(d, null, c);
            return
        }
        Ext.Object.each(d,
        function(g, h) {
            Ext.Object.each(h,
            function(m, n) {
                var j = {},
                k = c,
                l = Ext.create("Ext.util.Event", c, m);
                if (Ext.isObject(n)) {
                    j = n;
                    n = j.fn;
                    k = j.scope || c;
                    delete j.fn;
                    delete j.scope
                }
                l.addListener(n, k, j);
                b[m] = b[m] || {};
                b[m][g] = b[m][g] || {};
                b[m][g][c.id] = b[m][g][c.id] || [];
                b[m][g][c.id].push(l)
            })
        })
    }
});
Ext.define("Ext.util.ComponentDragger", {
    extend: "Ext.dd.DragTracker",
    autoStart: 500,
    constructor: function(a, b) {
        this.comp = a;
        this.initialConstrainTo = b.constrainTo;
        this.callParent([b])
    },
    onStart: function(c) {
        var b = this,
        a = b.comp;
        this.startPosition = a.getPosition();
        if (a.ghost && !a.liveDrag) {
            b.proxy = a.ghost();
            b.dragTarget = b.proxy.header.el
        }
        if (b.constrain || b.constrainDelegate) {
            b.constrainTo = b.calculateConstrainRegion()
        }
    },
    calculateConstrainRegion: function() {
        var d = this,
        a = d.comp,
        g = d.initialConstrainTo,
        e, f, b = a.el.shadow ? a.el.shadow.offset: 0;
        if (! (g instanceof Ext.util.Region)) {
            g = Ext.fly(g).getViewRegion()
        }
        if (b) {
            g.adjust(0, -b, -b, b)
        }
        if (!d.constrainDelegate) {
            e = Ext.fly(d.dragTarget).getRegion();
            f = d.proxy ? d.proxy.el.getRegion() : a.el.getRegion();
            g.adjust(e.top - f.top, e.right - f.right, e.bottom - f.bottom, e.left - f.left)
        }
        return g
    },
    onDrag: function(c) {
        var b = this,
        a = (b.proxy && !b.comp.liveDrag) ? b.proxy: b.comp,
        d = b.getOffset(b.constrain || b.constrainDelegate ? "dragTarget": null);
        a.setPosition(b.startPosition[0] + d[0], b.startPosition[1] + d[1])
    },
    onEnd: function(a) {
        if (this.proxy && !this.comp.liveDrag) {
            this.comp.unghost()
        }
    }
});
Ext.define("Ext.util.Region", {
    requires: ["Ext.util.Offset"],
    statics: {
        getRegion: function(a) {
            return Ext.fly(a).getPageBox(true)
        },
        from: function(a) {
            return new this(a.top, a.right, a.bottom, a.left)
        }
    },
    constructor: function(d, f, a, c) {
        var e = this;
        e.y = e.top = e[1] = d;
        e.right = f;
        e.bottom = a;
        e.x = e.left = e[0] = c
    },
    contains: function(b) {
        var a = this;
        return (b.x >= a.x && b.right <= a.right && b.y >= a.y && b.bottom <= a.bottom)
    },
    intersect: function(g) {
        var f = this,
        d = Math.max(f.y, g.y),
        e = Math.min(f.right, g.right),
        a = Math.min(f.bottom, g.bottom),
        c = Math.max(f.x, g.x);
        if (a > d && e > c) {
            return new this.self(d, e, a, c)
        } else {
            return false
        }
    },
    union: function(g) {
        var f = this,
        d = Math.min(f.y, g.y),
        e = Math.max(f.right, g.right),
        a = Math.max(f.bottom, g.bottom),
        c = Math.min(f.x, g.x);
        return new this.self(d, e, a, c)
    },
    constrainTo: function(b) {
        var a = this,
        c = Ext.Number.constrain;
        a.top = a.y = c(a.top, b.y, b.bottom);
        a.bottom = c(a.bottom, b.y, b.bottom);
        a.left = a.x = c(a.left, b.x, b.right);
        a.right = c(a.right, b.x, b.right);
        return a
    },
    adjust: function(d, f, a, c) {
        var e = this;
        e.top = e.y += d;
        e.left = e.x += c;
        e.right += f;
        e.bottom += a;
        return e
    },
    getOutOfBoundOffset: function(a, b) {
        if (!Ext.isObject(a)) {
            if (a == "x") {
                return this.getOutOfBoundOffsetX(b)
            } else {
                return this.getOutOfBoundOffsetY(b)
            }
        } else {
            b = a;
            var c = Ext.create("Ext.util.Offset");
            c.x = this.getOutOfBoundOffsetX(b.x);
            c.y = this.getOutOfBoundOffsetY(b.y);
            return c
        }
    },
    getOutOfBoundOffsetX: function(a) {
        if (a <= this.x) {
            return this.x - a
        } else {
            if (a >= this.right) {
                return this.right - a
            }
        }
        return 0
    },
    getOutOfBoundOffsetY: function(a) {
        if (a <= this.y) {
            return this.y - a
        } else {
            if (a >= this.bottom) {
                return this.bottom - a
            }
        }
        return 0
    },
    isOutOfBound: function(a, b) {
        if (!Ext.isObject(a)) {
            if (a == "x") {
                return this.isOutOfBoundX(b)
            } else {
                return this.isOutOfBoundY(b)
            }
        } else {
            b = a;
            return (this.isOutOfBoundX(b.x) || this.isOutOfBoundY(b.y))
        }
    },
    isOutOfBoundX: function(a) {
        return (a < this.x || a > this.right)
    },
    isOutOfBoundY: function(a) {
        return (a < this.y || a > this.bottom)
    },
    restrict: function(b, d, a) {
        if (Ext.isObject(b)) {
            var c;
            a = d;
            d = b;
            if (d.copy) {
                c = d.copy()
            } else {
                c = {
                    x: d.x,
                    y: d.y
                }
            }
            c.x = this.restrictX(d.x, a);
            c.y = this.restrictY(d.y, a);
            return c
        } else {
            if (b == "x") {
                return this.restrictX(d, a)
            } else {
                return this.restrictY(d, a)
            }
        }
    },
    restrictX: function(b, a) {
        if (!a) {
            a = 1
        }
        if (b <= this.x) {
            b -= (b - this.x) * a
        } else {
            if (b >= this.right) {
                b -= (b - this.right) * a
            }
        }
        return b
    },
    restrictY: function(b, a) {
        if (!a) {
            a = 1
        }
        if (b <= this.y) {
            b -= (b - this.y) * a
        } else {
            if (b >= this.bottom) {
                b -= (b - this.bottom) * a
            }
        }
        return b
    },
    getSize: function() {
        return {
            width: this.right - this.x,
            height: this.bottom - this.y
        }
    },
    copy: function() {
        return new this.self(this.y, this.right, this.bottom, this.x)
    },
    copyFrom: function(b) {
        var a = this;
        a.top = a.y = a[1] = b.y;
        a.right = b.right;
        a.bottom = b.bottom;
        a.left = a.x = a[0] = b.x;
        return this
    },
    toString: function() {
        return "Region[" + this.top + "," + this.right + "," + this.bottom + "," + this.left + "]"
    },
    translateBy: function(a, c) {
        if (arguments.length == 1) {
            c = a.y;
            a = a.x
        }
        var b = this;
        b.top = b.y += c;
        b.right += a;
        b.bottom += c;
        b.left = b.x += a;
        return b
    },
    round: function() {
        var a = this;
        a.top = a.y = Math.round(a.y);
        a.right = Math.round(a.right);
        a.bottom = Math.round(a.bottom);
        a.left = a.x = Math.round(a.x);
        return a
    },
    equals: function(a) {
        return (this.top == a.top && this.right == a.right && this.bottom == a.bottom && this.left == a.left)
    }
});
Ext.define("Ext.slider.Thumb", {
    requires: ["Ext.dd.DragTracker", "Ext.util.Format"],
    topZIndex: 10000,
    constructor: function(a) {
        var b = this;
        Ext.apply(b, a || {},
        {
            cls: Ext.baseCSSPrefix + "slider-thumb",
            constrain: false
        });
        b.callParent([a]);
        if (b.slider.vertical) {
            Ext.apply(b, Ext.slider.Thumb.Vertical)
        }
    },
    render: function() {
        var a = this;
        a.el = a.slider.innerEl.insertFirst({
            cls: a.cls
        });
        if (a.disabled) {
            a.disable()
        }
        a.initEvents()
    },
    move: function(b, a) {
        if (!a) {
            this.el.setLeft(b)
        } else {
            Ext.create("Ext.fx.Anim", {
                target: this.el,
                duration: 350,
                to: {
                    left: b
                }
            })
        }
    },
    bringToFront: function() {
        this.el.setStyle("zIndex", this.topZIndex)
    },
    sendToBack: function() {
        this.el.setStyle("zIndex", "")
    },
    enable: function() {
        var a = this;
        a.disabled = false;
        if (a.el) {
            a.el.removeCls(a.slider.disabledCls)
        }
    },
    disable: function() {
        var a = this;
        a.disabled = true;
        if (a.el) {
            a.el.addCls(a.slider.disabledCls)
        }
    },
    initEvents: function() {
        var b = this,
        a = b.el;
        b.tracker = Ext.create("Ext.dd.DragTracker", {
            onBeforeStart: Ext.Function.bind(b.onBeforeDragStart, b),
            onStart: Ext.Function.bind(b.onDragStart, b),
            onDrag: Ext.Function.bind(b.onDrag, b),
            onEnd: Ext.Function.bind(b.onDragEnd, b),
            tolerance: 3,
            autoStart: 300,
            overCls: Ext.baseCSSPrefix + "slider-thumb-over"
        });
        b.tracker.initEl(a)
    },
    onBeforeDragStart: function(a) {
        if (this.disabled) {
            return false
        } else {
            this.slider.promoteThumb(this);
            return true
        }
    },
    onDragStart: function(b) {
        var a = this;
        a.el.addCls(Ext.baseCSSPrefix + "slider-thumb-drag");
        a.dragging = true;
        a.dragStartValue = a.value;
        a.slider.fireEvent("dragstart", a.slider, b, a)
    },
    onDrag: function(g) {
        var d = this,
        c = d.slider,
        b = d.index,
        f = d.getNewValue(),
        a,
        h;
        if (d.constrain) {
            a = c.thumbs[b + 1];
            h = c.thumbs[b - 1];
            if (h !== undefined && f <= h.value) {
                f = h.value
            }
            if (a !== undefined && f >= a.value) {
                f = a.value
            }
        }
        c.setValue(b, f, false);
        c.fireEvent("drag", c, g, d)
    },
    getNewValue: function() {
        var a = this.slider,
        b = a.innerEl.translatePoints(this.tracker.getXY());
        return Ext.util.Format.round(a.reverseValue(b.left), a.decimalPrecision)
    },
    onDragEnd: function(d) {
        var b = this,
        a = b.slider,
        c = b.value;
        b.el.removeCls(Ext.baseCSSPrefix + "slider-thumb-drag");
        b.dragging = false;
        a.fireEvent("dragend", a, d);
        if (b.dragStartValue != c) {
            a.fireEvent("changecomplete", a, c, b)
        }
    },
    destroy: function() {
        Ext.destroy(this.tracker)
    },
    statics: {
        Vertical: {
            getNewValue: function() {
                var b = this.slider,
                c = b.innerEl,
                d = c.translatePoints(this.tracker.getXY()),
                a = c.getHeight() - d.top;
                return Ext.util.Format.round(b.reverseValue(a), b.decimalPrecision)
            },
            move: function(b, a) {
                if (!a) {
                    this.el.setBottom(b)
                } else {
                    Ext.create("Ext.fx.Anim", {
                        target: this.el,
                        duration: 350,
                        to: {
                            bottom: b
                        }
                    })
                }
            }
        }
    }
});
Ext.define("Ext.util.ClickRepeater", {
    extend: "Ext.util.Observable",
    constructor: function(b, a) {
        this.el = Ext.get(b);
        this.el.unselectable();
        Ext.apply(this, a);
        this.addEvents("mousedown", "click", "mouseup");
        if (!this.disabled) {
            this.disabled = true;
            this.enable()
        }
        if (this.handler) {
            this.on("click", this.handler, this.scope || this)
        }
        this.callParent()
    },
    interval: 20,
    delay: 250,
    preventDefault: true,
    stopDefault: false,
    timer: 0,
    enable: function() {
        if (this.disabled) {
            this.el.on("mousedown", this.handleMouseDown, this);
            if (Ext.isIE) {
                this.el.on("dblclick", this.handleDblClick, this)
            }
            if (this.preventDefault || this.stopDefault) {
                this.el.on("click", this.eventOptions, this)
            }
        }
        this.disabled = false
    },
    disable: function(a) {
        if (a || !this.disabled) {
            clearTimeout(this.timer);
            if (this.pressedCls) {
                this.el.removeCls(this.pressedCls)
            }
            Ext.getDoc().un("mouseup", this.handleMouseUp, this);
            this.el.removeAllListeners()
        }
        this.disabled = true
    },
    setDisabled: function(a) {
        this[a ? "disable": "enable"]()
    },
    eventOptions: function(a) {
        if (this.preventDefault) {
            a.preventDefault()
        }
        if (this.stopDefault) {
            a.stopEvent()
        }
    },
    destroy: function() {
        this.disable(true);
        Ext.destroy(this.el);
        this.clearListeners()
    },
    handleDblClick: function(a) {
        clearTimeout(this.timer);
        this.el.blur();
        this.fireEvent("mousedown", this, a);
        this.fireEvent("click", this, a)
    },
    handleMouseDown: function(a) {
        clearTimeout(this.timer);
        this.el.blur();
        if (this.pressedCls) {
            this.el.addCls(this.pressedCls)
        }
        this.mousedownTime = new Date();
        Ext.getDoc().on("mouseup", this.handleMouseUp, this);
        this.el.on("mouseout", this.handleMouseOut, this);
        this.fireEvent("mousedown", this, a);
        this.fireEvent("click", this, a);
        if (this.accelerate) {
            this.delay = 400
        }
        a = new Ext.EventObjectImpl(a);
        this.timer = Ext.defer(this.click, this.delay || this.interval, this, [a])
    },
    click: function(a) {
        this.fireEvent("click", this, a);
        this.timer = Ext.defer(this.click, this.accelerate ? this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime), 400, -390, 12000) : this.interval, this, [a])
    },
    easeOutExpo: function(e, a, g, f) {
        return (e == f) ? a + g: g * ( - Math.pow(2, -10 * e / f) + 1) + a
    },
    handleMouseOut: function() {
        clearTimeout(this.timer);
        if (this.pressedCls) {
            this.el.removeCls(this.pressedCls)
        }
        this.el.on("mouseover", this.handleMouseReturn, this)
    },
    handleMouseReturn: function() {
        this.el.un("mouseover", this.handleMouseReturn, this);
        if (this.pressedCls) {
            this.el.addCls(this.pressedCls)
        }
        this.click()
    },
    handleMouseUp: function(a) {
        clearTimeout(this.timer);
        this.el.un("mouseover", this.handleMouseReturn, this);
        this.el.un("mouseout", this.handleMouseOut, this);
        Ext.getDoc().un("mouseup", this.handleMouseUp, this);
        if (this.pressedCls) {
            this.el.removeCls(this.pressedCls)
        }
        this.fireEvent("mouseup", this, a)
    }
});
Ext.define("Ext.AbstractManager", {
    requires: ["Ext.util.HashMap"],
    typeName: "type",
    constructor: function(a) {
        Ext.apply(this, a || {});
        this.all = Ext.create("Ext.util.HashMap");
        this.types = {}
    },
    get: function(a) {
        return this.all.get(a)
    },
    register: function(c) {
        var b = this.all,
        a = b.getKey(c);
        if (b.containsKey(a)) {
            Ext.Error.raise('Registering duplicate id "' + a + '" with this manager')
        }
        this.all.add(c)
    },
    unregister: function(a) {
        this.all.remove(a)
    },
    registerType: function(b, a) {
        this.types[b] = a;
        a[this.typeName] = b
    },
    isRegistered: function(a) {
        return this.types[a] !== undefined
    },
    create: function(a, d) {
        var b = a[this.typeName] || a.type || d,
        c = this.types[b];
        if (c === undefined) {
            Ext.Error.raise("The '" + b + "' type has not been registered with this manager")
        }
        return new c(a)
    },
    onAvailable: function(e, c, b) {
        var a = this.all,
        d;
        if (a.containsKey(e)) {
            d = a.get(e);
            c.call(b || d, d)
        } else {
            a.on("add",
            function(h, f, g) {
                if (f == e) {
                    c.call(b || g, g);
                    a.un("add", c, b)
                }
            })
        }
    },
    each: function(b, a) {
        this.all.each(b, a || this)
    },
    getCount: function() {
        return this.all.getCount()
    }
});
Ext.define("Ext.ComponentManager", {
    extend: "Ext.AbstractManager",
    alternateClassName: "Ext.ComponentMgr",
    singleton: true,
    typeName: "xtype",
    create: function(b, d) {
        if (b instanceof Ext.AbstractComponent) {
            return b
        } else {
            if (Ext.isString(b)) {
                return Ext.createByAlias("widget." + b)
            } else {
                var c = b.xtype || d,
                a = b;
                return Ext.createByAlias("widget." + c, a)
            }
        }
    },
    registerType: function(b, a) {
        this.types[b] = a;
        a[this.typeName] = b;
        a.prototype[this.typeName] = b
    }
});
Ext.define("Ext.ModelManager", {
    extend: "Ext.AbstractManager",
    alternateClassName: "Ext.ModelMgr",
    requires: ["Ext.data.Association"],
    singleton: true,
    typeName: "mtype",
    associationStack: [],
    registerType: function(c, b) {
        var d = b.prototype,
        a;
        if (d && d.isModel) {
            a = b
        } else {
            if (!b.extend) {
                b.extend = "Ext.data.Model"
            }
            a = Ext.define(c, b)
        }
        this.types[c] = a;
        return a
    },
    onModelDefined: function(c) {
        var a = this.associationStack,
        f = a.length,
        e = [],
        b,
        d,
        g;
        for (d = 0; d < f; d++) {
            b = a[d];
            if (b.associatedModel == c.modelName) {
                e.push(b)
            }
        }
        for (d = 0, f = e.length; d < f; d++) {
            g = e[d];
            this.types[g.ownerModel].prototype.associations.add(Ext.data.Association.create(g));
            Ext.Array.remove(a, g)
        }
    },
    registerDeferredAssociation: function(a) {
        this.associationStack.push(a)
    },
    getModel: function(b) {
        var a = b;
        if (typeof a == "string") {
            a = this.types[a]
        }
        return a
    },
    create: function(c, b, d) {
        var a = typeof b == "function" ? b: this.types[b || c.name];
        return new a(c, d)
    }
},
function() {
    Ext.regModel = function() {
        if (Ext.isDefined(Ext.global.console)) {
            Ext.global.console.warn('Ext.regModel has been deprecated. Models can now be created by extending Ext.data.Model: Ext.define("MyModel", {extend: "Ext.data.Model", fields: []});.')
        }
        return this.ModelManager.registerType.apply(this.ModelManager, arguments)
    }
});
Ext.define("Ext.FocusManager", {
    singleton: true,
    alternateClassName: "Ext.FocusMgr",
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.ComponentManager", "Ext.ComponentQuery", "Ext.util.HashMap", "Ext.util.KeyNav"],
    enabled: false,
    focusElementCls: Ext.baseCSSPrefix + "focus-element",
    focusFrameCls: Ext.baseCSSPrefix + "focus-frame",
    whitelist: ["textfield"],
    tabIndexWhitelist: ["a", "button", "embed", "frame", "iframe", "img", "input", "object", "select", "textarea"],
    constructor: function() {
        var a = this,
        b = Ext.ComponentQuery;
        a.addEvents("beforecomponentfocus", "componentfocus", "disable", "enable");
        a.keyNav = Ext.create("Ext.util.KeyNav", Ext.getDoc(), {
            disabled: true,
            scope: a,
            backspace: a.focusLast,
            enter: a.navigateIn,
            esc: a.navigateOut,
            tab: a.navigateSiblings
        });
        a.focusData = {};
        a.subscribers = Ext.create("Ext.util.HashMap");
        a.focusChain = {};
        Ext.apply(b.pseudos, {
            focusable: function(f) {
                var d = f.length,
                h = [],
                g = 0,
                j,
                e = function(c) {
                    return c && c.focusable !== false && b.is(c, "[rendered]:not([destroying]):not([isDestroyed]):not([disabled]){isVisible(true)}{el && c.el.dom && c.el.isVisible()}")
                };
                for (; g < d; g++) {
                    j = f[g];
                    if (e(j)) {
                        h.push(j)
                    }
                }
                return h
            },
            nextFocus: function(f, e, h) {
                h = h || 1;
                e = parseInt(e, 10);
                var d = f.length,
                g = e + h,
                j;
                for (; g != e; g += h) {
                    if (g >= d) {
                        g = 0
                    } else {
                        if (g < 0) {
                            g = d - 1
                        }
                    }
                    j = f[g];
                    if (b.is(j, ":focusable")) {
                        return [j]
                    } else {
                        if (j.placeholder && b.is(j.placeholder, ":focusable")) {
                            return [j.placeholder]
                        }
                    }
                }
                return []
            },
            prevFocus: function(d, c) {
                return this.nextFocus(d, c, -1)
            },
            root: function(e) {
                var d = e.length,
                g = [],
                f = 0,
                h;
                for (; f < d; f++) {
                    h = e[f];
                    if (!h.ownerCt) {
                        g.push(h)
                    }
                }
                return g
            }
        })
    },
    addXTypeToWhitelist: function(b) {
        var a = this;
        if (Ext.isArray(b)) {
            Ext.Array.forEach(b, a.addXTypeToWhitelist, a);
            return
        }
        if (!Ext.Array.contains(a.whitelist, b)) {
            a.whitelist.push(b)
        }
    },
    clearComponent: function(a) {
        clearTimeout(this.cmpFocusDelay);
        if (!a.isDestroyed) {
            a.blur()
        }
    },
    disable: function() {
        var a = this;
        if (!a.enabled) {
            return
        }
        delete a.options;
        a.enabled = false;
        Ext.ComponentManager.all.un("add", a.onComponentCreated, a);
        a.removeDOM();
        a.keyNav.disable();
        a.setFocusAll(false);
        a.fireEvent("disable", a)
    },
    enable: function(a) {
        var b = this;
        if (a === true) {
            a = {
                focusFrame: true
            }
        }
        b.options = a = a || {};
        if (b.enabled) {
            return
        }
        Ext.ComponentManager.all.on("add", b.onComponentCreated, b);
        b.initDOM(a);
        b.keyNav.enable();
        b.setFocusAll(true, a);
        b.focusEl.focus();
        delete b.focusedCmp;
        b.enabled = true;
        b.fireEvent("enable", b)
    },
    focusLast: function(b) {
        var a = this;
        if (a.isWhitelisted(a.focusedCmp)) {
            return true
        }
        if (a.previousFocusedCmp) {
            a.previousFocusedCmp.focus()
        }
    },
    getRootComponents: function() {
        var a = this,
        c = Ext.ComponentQuery,
        b = c.query(":focusable:root:not([floating])"),
        d = c.query(":focusable:root[floating]");
        d.sort(function(f, e) {
            return f.el.getZIndex() > e.el.getZIndex()
        });
        return d.concat(b)
    },
    initDOM: function(b) {
        var c = this,
        d = "&#160",
        a = c.focusFrameCls;
        if (!Ext.isReady) {
            Ext.onReady(c.initDOM, c);
            return
        }
        if (!c.focusEl) {
            c.focusEl = Ext.getBody().createChild({
                tabIndex: "-1",
                cls: c.focusElementCls,
                html: d
            })
        }
        if (!c.focusFrame && b.focusFrame) {
            c.focusFrame = Ext.getBody().createChild({
                cls: a,
                children: [{
                    cls: a + "-top"
                },
                {
                    cls: a + "-bottom"
                },
                {
                    cls: a + "-left"
                },
                {
                    cls: a + "-right"
                }],
                style: "top: -100px; left: -100px;"
            });
            c.focusFrame.setVisibilityMode(Ext.Element.DISPLAY);
            c.focusFrameWidth = 2;
            c.focusFrame.hide().setLeftTop(0, 0)
        }
    },
    isWhitelisted: function(a) {
        return a && Ext.Array.some(this.whitelist,
        function(b) {
            return a.isXType(b)
        })
    },
    navigateIn: function(d) {
        var b = this,
        a = b.focusedCmp,
        f, c;
        if (!a) {
            f = b.getRootComponents();
            if (f.length) {
                f[0].focus()
            }
        } else {
            c = Ext.ComponentQuery.query(">:focusable", a)[0];
            if (c) {
                c.focus()
            } else {
                if (Ext.isFunction(a.onClick)) {
                    d.button = 0;
                    a.onClick(d);
                    a.focus()
                }
            }
        }
    },
    navigateOut: function(c) {
        var b = this,
        a;
        if (!b.focusedCmp || !(a = b.focusedCmp.up(":focusable"))) {
            b.focusEl.focus()
        } else {
            a.focus()
        }
        return true
    },
    navigateSiblings: function(h, b, n) {
        var j = this,
        a = b || j,
        o = h.getKey(),
        f = Ext.EventObject,
        k = h.shiftKey || o == f.LEFT || o == f.UP,
        c = o == f.LEFT || o == f.RIGHT || o == f.UP || o == f.DOWN,
        g = k ? "prev": "next",
        m,
        d,
        l;
        l = (a.focusedCmp && a.focusedCmp.comp) || a.focusedCmp;
        if (!l && !n) {
            return
        }
        if (c && j.isWhitelisted(l)) {
            return true
        }
        n = n || l.up();
        if (n) {
            m = l ? Ext.Array.indexOf(n.getRefItems(), l) : -1;
            d = Ext.ComponentQuery.query(">:" + g + "Focus(" + m + ")", n)[0];
            if (d && l !== d) {
                d.focus();
                return d
            }
        }
    },
    onComponentBlur: function(b, c) {
        var a = this;
        if (a.focusedCmp === b) {
            a.previousFocusedCmp = b;
            delete a.focusedCmp
        }
        if (a.focusFrame) {
            a.focusFrame.hide()
        }
    },
    onComponentCreated: function(b, c, a) {
        this.setFocus(a, true, this.options)
    },
    onComponentDestroy: function(a) {
        this.setFocus(a, false)
    },
    onComponentFocus: function(o, l) {
        var m = this,
        a = m.focusChain;
        if (!Ext.ComponentQuery.is(o, ":focusable")) {
            m.clearComponent(o);
            if (a[o.id]) {
                return
            }
            var q = o.up();
            if (q) {
                a[o.id] = true;
                q.focus()
            }
            return
        }
        m.focusChain = {};
        clearTimeout(m.cmpFocusDelay);
        if (arguments.length !== 2) {
            m.cmpFocusDelay = Ext.defer(m.onComponentFocus, 90, m, [o, l]);
            return
        }
        if (m.fireEvent("beforecomponentfocus", m, o, m.previousFocusedCmp) === false) {
            m.clearComponent(o);
            return
        }
        m.focusedCmp = o;
        if (m.shouldShowFocusFrame(o)) {
            var s = "." + m.focusFrameCls + "-",
            b = m.focusFrame,
            f = m.focusFrameWidth,
            j = o.el.getPageBox(),
            r = j.top,
            c = j.left,
            n = j.width,
            g = j.height,
            h = b.child(s + "top"),
            d = b.child(s + "bottom"),
            p = b.child(s + "left"),
            k = b.child(s + "right");
            h.setWidth(n).setLeftTop(c, r);
            d.setWidth(n).setLeftTop(c, r + g - f);
            p.setHeight(g - f - f).setLeftTop(c, r + f);
            k.setHeight(g - f - f).setLeftTop(c + n - f, r + f);
            b.show()
        }
        m.fireEvent("componentfocus", m, o, m.previousFocusedCmp)
    },
    onComponentHide: function(e) {
        var d = this,
        f = Ext.ComponentQuery,
        b = false,
        a, c;
        if (d.focusedCmp) {
            a = f.query("[id=" + d.focusedCmp.id + "]", e)[0];
            b = d.focusedCmp.id === e.id || a;
            if (a) {
                d.clearComponent(a)
            }
        }
        d.clearComponent(e);
        if (b) {
            c = f.query("^:focusable", e)[0];
            if (c) {
                c.focus()
            }
        }
    },
    removeDOM: function() {
        var a = this;
        if (a.enabled || a.subscribers.length) {
            return
        }
        Ext.destroy(a.focusEl, a.focusFrame);
        delete a.focusEl;
        delete a.focusFrame;
        delete a.focusFrameWidth
    },
    removeXTypeFromWhitelist: function(b) {
        var a = this;
        if (Ext.isArray(b)) {
            Ext.Array.forEach(b, a.removeXTypeFromWhitelist, a);
            return
        }
        Ext.Array.remove(a.whitelist, b)
    },
    setFocus: function(e, h, b) {
        var d = this,
        c, g, f, a = function(j) {
            return ! Ext.Array.contains(d.tabIndexWhitelist, j.tagName.toLowerCase()) && j.tabIndex <= 0
        };
        b = b || {};
        if (!e.rendered) {
            e.on("afterrender", Ext.pass(d.setFocus, arguments, d), d, {
                single: true
            });
            return
        }
        c = e.getFocusEl();
        g = c.dom;
        if ((h && !d.focusData[e.id]) || (!h && d.focusData[e.id])) {
            if (h) {
                f = {
                    focusFrame: b.focusFrame
                };
                if (a(g)) {
                    f.tabIndex = g.tabIndex;
                    g.tabIndex = -1
                }
                c.on({
                    focus: f.focusFn = Ext.bind(d.onComponentFocus, d, [e], 0),
                    blur: f.blurFn = Ext.bind(d.onComponentBlur, d, [e], 0),
                    scope: d
                });
                e.on({
                    hide: d.onComponentHide,
                    close: d.onComponentHide,
                    beforedestroy: d.onComponentDestroy,
                    scope: d
                });
                d.focusData[e.id] = f
            } else {
                f = d.focusData[e.id];
                if ("tabIndex" in f) {
                    g.tabIndex = f.tabIndex
                }
                c.un("focus", f.focusFn, d);
                c.un("blur", f.blurFn, d);
                e.un("hide", d.onComponentHide, d);
                e.un("close", d.onComponentHide, d);
                e.un("beforedestroy", d.onComponentDestroy, d);
                delete d.focusData[e.id]
            }
        }
    },
    setFocusAll: function(g, c) {
        var f = this,
        b = Ext.ComponentManager.all.getArray(),
        a = b.length,
        e,
        d = 0;
        for (; d < a; d++) {
            f.setFocus(b[d], g, c)
        }
    },
    setupSubscriberKeys: function(a, f) {
        var e = this,
        d = a.getFocusEl(),
        c = f.scope,
        b = {
            backspace: e.focusLast,
            enter: e.navigateIn,
            esc: e.navigateOut,
            scope: e
        },
        g = function(h) {
            if (e.focusedCmp === a) {
                return e.navigateSiblings(h, e, a)
            } else {
                return e.navigateSiblings(h)
            }
        };
        Ext.iterate(f,
        function(j, h) {
            b[j] = function(l) {
                var k = g(l);
                if (Ext.isFunction(h) && h.call(c || a, l, k) === true) {
                    return true
                }
                return k
            }
        },
        e);
        return Ext.create("Ext.util.KeyNav", d, b)
    },
    shouldShowFocusFrame: function(c) {
        var b = this,
        a = b.options || {};
        if (!b.focusFrame || !c) {
            return false
        }
        if (a.focusFrame) {
            return true
        }
        if (b.focusData[c.id].focusFrame) {
            return true
        }
        return false
    },
    subscribe: function(a, c) {
        var f = this,
        e = Ext.Array,
        g = {},
        d = f.subscribers,
        b = function(h) {
            if (h.isContainer && !d.containsKey(h.id)) {
                e.forEach(h.query(">"), b);
                f.setFocus(h, true, c);
                h.on("add", g.onAdd, f)
            } else {
                if (!h.isContainer) {
                    f.setFocus(h, true, c)
                }
            }
        };
        if (!a || !a.isContainer) {
            return
        }
        if (!a.rendered) {
            a.on("afterrender", Ext.pass(f.subscribe, arguments, f), f, {
                single: true
            });
            return
        }
        f.initDOM(c);
        g.keyNav = f.setupSubscriberKeys(a, c.keys);
        g.onAdd = function(j, k, h) {
            b(k)
        };
        a.on("beforedestroy", f.unsubscribe, f);
        b(a);
        d.add(a.id, g)
    },
    unsubscribe: function(a) {
        var e = this,
        d = Ext.Array,
        c = e.subscribers,
        f, b = function(g) {
            if (g.isContainer && !c.containsKey(g.id)) {
                d.forEach(g.query(">"), b);
                e.setFocus(g, false);
                g.un("add", f.onAdd, e)
            } else {
                if (!g.isContainer) {
                    e.setFocus(g, false)
                }
            }
        };
        if (!a || !c.containsKey(a.id)) {
            return
        }
        f = c.get(a.id);
        f.keyNav.destroy();
        a.un("beforedestroy", e.unsubscribe, e);
        c.removeAtKey(a.id);
        b(a);
        e.removeDOM()
    }
});
Ext.define("Ext.form.Labelable", {
    requires: ["Ext.XTemplate"],
    labelableRenderTpl: ['<tpl if="!hideLabel && !(!fieldLabel && hideEmptyLabel)">', '<label id="{id}-labelEl"<tpl if="inputId"> for="{inputId}"</tpl> class="{labelCls}"', '<tpl if="labelStyle"> style="{labelStyle}"</tpl>>', '<tpl if="fieldLabel">{fieldLabel}{labelSeparator}</tpl>', "</label>", "</tpl>", '<div class="{baseBodyCls} {fieldBodyCls}" id="{id}-bodyEl" role="presentation">{subTplMarkup}</div>', '<div id="{id}-errorEl" class="{errorMsgCls}" style="display:none"></div>', '<div class="{clearCls}" role="presentation"><!-- --></div>', {
        compiled: true,
        disableFormats: true
    }],
    activeErrorsTpl: ['<tpl if="errors && errors.length">', '<ul><tpl for="errors"><li<tpl if="xindex == xcount"> class="last"</tpl>>{.}</li></tpl></ul>', "</tpl>"],
    isFieldLabelable: true,
    formItemCls: Ext.baseCSSPrefix + "form-item",
    labelCls: Ext.baseCSSPrefix + "form-item-label",
    errorMsgCls: Ext.baseCSSPrefix + "form-error-msg",
    baseBodyCls: Ext.baseCSSPrefix + "form-item-body",
    fieldBodyCls: "",
    clearCls: Ext.baseCSSPrefix + "clear",
    invalidCls: Ext.baseCSSPrefix + "form-invalid",
    fieldLabel: undefined,
    labelAlign: "left",
    labelWidth: 100,
    labelPad: 5,
    labelSeparator: ":",
    hideLabel: false,
    hideEmptyLabel: true,
    preventMark: false,
    autoFitErrors: true,
    msgTarget: "qtip",
    initLabelable: function() {
        this.addCls(this.formItemCls);
        this.addEvents("errorchange")
    },
    getFieldLabel: function() {
        return this.fieldLabel || ""
    },
    getLabelableRenderData: function() {
        var e = this,
        b = e.labelAlign,
        f = e.labelCls,
        d = e.labelClsExtra,
        c = e.labelPad,
        a;
        if (b === "top") {
            a = "margin-bottom:" + c + "px;"
        } else {
            a = "margin-right:" + c + "px;";
            if (Ext.isBorderBox) {
                a += "width:" + e.labelWidth + "px;"
            }
        }
        return Ext.copyTo({
            inputId: e.getInputId(),
            fieldLabel: e.getFieldLabel(),
            labelCls: d ? f + " " + d: f,
            labelStyle: a + (e.labelStyle || ""),
            subTplMarkup: e.getSubTplMarkup()
        },
        e, "hideLabel,hideEmptyLabel,fieldBodyCls,baseBodyCls,errorMsgCls,clearCls,labelSeparator", true)
    },
    onLabelableRender: function() {
        this.addChildEls("labelEl", "bodyEl", "errorEl")
    },
    getSubTplMarkup: function() {
        return ""
    },
    getInputId: function() {
        return ""
    },
    getActiveError: function() {
        return this.activeError || ""
    },
    hasActiveError: function() {
        return !! this.getActiveError()
    },
    setActiveError: function(a) {
        this.activeError = a;
        this.activeErrors = [a];
        this.renderActiveError()
    },
    getActiveErrors: function() {
        return this.activeErrors || []
    },
    setActiveErrors: function(a) {
        this.activeErrors = a;
        this.activeError = this.getTpl("activeErrorsTpl").apply({
            errors: a
        });
        this.renderActiveError()
    },
    unsetActiveError: function() {
        delete this.activeError;
        delete this.activeErrors;
        this.renderActiveError()
    },
    renderActiveError: function() {
        var c = this,
        b = c.getActiveError(),
        a = !!b;
        if (b !== c.lastActiveError) {
            c.fireEvent("errorchange", c, b);
            c.lastActiveError = b
        }
        if (c.rendered && !c.isDestroyed && !c.preventMark) {
            c.el[a ? "addCls": "removeCls"](c.invalidCls);
            c.getActionEl().dom.setAttribute("aria-invalid", a);
            c.errorEl.dom.innerHTML = b
        }
    },
    setFieldDefaults: function(b) {
        var a = this;
        Ext.iterate(b,
        function(c, d) {
            if (!a.hasOwnProperty(c)) {
                a[c] = d
            }
        })
    },
    getBodyNaturalWidth: function() {
        return this.bodyEl.getWidth()
    }
});
Ext.ns("Ext.fx");
Ext.require("Ext.fx.CubicBezier",
function() {
    var e = Math,
    g = e.PI,
    d = e.pow,
    b = e.sin,
    f = e.sqrt,
    a = e.abs,
    c = 1.70158;
    Ext.fx.Easing = {};
    Ext.apply(Ext.fx.Easing, {
        linear: function(h) {
            return h
        },
        ease: function(l) {
            var h = 0.07813 - l / 2,
            m = -0.25,
            o = f(0.0066 + h * h),
            r = o - h,
            k = d(a(r), 1 / 3) * (r < 0 ? -1 : 1),
            p = -o - h,
            j = d(a(p), 1 / 3) * (p < 0 ? -1 : 1),
            s = k + j + 0.25;
            return d(1 - s, 2) * 3 * s * 0.1 + (1 - s) * 3 * s * s + s * s * s
        },
        easeIn: function(h) {
            return d(h, 1.7)
        },
        easeOut: function(h) {
            return d(h, 0.48)
        },
        easeInOut: function(r) {
            var l = 0.48 - r / 1.04,
            k = f(0.1734 + l * l),
            h = k - l,
            p = d(a(h), 1 / 3) * (h < 0 ? -1 : 1),
            o = -k - l,
            m = d(a(o), 1 / 3) * (o < 0 ? -1 : 1),
            j = p + m + 0.5;
            return (1 - j) * 3 * j * j + j * j * j
        },
        backIn: function(h) {
            return h * h * ((c + 1) * h - c)
        },
        backOut: function(h) {
            h = h - 1;
            return h * h * ((c + 1) * h + c) + 1
        },
        elasticIn: function(k) {
            if (k === 0 || k === 1) {
                return k
            }
            var j = 0.3,
            h = j / 4;
            return d(2, -10 * k) * b((k - h) * (2 * g) / j) + 1
        },
        elasticOut: function(h) {
            return 1 - Ext.fx.Easing.elasticIn(1 - h)
        },
        bounceIn: function(h) {
            return 1 - Ext.fx.Easing.bounceOut(1 - h)
        },
        bounceOut: function(m) {
            var j = 7.5625,
            k = 2.75,
            h;
            if (m < (1 / k)) {
                h = j * m * m
            } else {
                if (m < (2 / k)) {
                    m -= (1.5 / k);
                    h = j * m * m + 0.75
                } else {
                    if (m < (2.5 / k)) {
                        m -= (2.25 / k);
                        h = j * m * m + 0.9375
                    } else {
                        m -= (2.625 / k);
                        h = j * m * m + 0.984375
                    }
                }
            }
            return h
        }
    });
    Ext.apply(Ext.fx.Easing, {
        "back-in": Ext.fx.Easing.backIn,
        "back-out": Ext.fx.Easing.backOut,
        "ease-in": Ext.fx.Easing.easeIn,
        "ease-out": Ext.fx.Easing.easeOut,
        "elastic-in": Ext.fx.Easing.elasticIn,
        "elastic-out": Ext.fx.Easing.elasticIn,
        "bounce-in": Ext.fx.Easing.bounceIn,
        "bounce-out": Ext.fx.Easing.bounceOut,
        "ease-in-out": Ext.fx.Easing.easeInOut
    })
});
Ext.define("Ext.layout.container.AbstractContainer", {
    extend: "Ext.layout.Layout",
    type: "container",
    bindToOwnerCtComponent: false,
    bindToOwnerCtContainer: false,
    setItemSize: function(c, b, a) {
        if (Ext.isObject(b)) {
            a = b.height;
            b = b.width
        }
        c.setCalculatedSize(b, a, this.owner)
    },
    getLayoutItems: function() {
        return this.owner && this.owner.items && this.owner.items.items || []
    },
    beforeLayout: function() {
        return ! this.owner.collapsed && this.callParent(arguments)
    },
    afterLayout: function() {
        this.owner.afterLayout(this)
    },
    getTarget: function() {
        return this.owner.getTargetEl()
    },
    getRenderTarget: function() {
        return this.owner.getTargetEl()
    }
});
Ext.define("Ext.layout.container.Container", {
    extend: "Ext.layout.container.AbstractContainer",
    alternateClassName: "Ext.layout.ContainerLayout",
    layoutItem: function(b, a) {
        if (a) {
            b.doComponentLayout(a.width, a.height)
        } else {
            b.doComponentLayout()
        }
    },
    getLayoutTargetSize: function() {
        var b = this.getTarget(),
        a;
        if (b) {
            a = b.getViewSize();
            if (Ext.isIE && a.width == 0) {
                a = b.getStyleSize()
            }
            a.width -= b.getPadding("lr");
            a.height -= b.getPadding("tb")
        }
        return a
    },
    beforeLayout: function() {
        if (this.owner.beforeLayout(arguments) !== false) {
            return this.callParent(arguments)
        } else {
            return false
        }
    },
    getRenderedItems: function() {
        var e = this,
        g = e.getTarget(),
        a = e.getLayoutItems(),
        d = a.length,
        f = [],
        b,
        c;
        for (b = 0; b < d; b++) {
            c = a[b];
            if (c.rendered && e.isValidParent(c, g, b)) {
                f.push(c)
            }
        }
        return f
    },
    getVisibleItems: function() {
        var f = this.getTarget(),
        b = this.getLayoutItems(),
        e = b.length,
        a = [],
        c,
        d;
        for (c = 0; c < e; c++) {
            d = b[c];
            if (d.rendered && this.isValidParent(d, f, c) && d.hidden !== true) {
                a.push(d)
            }
        }
        return a
    }
});
Ext.define("Ext.layout.container.Anchor", {
    alias: "layout.anchor",
    extend: "Ext.layout.container.Container",
    alternateClassName: "Ext.layout.AnchorLayout",
    type: "anchor",
    defaultAnchor: "100%",
    parseAnchorRE: /^(r|right|b|bottom)$/i,
    onLayout: function() {
        this.callParent(arguments);
        var r = this,
        l = r.getLayoutTargetSize(),
        a = r.owner,
        t = r.getTarget(),
        s = l.width,
        j = l.height,
        m = t.getStyle("overflow"),
        k = r.getVisibleItems(a),
        p = k.length,
        e = [],
        g,
        n,
        h,
        f,
        c,
        d,
        o,
        b,
        q;
        if (s < 20 && j < 20) {
            return
        }
        if (!r.clearEl) {
            r.clearEl = t.createChild({
                cls: Ext.baseCSSPrefix + "clear",
                role: "presentation"
            })
        }
        if (!Ext.supports.RightMargin) {
            q = Ext.Element.getRightMarginFixCleaner(t);
            t.addCls(Ext.baseCSSPrefix + "inline-children")
        }
        for (o = 0; o < p; o++) {
            h = k[o];
            b = h.el;
            f = h.anchorSpec;
            if (f) {
                if (f.right) {
                    c = r.adjustWidthAnchor(f.right(s) - b.getMargin("lr"), h)
                } else {
                    c = undefined
                }
                if (f.bottom) {
                    d = r.adjustHeightAnchor(f.bottom(j) - b.getMargin("tb"), h)
                } else {
                    d = undefined
                }
                e.push({
                    component: h,
                    anchor: true,
                    width: c || undefined,
                    height: d || undefined
                })
            } else {
                e.push({
                    component: h,
                    anchor: false
                })
            }
        }
        if (!Ext.supports.RightMargin) {
            t.removeCls(Ext.baseCSSPrefix + "inline-children");
            q()
        }
        for (o = 0; o < p; o++) {
            g = e[o];
            r.setItemSize(g.component, g.width, g.height)
        }
        if (m && m != "hidden" && !r.adjustmentPass) {
            n = r.getLayoutTargetSize();
            if (n.width != l.width || n.height != l.height) {
                r.adjustmentPass = true;
                r.onLayout()
            }
        }
        delete r.adjustmentPass
    },
    parseAnchor: function(c, f, b) {
        if (c && c != "none") {
            var d;
            if (this.parseAnchorRE.test(c)) {
                var e = b - f;
                return function(a) {
                    return a - e
                }
            } else {
                if (c.indexOf("%") != -1) {
                    d = parseFloat(c.replace("%", "")) * 0.01;
                    return function(a) {
                        return Math.floor(a * d)
                    }
                } else {
                    c = parseInt(c, 10);
                    if (!isNaN(c)) {
                        return function(a) {
                            return a + c
                        }
                    }
                }
            }
        }
        return null
    },
    adjustWidthAnchor: function(b, a) {
        return b
    },
    adjustHeightAnchor: function(b, a) {
        return b
    },
    configureItem: function(f) {
        var e = this,
        a = e.owner,
        d = f.anchor,
        b, h, c, g;
        if (!f.anchor && f.items && !Ext.isNumber(f.width) && !(Ext.isIE6 && Ext.isStrict)) {
            f.anchor = d = e.defaultAnchor
        }
        if (a.anchorSize) {
            if (typeof a.anchorSize == "number") {
                c = a.anchorSize
            } else {
                c = a.anchorSize.width;
                g = a.anchorSize.height
            }
        } else {
            c = a.initialConfig.width;
            g = a.initialConfig.height
        }
        if (d) {
            b = d.split(" ");
            f.anchorSpec = h = {
                right: e.parseAnchor(b[0], f.initialConfig.width, c),
                bottom: e.parseAnchor(b[1], f.initialConfig.height, g)
            };
            if (h.right) {
                f.layoutManagedWidth = 1
            } else {
                f.layoutManagedWidth = 2
            }
            if (h.bottom) {
                f.layoutManagedHeight = 1
            } else {
                f.layoutManagedHeight = 2
            }
        } else {
            f.layoutManagedWidth = 2;
            f.layoutManagedHeight = 2
        }
        this.callParent(arguments)
    }
});
Ext.define("Ext.layout.component.Component", {
    extend: "Ext.layout.Layout",
    type: "component",
    monitorChildren: true,
    initLayout: function() {
        var c = this,
        a = c.owner,
        b = a.el;
        if (!c.initialized) {
            if (a.frameSize) {
                c.frameSize = a.frameSize
            } else {
                a.frameSize = c.frameSize = {
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0
                }
            }
        }
        c.callParent(arguments)
    },
    beforeLayout: function(b, k, l, h) {
        this.callParent(arguments);
        var g = this,
        c = g.owner,
        d = c.ownerCt,
        f = c.layout,
        e = c.isVisible(true),
        a = c.el.child,
        j;
        g.previousComponentSize = g.lastComponentSize;
        if (!l && ((!Ext.isNumber(b) && c.isFixedWidth()) || (!Ext.isNumber(k) && c.isFixedHeight())) && h && h !== d) {
            g.doContainerLayout();
            return false
        }
        if (!e && (c.hiddenAncestor || c.floating)) {
            if (c.hiddenAncestor) {
                j = c.hiddenAncestor.layoutOnShow;
                j.remove(c);
                j.add(c)
            }
            c.needsLayout = {
                width: b,
                height: k,
                isSetSize: false
            }
        }
        if (e && this.needsLayout(b, k)) {
            return c.beforeComponentLayout(b, k, l, h)
        } else {
            return false
        }
    },
    needsLayout: function(d, a) {
        var e = this,
        c, b;
        e.lastComponentSize = e.lastComponentSize || {
            width: -Infinity,
            height: -Infinity
        };
        c = !Ext.isDefined(d) || e.lastComponentSize.width !== d;
        b = !Ext.isDefined(a) || e.lastComponentSize.height !== a;
        return ! e.isSizing && (e.childrenChanged || c || b)
    },
    setElementSize: function(c, b, a) {
        if (b !== undefined && a !== undefined) {
            c.setSize(b, a)
        } else {
            if (a !== undefined) {
                c.setHeight(a)
            } else {
                if (b !== undefined) {
                    c.setWidth(b)
                }
            }
        }
    },
    getTarget: function() {
        return this.owner.el
    },
    getRenderTarget: function() {
        return this.owner.el
    },
    setTargetSize: function(d, a) {
        var e = this;
        e.setElementSize(e.owner.el, d, a);
        if (e.owner.frameBody) {
            var g = e.getTargetInfo(),
            f = g.padding,
            c = g.border,
            b = e.frameSize;
            e.setElementSize(e.owner.frameBody, Ext.isNumber(d) ? (d - b.left - b.right - f.left - f.right - c.left - c.right) : d, Ext.isNumber(a) ? (a - b.top - b.bottom - f.top - f.bottom - c.top - c.bottom) : a)
        }
        e.autoSized = {
            width: !Ext.isNumber(d),
            height: !Ext.isNumber(a)
        };
        e.lastComponentSize = {
            width: d,
            height: a
        }
    },
    getTargetInfo: function() {
        if (!this.targetInfo) {
            var b = this.getTarget(),
            a = this.owner.getTargetEl();
            this.targetInfo = {
                padding: {
                    top: b.getPadding("t"),
                    right: b.getPadding("r"),
                    bottom: b.getPadding("b"),
                    left: b.getPadding("l")
                },
                border: {
                    top: b.getBorderWidth("t"),
                    right: b.getBorderWidth("r"),
                    bottom: b.getBorderWidth("b"),
                    left: b.getBorderWidth("l")
                },
                bodyMargin: {
                    top: a.getMargin("t"),
                    right: a.getMargin("r"),
                    bottom: a.getMargin("b"),
                    left: a.getMargin("l")
                }
            }
        }
        return this.targetInfo
    },
    doOwnerCtLayouts: function() {
        var b = this.owner,
        e = b.ownerCt,
        c, h, d = this.lastComponentSize,
        g = this.previousComponentSize,
        a = (g && d && Ext.isNumber(d.width)) ? d.width !== g.width: true,
        f = (g && d && Ext.isNumber(d.height)) ? d.height !== g.height: true;
        if (!e || (!a && !f)) {
            return
        }
        c = e.componentLayout;
        h = e.layout;
        if (!b.floating && c && c.monitorChildren && !c.layoutBusy) {
            if (!e.suspendLayout && h && !h.layoutBusy) {
                if (((a && !e.isFixedWidth()) || (f && !e.isFixedHeight()))) {
                    this.isSizing = true;
                    e.doComponentLayout();
                    this.isSizing = false
                } else {
                    if (h.bindToOwnerCtContainer === true) {
                        h.layout()
                    }
                }
            }
        }
    },
    doContainerLayout: function() {
        var e = this,
        a = e.owner,
        c = a.ownerCt,
        d = a.layout,
        b;
        if (!a.suspendLayout && d && d.isLayout && !d.layoutBusy && !d.isAutoDock) {
            d.layout()
        }
        if (c && c.componentLayout) {
            b = c.componentLayout;
            if (!a.floating && b.monitorChildren && !b.layoutBusy) {
                b.childrenChanged = true
            }
        }
    },
    afterLayout: function(c, a, b, d) {
        this.doContainerLayout();
        this.owner.afterComponentLayout(c, a, b, d)
    }
});
Ext.define("Ext.layout.component.Button", {
    alias: ["layout.button"],
    extend: "Ext.layout.component.Component",
    type: "button",
    cellClsRE: /-btn-(tl|br)\b/,
    htmlRE: /<.*>/,
    beforeLayout: function() {
        return this.callParent(arguments) || this.lastText !== this.owner.text
    },
    onLayout: function(c, o) {
        var l = this,
        g = Ext.isNumber,
        d = l.owner,
        n = d.el,
        h = d.btnEl,
        e = d.btnInnerEl,
        f = d.btnIconEl,
        j = (d.icon || d.iconCls) && (d.iconAlign == "top" || d.iconAlign == "bottom"),
        b = d.minWidth,
        m = d.maxWidth,
        a,
        p,
        k;
        l.getTargetInfo();
        l.callParent(arguments);
        e.unclip();
        l.setTargetSize(c, o);
        if (!g(c)) {
            if (d.text && (Ext.isIE6 || Ext.isIE7) && Ext.isStrict && h && h.getWidth() > 20) {
                p = l.btnFrameWidth;
                k = Ext.util.TextMetrics.measure(e, d.text);
                n.setWidth(k.width + p + l.adjWidth);
                h.setWidth(k.width + p);
                e.setWidth(k.width + p);
                if (j) {
                    f.setWidth(k.width + p)
                }
            } else {
                n.setWidth(null);
                h.setWidth(null);
                e.setWidth(null);
                f.setWidth(null)
            }
            if (b || m) {
                a = n.getWidth();
                if (b && (a < b)) {
                    l.setTargetSize(b, o)
                } else {
                    if (m && (a > m)) {
                        e.clip();
                        l.setTargetSize(m, o)
                    }
                }
            }
        }
        this.lastText = d.text
    },
    setTargetSize: function(a, l) {
        var g = this,
        b = g.owner,
        e = Ext.isNumber,
        d = b.btnInnerEl,
        j = (e(a) ? a - g.adjWidth: a),
        f = (e(l) ? l - g.adjHeight: l),
        c = g.btnFrameHeight,
        k = b.getText(),
        h;
        g.callParent(arguments);
        g.setElementSize(b.btnEl, j, f);
        g.setElementSize(d, j, f);
        if (f >= 0) {
            d.setStyle("line-height", f - c + "px")
        }
        if (k && this.htmlRE.test(k)) {
            d.setStyle("line-height", "normal");
            h = Ext.util.TextMetrics.measure(d, k).height;
            d.setStyle("padding-top", g.btnFrameTop + Math.max(d.getHeight() - c - h, 0) / 2 + "px");
            g.setElementSize(d, j, f)
        }
    },
    getTargetInfo: function() {
        var e = this,
        a = e.owner,
        d = a.el,
        c = e.frameSize,
        g = a.frameBody,
        b = a.btnWrap,
        f = a.btnInnerEl;
        if (! ("adjWidth" in e)) {
            Ext.apply(e, {
                adjWidth: c.left + c.right + d.getBorderWidth("lr") + d.getPadding("lr") + b.getPadding("lr") + (g ? g.getFrameWidth("lr") : 0),
                adjHeight: c.top + c.bottom + d.getBorderWidth("tb") + d.getPadding("tb") + b.getPadding("tb") + (g ? g.getFrameWidth("tb") : 0),
                btnFrameWidth: f.getFrameWidth("lr"),
                btnFrameHeight: f.getFrameWidth("tb"),
                btnFrameTop: f.getFrameWidth("t")
            })
        }
        return e.callParent()
    }
});
Ext.define("Ext.layout.component.ProgressBar", {
    alias: ["layout.progressbar"],
    extend: "Ext.layout.component.Component",
    type: "progressbar",
    onLayout: function(d, b) {
        var e = this,
        a = e.owner,
        c = a.textEl;
        e.setElementSize(a.el, d, b);
        c.setWidth(a.el.getWidth(true));
        e.callParent([d, b]);
        a.updateProgress(a.value)
    }
});
Ext.define("Ext.layout.component.field.Field", {
    alias: ["layout.field"],
    extend: "Ext.layout.component.Component",
    uses: ["Ext.tip.QuickTip", "Ext.util.TextMetrics"],
    type: "field",
    beforeLayout: function(b, a) {
        var c = this;
        return c.callParent(arguments) || (!c.owner.preventMark && c.activeError !== c.owner.getActiveError())
    },
    onLayout: function(a, m) {
        var f = this,
        b = f.owner,
        e = f.getLabelStrategy(),
        l = f.getErrorStrategy(),
        j = Ext.isDefined,
        n = Ext.isNumber,
        h,
        g,
        k,
        c,
        d;
        h = f.lastComponentSize || {};
        if (!j(a)) {
            a = h.width;
            if (a < 0) {
                a = d
            }
        }
        if (!j(m)) {
            m = h.height;
            if (m < 0) {
                m = d
            }
        }
        g = !n(a);
        k = !n(m);
        c = {
            autoWidth: g,
            autoHeight: k,
            width: g ? b.getBodyNaturalWidth() : a,
            height: m,
            setOuterWidth: false,
            insets: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }
        };
        e.prepare(b, c);
        l.prepare(b, c);
        e.adjustHorizInsets(b, c);
        l.adjustHorizInsets(b, c);
        e.layoutHoriz(b, c);
        l.layoutHoriz(b, c);
        e.adjustVertInsets(b, c);
        l.adjustVertInsets(b, c);
        e.layoutVert(b, c);
        l.layoutVert(b, c);
        if (g && k) {
            f.setElementSize(b.el, (c.setOuterWidth ? c.width: d), c.height)
        } else {
            f.setTargetSize((!g || c.setOuterWidth ? c.width: d), c.height)
        }
        f.sizeBody(c);
        f.activeError = b.getActiveError()
    },
    onFocus: function() {
        this.getErrorStrategy().onFocus(this.owner)
    },
    sizeBody: function(h) {
        var g = this,
        c = g.owner,
        d = h.insets,
        b = h.width,
        e = h.height,
        f = Ext.isNumber(b) ? b - d.left - d.right: b,
        a = Ext.isNumber(e) ? e - d.top - d.bottom: e;
        g.setElementSize(c.bodyEl, f, a);
        g.sizeBodyContents(f, a)
    },
    sizeBodyContents: Ext.emptyFn,
    getLabelStrategy: function() {
        var b = this,
        c = b.labelStrategies,
        a = b.owner.labelAlign;
        return c[a] || c.base
    },
    getErrorStrategy: function() {
        var c = this,
        a = c.owner,
        d = c.errorStrategies,
        b = a.msgTarget;
        return ! a.preventMark && Ext.isString(b) ? (d[b] || d.elementId) : d.none
    },
    labelStrategies: (function() {
        var b = Ext.applyIf,
        a = Ext.emptyFn,
        c = {
            prepare: function(e, h) {
                var f = e.labelCls + "-" + e.labelAlign,
                g = e.labelEl;
                if (g && !g.hasCls(f)) {
                    g.addCls(f)
                }
            },
            adjustHorizInsets: a,
            adjustVertInsets: a,
            layoutHoriz: a,
            layoutVert: a
        },
        d = b({
            prepare: function(e, f) {
                c.prepare(e, f);
                if (f.autoWidth) {
                    f.width += (!e.labelEl ? 0 : e.labelWidth + e.labelPad)
                }
                f.setOuterWidth = true
            },
            adjustHorizInsets: function(e, f) {
                if (e.labelEl) {
                    f.insets.left += e.labelWidth + e.labelPad
                }
            },
            layoutHoriz: function(e, g) {
                var f = e.labelEl;
                if (f && !e.isLabelSized && !Ext.isBorderBox) {
                    f.setWidth(e.labelWidth);
                    e.isLabelSized = true
                }
            }
        },
        c);
        return {
            base: c,
            top: b({
                adjustVertInsets: function(e, g) {
                    var f = e.labelEl;
                    if (f) {
                        g.insets.top += Ext.util.TextMetrics.measure(f, e.fieldLabel, g.width).height + f.getFrameWidth("tb") + e.labelPad
                    }
                }
            },
            c),
            left: d,
            right: d
        }
    })(),
    errorStrategies: (function() {
        function d(h, g) {
            var j = h.getStyle("display") !== "none";
            if (g !== j) {
                h.setDisplayed(g)
            }
        }
        function f(h, g, j) {
            if (h.getStyle(g) !== j) {
                h.setStyle(g, j)
            }
        }
        function c(g) {
            var h = Ext.layout.component.field.Field.tip,
            j;
            if (h && h.isVisible()) {
                j = h.activeTarget;
                if (j && j.el === g.getActionEl().dom) {
                    h.toFront(true)
                }
            }
        }
        var b = Ext.applyIf,
        a = Ext.emptyFn,
        e = {
            prepare: function(g) {
                d(g.errorEl, false)
            },
            adjustHorizInsets: a,
            adjustVertInsets: a,
            layoutHoriz: a,
            layoutVert: a,
            onFocus: a
        };
        return {
            none: e,
            side: b({
                prepare: function(g) {
                    var h = g.errorEl;
                    h.addCls(Ext.baseCSSPrefix + "form-invalid-icon");
                    Ext.layout.component.field.Field.initTip();
                    h.dom.setAttribute("data-errorqtip", g.getActiveError() || "");
                    d(h, g.hasActiveError())
                },
                adjustHorizInsets: function(g, h) {
                    if (g.autoFitErrors && g.hasActiveError()) {
                        h.insets.right += g.errorEl.getWidth()
                    }
                },
                layoutHoriz: function(g, h) {
                    if (g.hasActiveError()) {
                        f(g.errorEl, "left", h.width - h.insets.right + "px")
                    }
                },
                layoutVert: function(g, h) {
                    if (g.hasActiveError()) {
                        f(g.errorEl, "top", h.insets.top + "px")
                    }
                },
                onFocus: c
            },
            e),
            under: b({
                prepare: function(g) {
                    var j = g.errorEl,
                    h = Ext.baseCSSPrefix + "form-invalid-under";
                    if (!j.hasCls(h)) {
                        j.addCls(h)
                    }
                    d(j, g.hasActiveError())
                },
                adjustVertInsets: function(g, h) {
                    if (g.autoFitErrors) {
                        h.insets.bottom += g.errorEl.getHeight()
                    }
                },
                layoutHoriz: function(g, j) {
                    var k = g.errorEl,
                    h = j.insets;
                    f(k, "width", j.width - h.right - h.left + "px");
                    f(k, "marginLeft", h.left + "px")
                }
            },
            e),
            qtip: b({
                prepare: function(g) {
                    d(g.errorEl, false);
                    Ext.layout.component.field.Field.initTip();
                    g.getActionEl().dom.setAttribute("data-errorqtip", g.getActiveError() || "")
                },
                onFocus: c
            },
            e),
            title: b({
                prepare: function(g) {
                    d(g.errorEl, false);
                    g.el.dom.title = g.getActiveError() || ""
                }
            },
            e),
            elementId: b({
                prepare: function(g) {
                    d(g.errorEl, false);
                    var h = Ext.fly(g.msgTarget);
                    if (h) {
                        h.dom.innerHTML = g.getActiveError() || "";
                        h.setDisplayed(g.hasActiveError())
                    }
                }
            },
            e)
        }
    })(),
    statics: {
        initTip: function() {
            var a = this.tip;
            if (!a) {
                a = this.tip = Ext.create("Ext.tip.QuickTip", {
                    baseCls: Ext.baseCSSPrefix + "form-invalid-tip",
                    renderTo: Ext.getBody()
                });
                a.tagConfig = Ext.apply({},
                {
                    attribute: "errorqtip"
                },
                a.tagConfig)
            }
        },
        destroyTip: function() {
            var a = this.tip;
            if (a) {
                a.destroy();
                delete this.tip
            }
        }
    }
});
Ext.define("Ext.layout.component.field.Text", {
    extend: "Ext.layout.component.field.Field",
    alias: "layout.textfield",
    requires: ["Ext.util.TextMetrics"],
    type: "textfield",
    beforeLayout: function(d, b) {
        var e = this,
        a = e.owner,
        c = this.lastValue,
        f = a.getRawValue();
        this.lastValue = f;
        return e.callParent(arguments) || (a.grow && f !== c)
    },
    sizeBodyContents: function(c, a) {
        var b = this.adjustForGrow(c, a);
        this.setElementSize(this.owner.inputEl, b[0], b[1])
    },
    adjustForGrow: function(e, c) {
        var f = this,
        b = f.owner,
        h, g, d, a = [e, c];
        if (b.grow) {
            h = b.inputEl;
            g = (h.dom.value || (b.hasFocus ? "": b.emptyText) || "") + b.growAppend;
            d = h.getTextWidth(g) + h.getBorderWidth("lr") + h.getPadding("lr");
            a[0] = Ext.Number.constrain(d, b.growMin, Math.max(b.growMin, Math.min(b.growMax, Ext.isNumber(e) ? e: Infinity)))
        }
        return a
    }
});
Ext.define("Ext.layout.component.field.TextArea", {
    extend: "Ext.layout.component.field.Text",
    alias: "layout.textareafield",
    type: "textareafield",
    adjustForGrow: function(a, k) {
        var e = this,
        b = e.owner,
        h, g, f, d, c, j, l = [a, k];
        if (b.grow) {
            h = b.inputEl;
            d = h.getWidth(true);
            c = h.getHeight();
            g = h.dom.value || "&#160;";
            g += b.growAppend;
            g = g.replace(/\n/g, "<br>");
            j = Ext.util.TextMetrics.measure(h, g, d).height + h.getBorderWidth("tb") + h.getPadding("tb");
            f = b.growMax;
            if (Ext.isNumber(k)) {
                f = Math.min(f, k)
            }
            l[1] = Ext.Number.constrain(j, b.growMin, f)
        }
        return l
    }
});
Ext.define("Ext.layout.component.field.Slider", {
    alias: ["layout.sliderfield"],
    extend: "Ext.layout.component.field.Field",
    type: "sliderfield",
    sizeBodyContents: function(a, j) {
        var b = this.owner,
        f = b.thumbs,
        c = f.length,
        h = b.inputEl,
        g = b.innerEl,
        e = b.endEl,
        d = 0;
        for (; d < c; ++d) {
            f[d].el.stopAnimation()
        }
        if (b.vertical) {
            h.setHeight(j);
            g.setHeight(Ext.isNumber(j) ? j - h.getPadding("t") - e.getPadding("b") : j)
        } else {
            h.setWidth(a);
            g.setWidth(Ext.isNumber(a) ? a - h.getPadding("l") - e.getPadding("r") : a)
        }
        b.syncThumbs()
    }
});
Ext.define("Ext.util.Sortable", {
    isSortable: true,
    defaultSortDirection: "ASC",
    requires: ["Ext.util.Sorter"],
    initSortable: function() {
        var a = this,
        b = a.sorters;
        a.sorters = Ext.create("Ext.util.AbstractMixedCollection", false,
        function(c) {
            return c.id || c.property
        });
        if (b) {
            a.sorters.addAll(a.decodeSorters(b))
        }
    },
    sort: function(g, f, c, e) {
        var d = this,
        h, b, a;
        if (Ext.isArray(g)) {
            e = c;
            c = f;
            a = g
        } else {
            if (Ext.isObject(g)) {
                e = c;
                c = f;
                a = [g]
            } else {
                if (Ext.isString(g)) {
                    h = d.sorters.get(g);
                    if (!h) {
                        h = {
                            property: g,
                            direction: f
                        };
                        a = [h]
                    } else {
                        if (f === undefined) {
                            h.toggle()
                        } else {
                            h.setDirection(f)
                        }
                    }
                }
            }
        }
        if (a && a.length) {
            a = d.decodeSorters(a);
            if (Ext.isString(c)) {
                if (c === "prepend") {
                    g = d.sorters.clone().items;
                    d.sorters.clear();
                    d.sorters.addAll(a);
                    d.sorters.addAll(g)
                } else {
                    d.sorters.addAll(a)
                }
            } else {
                d.sorters.clear();
                d.sorters.addAll(a)
            }
        }
        if (e !== false) {
            d.onBeforeSort(a);
            g = d.sorters.items;
            if (g.length) {
                b = function(l, k) {
                    var j = g[0].sort(l, k),
                    n = g.length,
                    m;
                    for (m = 1; m < n; m++) {
                        j = j || g[m].sort.call(this, l, k)
                    }
                    return j
                };
                d.doSort(b)
            }
        }
        return g
    },
    onBeforeSort: Ext.emptyFn,
    decodeSorters: function(f) {
        if (!Ext.isArray(f)) {
            if (f === undefined) {
                f = []
            } else {
                f = [f]
            }
        }
        var d = f.length,
        g = Ext.util.Sorter,
        a = this.model ? this.model.prototype.fields: null,
        e,
        b,
        c;
        for (c = 0; c < d; c++) {
            b = f[c];
            if (! (b instanceof g)) {
                if (Ext.isString(b)) {
                    b = {
                        property: b
                    }
                }
                Ext.applyIf(b, {
                    root: this.sortRoot,
                    direction: "ASC"
                });
                if (b.fn) {
                    b.sorterFn = b.fn
                }
                if (typeof b == "function") {
                    b = {
                        sorterFn: b
                    }
                }
                if (a && !b.transform) {
                    e = a.get(b.property);
                    b.transform = e ? e.sortType: undefined
                }
                f[c] = Ext.create("Ext.util.Sorter", b)
            }
        }
        return f
    },
    getSorters: function() {
        return this.sorters.items
    }
});
Ext.define("Ext.util.AbstractMixedCollection", {
    requires: ["Ext.util.Filter"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    constructor: function(b, a) {
        var c = this;
        c.items = [];
        c.map = {};
        c.keys = [];
        c.length = 0;
        c.addEvents("clear", "add", "replace", "remove");
        c.allowFunctions = b === true;
        if (a) {
            c.getKey = a
        }
        c.mixins.observable.constructor.call(c)
    },
    allowFunctions: false,
    add: function(b, e) {
        var d = this,
        f = e,
        c = b,
        a;
        if (arguments.length == 1) {
            f = c;
            c = d.getKey(f)
        }
        if (typeof c != "undefined" && c !== null) {
            a = d.map[c];
            if (typeof a != "undefined") {
                return d.replace(c, f)
            }
            d.map[c] = f
        }
        d.length++;
        d.items.push(f);
        d.keys.push(c);
        d.fireEvent("add", d.length - 1, f, c);
        return f
    },
    getKey: function(a) {
        return a.id
    },
    replace: function(c, e) {
        var d = this,
        a, b;
        if (arguments.length == 1) {
            e = arguments[0];
            c = d.getKey(e)
        }
        a = d.map[c];
        if (typeof c == "undefined" || c === null || typeof a == "undefined") {
            return d.add(c, e)
        }
        b = d.indexOfKey(c);
        d.items[b] = e;
        d.map[c] = e;
        d.fireEvent("replace", c, a, e);
        return e
    },
    addAll: function(f) {
        var e = this,
        d = 0,
        b, a, c;
        if (arguments.length > 1 || Ext.isArray(f)) {
            b = arguments.length > 1 ? arguments: f;
            for (a = b.length; d < a; d++) {
                e.add(b[d])
            }
        } else {
            for (c in f) {
                if (f.hasOwnProperty(c)) {
                    if (e.allowFunctions || typeof f[c] != "function") {
                        e.add(c, f[c])
                    }
                }
            }
        }
    },
    each: function(e, d) {
        var b = [].concat(this.items),
        c = 0,
        a = b.length,
        f;
        for (; c < a; c++) {
            f = b[c];
            if (e.call(d || f, f, c, a) === false) {
                break
            }
        }
    },
    eachKey: function(e, d) {
        var f = this.keys,
        b = this.items,
        c = 0,
        a = f.length;
        for (; c < a; c++) {
            e.call(d || window, f[c], b[c], c, a)
        }
    },
    findBy: function(e, d) {
        var f = this.keys,
        b = this.items,
        c = 0,
        a = b.length;
        for (; c < a; c++) {
            if (e.call(d || window, b[c], f[c])) {
                return b[c]
            }
        }
        return null
    },
    find: function() {
        if (Ext.isDefined(Ext.global.console)) {
            Ext.global.console.warn("Ext.util.MixedCollection: find has been deprecated. Use findBy instead.")
        }
        return this.findBy.apply(this, arguments)
    },
    insert: function(a, b, e) {
        var d = this,
        c = b,
        f = e;
        if (arguments.length == 2) {
            f = c;
            c = d.getKey(f)
        }
        if (d.containsKey(c)) {
            d.suspendEvents();
            d.removeAtKey(c);
            d.resumeEvents()
        }
        if (a >= d.length) {
            return d.add(c, f)
        }
        d.length++;
        Ext.Array.splice(d.items, a, 0, f);
        if (typeof c != "undefined" && c !== null) {
            d.map[c] = f
        }
        Ext.Array.splice(d.keys, a, 0, c);
        d.fireEvent("add", a, f, c);
        return f
    },
    remove: function(a) {
        return this.removeAt(this.indexOf(a))
    },
    removeAll: function(a) {
        Ext.each(a || [],
        function(b) {
            this.remove(b)
        },
        this);
        return this
    },
    removeAt: function(a) {
        var c = this,
        d, b;
        if (a < c.length && a >= 0) {
            c.length--;
            d = c.items[a];
            Ext.Array.erase(c.items, a, 1);
            b = c.keys[a];
            if (typeof b != "undefined") {
                delete c.map[b]
            }
            Ext.Array.erase(c.keys, a, 1);
            c.fireEvent("remove", d, b);
            return d
        }
        return false
    },
    removeAtKey: function(a) {
        return this.removeAt(this.indexOfKey(a))
    },
    getCount: function() {
        return this.length
    },
    indexOf: function(a) {
        return Ext.Array.indexOf(this.items, a)
    },
    indexOfKey: function(a) {
        return Ext.Array.indexOf(this.keys, a)
    },
    get: function(b) {
        var d = this,
        a = d.map[b],
        c = a !== undefined ? a: (typeof b == "number") ? d.items[b] : undefined;
        return typeof c != "function" || d.allowFunctions ? c: null
    },
    getAt: function(a) {
        return this.items[a]
    },
    getByKey: function(a) {
        return this.map[a]
    },
    contains: function(a) {
        return Ext.Array.contains(this.items, a)
    },
    containsKey: function(a) {
        return typeof this.map[a] != "undefined"
    },
    clear: function() {
        var a = this;
        a.length = 0;
        a.items = [];
        a.keys = [];
        a.map = {};
        a.fireEvent("clear")
    },
    first: function() {
        return this.items[0]
    },
    last: function() {
        return this.items[this.length - 1]
    },
    sum: function(g, b, h, a) {
        var c = this.extractValues(g, b),
        f = c.length,
        e = 0,
        d;
        h = h || 0;
        a = (a || a === 0) ? a: f - 1;
        for (d = h; d <= a; d++) {
            e += c[d]
        }
        return e
    },
    collect: function(j, e, g) {
        var k = this.extractValues(j, e),
        a = k.length,
        b = {},
        c = [],
        h,
        f,
        d;
        for (d = 0; d < a; d++) {
            h = k[d];
            f = String(h);
            if ((g || !Ext.isEmpty(h)) && !b[f]) {
                b[f] = true;
                c.push(h)
            }
        }
        return c
    },
    extractValues: function(c, a) {
        var b = this.items;
        if (a) {
            b = Ext.Array.pluck(b, a)
        }
        return Ext.Array.pluck(b, c)
    },
    getRange: function(f, a) {
        var e = this,
        c = e.items,
        b = [],
        d;
        if (c.length < 1) {
            return b
        }
        f = f || 0;
        a = Math.min(typeof a == "undefined" ? e.length - 1 : a, e.length - 1);
        if (f <= a) {
            for (d = f; d <= a; d++) {
                b[b.length] = c[d]
            }
        } else {
            for (d = f; d >= a; d--) {
                b[b.length] = c[d]
            }
        }
        return b
    },
    filter: function(d, c, f, a) {
        var b = [],
        e;
        if (Ext.isString(d)) {
            b.push(Ext.create("Ext.util.Filter", {
                property: d,
                value: c,
                anyMatch: f,
                caseSensitive: a
            }))
        } else {
            if (Ext.isArray(d) || d instanceof Ext.util.Filter) {
                b = b.concat(d)
            }
        }
        e = function(g) {
            var m = true,
            n = b.length,
            h;
            for (h = 0; h < n; h++) {
                var l = b[h],
                k = l.filterFn,
                j = l.scope;
                m = m && k.call(j, g)
            }
            return m
        };
        return this.filterBy(e)
    },
    filterBy: function(e, d) {
        var h = this,
        a = new this.self(),
        g = h.keys,
        b = h.items,
        f = b.length,
        c;
        a.getKey = h.getKey;
        for (c = 0; c < f; c++) {
            if (e.call(d || h, b[c], g[c])) {
                a.add(g[c], b[c])
            }
        }
        return a
    },
    findIndex: function(c, b, e, d, a) {
        if (Ext.isEmpty(b, false)) {
            return - 1
        }
        b = this.createValueMatcher(b, d, a);
        return this.findIndexBy(function(f) {
            return f && b.test(f[c])
        },
        null, e)
    },
    findIndexBy: function(e, d, h) {
        var g = this,
        f = g.keys,
        b = g.items,
        c = h || 0,
        a = b.length;
        for (; c < a; c++) {
            if (e.call(d || g, b[c], f[c])) {
                return c
            }
        }
        return - 1
    },
    createValueMatcher: function(c, e, a, b) {
        if (!c.exec) {
            var d = Ext.String.escapeRegex;
            c = String(c);
            if (e === true) {
                c = d(c)
            } else {
                c = "^" + d(c);
                if (b === true) {
                    c += "$"
                }
            }
            c = new RegExp(c, a ? "": "i")
        }
        return c
    },
    clone: function() {
        var e = this,
        f = new this.self(),
        d = e.keys,
        b = e.items,
        c = 0,
        a = b.length;
        for (; c < a; c++) {
            f.add(d[c], b[c])
        }
        f.getKey = e.getKey;
        return f
    }
});
Ext.define("Ext.util.MixedCollection", {
    extend: "Ext.util.AbstractMixedCollection",
    mixins: {
        sortable: "Ext.util.Sortable"
    },
    constructor: function() {
        var a = this;
        a.callParent(arguments);
        a.addEvents("sort");
        a.mixins.sortable.initSortable.call(a)
    },
    doSort: function(a) {
        this.sortBy(a)
    },
    _sort: function(k, a, j) {
        var h = this,
        d, e, b = String(a).toUpperCase() == "DESC" ? -1 : 1,
        g = [],
        l = h.keys,
        f = h.items;
        j = j ||
        function(m, c) {
            return m - c
        };
        for (d = 0, e = f.length; d < e; d++) {
            g[g.length] = {
                key: l[d],
                value: f[d],
                index: d
            }
        }
        Ext.Array.sort(g,
        function(m, c) {
            var n = j(m[k], c[k]) * b;
            if (n === 0) {
                n = (m.index < c.index ? -1 : 1)
            }
            return n
        });
        for (d = 0, e = g.length; d < e; d++) {
            f[d] = g[d].value;
            l[d] = g[d].key
        }
        h.fireEvent("sort", h)
    },
    sortBy: function(c) {
        var g = this,
        b = g.items,
        f = g.keys,
        e = b.length,
        a = [],
        d;
        for (d = 0; d < e; d++) {
            a[d] = {
                key: f[d],
                value: b[d],
                index: d
            }
        }
        Ext.Array.sort(a,
        function(j, h) {
            var k = c(j.value, h.value);
            if (k === 0) {
                k = (j.index < h.index ? -1 : 1)
            }
            return k
        });
        for (d = 0; d < e; d++) {
            b[d] = a[d].value;
            f[d] = a[d].key
        }
        g.fireEvent("sort", g, b, f)
    },
    reorder: function(d) {
        var g = this,
        b = g.items,
        c = 0,
        f = b.length,
        a = [],
        e = [],
        h;
        g.suspendEvents();
        for (h in d) {
            a[d[h]] = b[h]
        }
        for (c = 0; c < f; c++) {
            if (d[c] == undefined) {
                e.push(b[c])
            }
        }
        for (c = 0; c < f; c++) {
            if (a[c] == undefined) {
                a[c] = e.shift()
            }
        }
        g.clear();
        g.addAll(a);
        g.resumeEvents();
        g.fireEvent("sort", g)
    },
    sortByKey: function(a, b) {
        this._sort("key", a, b ||
        function(d, c) {
            var f = String(d).toUpperCase(),
            e = String(c).toUpperCase();
            return f > e ? 1 : (f < e ? -1 : 0)
        })
    }
});
Ext.define("Ext.data.StoreManager", {
    extend: "Ext.util.MixedCollection",
    alternateClassName: ["Ext.StoreMgr", "Ext.data.StoreMgr", "Ext.StoreManager"],
    singleton: true,
    uses: ["Ext.data.ArrayStore"],
    register: function() {
        for (var a = 0,
        b; (b = arguments[a]); a++) {
            this.add(b)
        }
    },
    unregister: function() {
        for (var a = 0,
        b; (b = arguments[a]); a++) {
            this.remove(this.lookup(b))
        }
    },
    lookup: function(c) {
        if (Ext.isArray(c)) {
            var b = ["field1"],
            e = !Ext.isArray(c[0]),
            f = c,
            d,
            a;
            if (e) {
                f = [];
                for (d = 0, a = c.length; d < a; ++d) {
                    f.push([c[d]])
                }
            } else {
                for (d = 2, a = c[0].length; d <= a; ++d) {
                    b.push("field" + d)
                }
            }
            return Ext.create("Ext.data.ArrayStore", {
                data: f,
                fields: b,
                autoDestroy: true,
                autoCreated: true,
                expanded: e
            })
        }
        if (Ext.isString(c)) {
            return this.get(c)
        } else {
            return Ext.data.AbstractStore.create(c)
        }
    },
    getKey: function(a) {
        return a.storeId
    }
},
function() {
    Ext.regStore = function(c, b) {
        var a;
        if (Ext.isObject(c)) {
            b = c
        } else {
            b.storeId = c
        }
        if (b instanceof Ext.data.Store) {
            a = b
        } else {
            a = Ext.create("Ext.data.Store", b)
        }
        return Ext.data.StoreManager.register(a)
    };
    Ext.getStore = function(a) {
        return Ext.data.StoreManager.lookup(a)
    }
});
Ext.define("Ext.menu.Manager", {
    singleton: true,
    requires: ["Ext.util.MixedCollection", "Ext.util.KeyMap"],
    alternateClassName: "Ext.menu.MenuMgr",
    uses: ["Ext.menu.Menu"],
    menus: {},
    groups: {},
    attached: false,
    lastShow: new Date(),
    init: function() {
        var a = this;
        a.active = Ext.create("Ext.util.MixedCollection");
        Ext.getDoc().addKeyListener(27,
        function() {
            if (a.active.length > 0) {
                a.hideAll()
            }
        },
        a)
    },
    hideAll: function() {
        var a = this.active,
        b;
        if (a && a.length > 0) {
            b = a.clone();
            b.each(function(c) {
                c.hide()
            });
            return true
        }
        return false
    },
    onHide: function(a) {
        var b = this,
        c = b.active;
        c.remove(a);
        if (c.length < 1) {
            Ext.getDoc().un("mousedown", b.onMouseDown, b);
            b.attached = false
        }
    },
    onShow: function(a) {
        var e = this,
        f = e.active,
        d = f.last(),
        c = e.attached,
        b = a.getEl(),
        g;
        e.lastShow = new Date();
        f.add(a);
        if (!c) {
            Ext.getDoc().on("mousedown", e.onMouseDown, e);
            e.attached = true
        }
        a.toFront()
    },
    onBeforeHide: function(a) {
        if (a.activeChild) {
            a.activeChild.hide()
        }
        if (a.autoHideTimer) {
            clearTimeout(a.autoHideTimer);
            delete a.autoHideTimer
        }
    },
    onBeforeShow: function(a) {
        var c = this.active,
        b = a.parentMenu;
        c.remove(a);
        if (!b && !a.allowOtherMenus) {
            this.hideAll()
        } else {
            if (b && b.activeChild && a != b.activeChild) {
                b.activeChild.hide()
            }
        }
    },
    onMouseDown: function(f) {
        var b = this,
        d = b.active,
        a = b.lastShow,
        c = f.target;
        if (Ext.Date.getElapsed(a) > 50 && d.length > 0 && !f.getTarget("." + Ext.baseCSSPrefix + "menu")) {
            b.hideAll();
            if (Ext.isIE && Ext.fly(c).focusable()) {
                c.focus()
            }
        }
    },
    register: function(b) {
        var a = this;
        if (!a.active) {
            a.init()
        }
        if (b.floating) {
            a.menus[b.id] = b;
            b.on({
                beforehide: a.onBeforeHide,
                hide: a.onHide,
                beforeshow: a.onBeforeShow,
                show: a.onShow,
                scope: a
            })
        }
    },
    get: function(b) {
        var a = this.menus;
        if (typeof b == "string") {
            if (!a) {
                return null
            }
            return a[b]
        } else {
            if (b.isMenu) {
                return b
            } else {
                if (Ext.isArray(b)) {
                    return Ext.create("Ext.menu.Menu", {
                        items: b
                    })
                } else {
                    return Ext.ComponentManager.create(b, "menu")
                }
            }
        }
    },
    unregister: function(d) {
        var a = this,
        b = a.menus,
        c = a.active;
        delete b[d.id];
        c.remove(d);
        d.un({
            beforehide: a.onBeforeHide,
            hide: a.onHide,
            beforeshow: a.onBeforeShow,
            show: a.onShow,
            scope: a
        })
    },
    registerCheckable: function(c) {
        var a = this.groups,
        b = c.group;
        if (b) {
            if (!a[b]) {
                a[b] = []
            }
            a[b].push(c)
        }
    },
    unregisterCheckable: function(c) {
        var a = this.groups,
        b = c.group;
        if (b) {
            Ext.Array.remove(a[b], c)
        }
    },
    onCheckChange: function(d, f) {
        var a = this.groups,
        c = d.group,
        b = 0,
        h, e, g;
        if (c && f) {
            h = a[c];
            e = h.length;
            for (; b < e; b++) {
                g = h[b];
                if (g != d) {
                    g.setChecked(false)
                }
            }
        }
    }
});
Ext.define("Ext.data.Errors", {
    extend: "Ext.util.MixedCollection",
    isValid: function() {
        return this.length === 0
    },
    getByField: function(e) {
        var d = [],
        a,
        c,
        b;
        for (b = 0; b < this.length; b++) {
            a = this.items[b];
            if (a.field == e) {
                d.push(a)
            }
        }
        return d
    }
});
Ext.define("Ext.dd.DragDropManager", {
    singleton: true,
    requires: ["Ext.util.Region"],
    uses: ["Ext.tip.QuickTipManager"],
    alternateClassName: ["Ext.dd.DragDropMgr", "Ext.dd.DDM"],
    ids: {},
    handleIds: {},
    dragCurrent: null,
    dragOvers: {},
    deltaX: 0,
    deltaY: 0,
    preventDefault: true,
    stopPropagation: true,
    initialized: false,
    locked: false,
    init: function() {
        this.initialized = true
    },
    POINT: 0,
    INTERSECT: 1,
    mode: 0,
    _execOnAll: function(c, b) {
        for (var d in this.ids) {
            for (var a in this.ids[d]) {
                var e = this.ids[d][a];
                if (!this.isTypeOfDD(e)) {
                    continue
                }
                e[c].apply(e, b)
            }
        }
    },
    _onLoad: function() {
        this.init();
        var a = Ext.EventManager;
        a.on(document, "mouseup", this.handleMouseUp, this, true);
        a.on(document, "mousemove", this.handleMouseMove, this, true);
        a.on(window, "unload", this._onUnload, this, true);
        a.on(window, "resize", this._onResize, this, true)
    },
    _onResize: function(a) {
        this._execOnAll("resetConstraints", [])
    },
    lock: function() {
        this.locked = true
    },
    unlock: function() {
        this.locked = false
    },
    isLocked: function() {
        return this.locked
    },
    locationCache: {},
    useCache: true,
    clickPixelThresh: 3,
    clickTimeThresh: 350,
    dragThreshMet: false,
    clickTimeout: null,
    startX: 0,
    startY: 0,
    regDragDrop: function(b, a) {
        if (!this.initialized) {
            this.init()
        }
        if (!this.ids[a]) {
            this.ids[a] = {}
        }
        this.ids[a][b.id] = b
    },
    removeDDFromGroup: function(c, a) {
        if (!this.ids[a]) {
            this.ids[a] = {}
        }
        var b = this.ids[a];
        if (b && b[c.id]) {
            delete b[c.id]
        }
    },
    _remove: function(b) {
        for (var a in b.groups) {
            if (a && this.ids[a] && this.ids[a][b.id]) {
                delete this.ids[a][b.id]
            }
        }
        delete this.handleIds[b.id]
    },
    regHandle: function(b, a) {
        if (!this.handleIds[b]) {
            this.handleIds[b] = {}
        }
        this.handleIds[b][a] = a
    },
    isDragDrop: function(a) {
        return (this.getDDById(a)) ? true: false
    },
    getRelated: function(f, b) {
        var e = [];
        for (var d in f.groups) {
            for (var c in this.ids[d]) {
                var a = this.ids[d][c];
                if (!this.isTypeOfDD(a)) {
                    continue
                }
                if (!b || a.isTarget) {
                    e[e.length] = a
                }
            }
        }
        return e
    },
    isLegalTarget: function(e, d) {
        var b = this.getRelated(e, true);
        for (var c = 0,
        a = b.length; c < a; ++c) {
            if (b[c].id == d.id) {
                return true
            }
        }
        return false
    },
    isTypeOfDD: function(a) {
        return (a && a.__ygDragDrop)
    },
    isHandle: function(b, a) {
        return (this.handleIds[b] && this.handleIds[b][a])
    },
    getDDById: function(b) {
        for (var a in this.ids) {
            if (this.ids[a][b]) {
                return this.ids[a][b]
            }
        }
        return null
    },
    handleMouseDown: function(c, b) {
        if (Ext.tip.QuickTipManager) {
            Ext.tip.QuickTipManager.ddDisable()
        }
        if (this.dragCurrent) {
            this.handleMouseUp(c)
        }
        this.currentTarget = c.getTarget();
        this.dragCurrent = b;
        var a = b.getEl();
        this.startX = c.getPageX();
        this.startY = c.getPageY();
        this.deltaX = this.startX - a.offsetLeft;
        this.deltaY = this.startY - a.offsetTop;
        this.dragThreshMet = false;
        this.clickTimeout = setTimeout(function() {
            var d = Ext.dd.DragDropManager;
            d.startDrag(d.startX, d.startY)
        },
        this.clickTimeThresh)
    },
    startDrag: function(a, b) {
        clearTimeout(this.clickTimeout);
        if (this.dragCurrent) {
            this.dragCurrent.b4StartDrag(a, b);
            this.dragCurrent.startDrag(a, b)
        }
        this.dragThreshMet = true
    },
    handleMouseUp: function(a) {
        if (Ext.tip && Ext.tip.QuickTipManager) {
            Ext.tip.QuickTipManager.ddEnable()
        }
        if (!this.dragCurrent) {
            return
        }
        clearTimeout(this.clickTimeout);
        if (this.dragThreshMet) {
            this.fireEvents(a, true)
        } else {}
        this.stopDrag(a);
        this.stopEvent(a)
    },
    stopEvent: function(a) {
        if (this.stopPropagation) {
            a.stopPropagation()
        }
        if (this.preventDefault) {
            a.preventDefault()
        }
    },
    stopDrag: function(a) {
        if (this.dragCurrent) {
            if (this.dragThreshMet) {
                this.dragCurrent.b4EndDrag(a);
                this.dragCurrent.endDrag(a)
            }
            this.dragCurrent.onMouseUp(a)
        }
        this.dragCurrent = null;
        this.dragOvers = {}
    },
    handleMouseMove: function(c) {
        if (!this.dragCurrent) {
            return true
        }
        if (Ext.isIE && (c.button !== 0 && c.button !== 1 && c.button !== 2)) {
            this.stopEvent(c);
            return this.handleMouseUp(c)
        }
        if (!this.dragThreshMet) {
            var b = Math.abs(this.startX - c.getPageX());
            var a = Math.abs(this.startY - c.getPageY());
            if (b > this.clickPixelThresh || a > this.clickPixelThresh) {
                this.startDrag(this.startX, this.startY)
            }
        }
        if (this.dragThreshMet) {
            this.dragCurrent.b4Drag(c);
            this.dragCurrent.onDrag(c);
            if (!this.dragCurrent.moveOnly) {
                this.fireEvents(c, false)
            }
        }
        this.stopEvent(c);
        return true
    },
    fireEvents: function(l, m) {
        var o = this.dragCurrent;
        if (!o || o.isLocked()) {
            return
        }
        var p = l.getPoint();
        var a = [];
        var d = [];
        var j = [];
        var g = [];
        var c = [];
        for (var f in this.dragOvers) {
            var b = this.dragOvers[f];
            if (!this.isTypeOfDD(b)) {
                continue
            }
            if (!this.isOverTarget(p, b, this.mode)) {
                d.push(b)
            }
            a[f] = true;
            delete this.dragOvers[f]
        }
        for (var n in o.groups) {
            if ("string" != typeof n) {
                continue
            }
            for (f in this.ids[n]) {
                var h = this.ids[n][f];
                if (!this.isTypeOfDD(h)) {
                    continue
                }
                if (h.isTarget && !h.isLocked() && ((h != o) || (o.ignoreSelf === false))) {
                    if (this.isOverTarget(p, h, this.mode)) {
                        if (m) {
                            g.push(h)
                        } else {
                            if (!a[h.id]) {
                                c.push(h)
                            } else {
                                j.push(h)
                            }
                            this.dragOvers[h.id] = h
                        }
                    }
                }
            }
        }
        if (this.mode) {
            if (d.length) {
                o.b4DragOut(l, d);
                o.onDragOut(l, d)
            }
            if (c.length) {
                o.onDragEnter(l, c)
            }
            if (j.length) {
                o.b4DragOver(l, j);
                o.onDragOver(l, j)
            }
            if (g.length) {
                o.b4DragDrop(l, g);
                o.onDragDrop(l, g)
            }
        } else {
            var k = 0;
            for (f = 0, k = d.length; f < k; ++f) {
                o.b4DragOut(l, d[f].id);
                o.onDragOut(l, d[f].id)
            }
            for (f = 0, k = c.length; f < k; ++f) {
                o.onDragEnter(l, c[f].id)
            }
            for (f = 0, k = j.length; f < k; ++f) {
                o.b4DragOver(l, j[f].id);
                o.onDragOver(l, j[f].id)
            }
            for (f = 0, k = g.length; f < k; ++f) {
                o.b4DragDrop(l, g[f].id);
                o.onDragDrop(l, g[f].id)
            }
        }
        if (m && !g.length) {
            o.onInvalidDrop(l)
        }
    },
    getBestMatch: function(c) {
        var e = null;
        var b = c.length;
        if (b == 1) {
            e = c[0]
        } else {
            for (var d = 0; d < b; ++d) {
                var a = c[d];
                if (a.cursorIsOver) {
                    e = a;
                    break
                } else {
                    if (!e || e.overlap.getArea() < a.overlap.getArea()) {
                        e = a
                    }
                }
            }
        }
        return e
    },
    refreshCache: function(b) {
        for (var a in b) {
            if ("string" != typeof a) {
                continue
            }
            for (var c in this.ids[a]) {
                var d = this.ids[a][c];
                if (this.isTypeOfDD(d)) {
                    var e = this.getLocation(d);
                    if (e) {
                        this.locationCache[d.id] = e
                    } else {
                        delete this.locationCache[d.id]
                    }
                }
            }
        }
    },
    verifyEl: function(b) {
        if (b) {
            var a;
            if (Ext.isIE) {
                try {
                    a = b.offsetParent
                } catch(c) {}
            } else {
                a = b.offsetParent
            }
            if (a) {
                return true
            }
        }
        return false
    },
    getLocation: function(h) {
        if (!this.isTypeOfDD(h)) {
            return null
        }
        if (h.getRegion) {
            return h.getRegion()
        }
        var f = h.getEl(),
        m,
        d,
        c,
        o,
        n,
        p,
        a,
        k,
        g;
        try {
            m = Ext.Element.getXY(f)
        } catch(j) {}
        if (!m) {
            return null
        }
        d = m[0];
        c = d + f.offsetWidth;
        o = m[1];
        n = o + f.offsetHeight;
        p = o - h.padding[0];
        a = c + h.padding[1];
        k = n + h.padding[2];
        g = d - h.padding[3];
        return Ext.create("Ext.util.Region", p, a, k, g)
    },
    isOverTarget: function(j, a, c) {
        var e = this.locationCache[a.id];
        if (!e || !this.useCache) {
            e = this.getLocation(a);
            this.locationCache[a.id] = e
        }
        if (!e) {
            return false
        }
        a.cursorIsOver = e.contains(j);
        var h = this.dragCurrent;
        if (!h || !h.getTargetCoord || (!c && !h.constrainX && !h.constrainY)) {
            return a.cursorIsOver
        }
        a.overlap = null;
        var f = h.getTargetCoord(j.x, j.y);
        var b = h.getDragEl();
        var d = Ext.create("Ext.util.Region", f.y, f.x + b.offsetWidth, f.y + b.offsetHeight, f.x);
        var g = d.intersect(e);
        if (g) {
            a.overlap = g;
            return (c) ? true: a.cursorIsOver
        } else {
            return false
        }
    },
    _onUnload: function(b, a) {
        Ext.dd.DragDropManager.unregAll()
    },
    unregAll: function() {
        if (this.dragCurrent) {
            this.stopDrag();
            this.dragCurrent = null
        }
        this._execOnAll("unreg", []);
        for (var a in this.elementCache) {
            delete this.elementCache[a]
        }
        this.elementCache = {};
        this.ids = {}
    },
    elementCache: {},
    getElWrapper: function(b) {
        var a = this.elementCache[b];
        if (!a || !a.el) {
            a = this.elementCache[b] = new this.ElementWrapper(Ext.getDom(b))
        }
        return a
    },
    getElement: function(a) {
        return Ext.getDom(a)
    },
    getCss: function(b) {
        var a = Ext.getDom(b);
        return (a) ? a.style: null
    },
    ElementWrapper: function(a) {
        this.el = a || null;
        this.id = this.el && a.id;
        this.css = this.el && a.style
    },
    getPosX: function(a) {
        return Ext.Element.getX(a)
    },
    getPosY: function(a) {
        return Ext.Element.getY(a)
    },
    swapNode: function(c, a) {
        if (c.swapNode) {
            c.swapNode(a)
        } else {
            var d = a.parentNode;
            var b = a.nextSibling;
            if (b == c) {
                d.insertBefore(c, a)
            } else {
                if (a == c.nextSibling) {
                    d.insertBefore(a, c)
                } else {
                    c.parentNode.replaceChild(a, c);
                    d.insertBefore(c, b)
                }
            }
        }
    },
    getScroll: function() {
        var d = window.document,
        e = d.documentElement,
        a = d.body,
        c = 0,
        b = 0;
        if (Ext.isGecko4) {
            c = window.scrollYOffset;
            b = window.scrollXOffset
        } else {
            if (e && (e.scrollTop || e.scrollLeft)) {
                c = e.scrollTop;
                b = e.scrollLeft
            } else {
                if (a) {
                    c = a.scrollTop;
                    b = a.scrollLeft
                }
            }
        }
        return {
            top: c,
            left: b
        }
    },
    getStyle: function(b, a) {
        return Ext.fly(b).getStyle(a)
    },
    getScrollTop: function() {
        return this.getScroll().top
    },
    getScrollLeft: function() {
        return this.getScroll().left
    },
    moveToEl: function(a, c) {
        var b = Ext.Element.getXY(c);
        Ext.Element.setXY(a, b)
    },
    numericSort: function(d, c) {
        return (d - c)
    },
    _timeoutCount: 0,
    _addListeners: function() {
        if (document) {
            this._onLoad()
        } else {
            if (this._timeoutCount > 2000) {} else {
                setTimeout(this._addListeners, 10);
                if (document && document.body) {
                    this._timeoutCount += 1
                }
            }
        }
    },
    handleWasClicked: function(a, c) {
        if (this.isHandle(c, a.id)) {
            return true
        } else {
            var b = a.parentNode;
            while (b) {
                if (this.isHandle(c, b.id)) {
                    return true
                } else {
                    b = b.parentNode
                }
            }
        }
        return false
    }
},
function() {
    this._addListeners()
});
Ext.define("Ext.layout.container.boxOverflow.Scroller", {
    extend: "Ext.layout.container.boxOverflow.None",
    requires: ["Ext.util.ClickRepeater", "Ext.Element"],
    alternateClassName: "Ext.layout.boxOverflow.Scroller",
    mixins: {
        observable: "Ext.util.Observable"
    },
    animateScroll: false,
    scrollIncrement: 20,
    wheelIncrement: 10,
    scrollRepeatInterval: 60,
    scrollDuration: 400,
    scrollerCls: Ext.baseCSSPrefix + "box-scroller",
    constructor: function(b, a) {
        this.layout = b;
        Ext.apply(this, a || {});
        this.addEvents("scroll")
    },
    initCSSClasses: function() {
        var b = this,
        a = b.layout;
        if (!b.CSSinitialized) {
            b.beforeCtCls = b.beforeCtCls || Ext.baseCSSPrefix + "box-scroller-" + a.parallelBefore;
            b.afterCtCls = b.afterCtCls || Ext.baseCSSPrefix + "box-scroller-" + a.parallelAfter;
            b.beforeScrollerCls = b.beforeScrollerCls || Ext.baseCSSPrefix + a.owner.getXType() + "-scroll-" + a.parallelBefore;
            b.afterScrollerCls = b.afterScrollerCls || Ext.baseCSSPrefix + a.owner.getXType() + "-scroll-" + a.parallelAfter;
            b.CSSinitializes = true
        }
    },
    handleOverflow: function(a, f) {
        var e = this,
        d = e.layout,
        c = "get" + d.parallelPrefixCap,
        b = {};
        e.initCSSClasses();
        e.callParent(arguments);
        this.createInnerElements();
        this.showScrollers();
        b[d.perpendicularPrefix] = f[d.perpendicularPrefix];
        b[d.parallelPrefix] = f[d.parallelPrefix] - (e.beforeCt[c]() + e.afterCt[c]());
        return {
            targetSize: b
        }
    },
    createInnerElements: function() {
        var a = this,
        b = a.layout.getRenderTarget();
        if (!a.beforeCt) {
            b.addCls(Ext.baseCSSPrefix + a.layout.direction + "-box-overflow-body");
            a.beforeCt = b.insertSibling({
                cls: Ext.layout.container.Box.prototype.innerCls + " " + a.beforeCtCls
            },
            "before");
            a.afterCt = b.insertSibling({
                cls: Ext.layout.container.Box.prototype.innerCls + " " + a.afterCtCls
            },
            "after");
            a.createWheelListener()
        }
    },
    createWheelListener: function() {
        this.layout.innerCt.on({
            scope: this,
            mousewheel: function(a) {
                a.stopEvent();
                this.scrollBy(a.getWheelDelta() * this.wheelIncrement * -1, false)
            }
        })
    },
    clearOverflow: function() {
        this.hideScrollers()
    },
    showScrollers: function() {
        this.createScrollers();
        this.beforeScroller.show();
        this.afterScroller.show();
        this.updateScrollButtons();
        this.layout.owner.addClsWithUI("scroller")
    },
    hideScrollers: function() {
        if (this.beforeScroller != undefined) {
            this.beforeScroller.hide();
            this.afterScroller.hide();
            this.layout.owner.removeClsWithUI("scroller")
        }
    },
    createScrollers: function() {
        if (!this.beforeScroller && !this.afterScroller) {
            var a = this.beforeCt.createChild({
                cls: Ext.String.format("{0} {1} ", this.scrollerCls, this.beforeScrollerCls)
            });
            var b = this.afterCt.createChild({
                cls: Ext.String.format("{0} {1}", this.scrollerCls, this.afterScrollerCls)
            });
            a.addClsOnOver(this.beforeScrollerCls + "-hover");
            b.addClsOnOver(this.afterScrollerCls + "-hover");
            a.setVisibilityMode(Ext.Element.DISPLAY);
            b.setVisibilityMode(Ext.Element.DISPLAY);
            this.beforeRepeater = Ext.create("Ext.util.ClickRepeater", a, {
                interval: this.scrollRepeatInterval,
                handler: this.scrollLeft,
                scope: this
            });
            this.afterRepeater = Ext.create("Ext.util.ClickRepeater", b, {
                interval: this.scrollRepeatInterval,
                handler: this.scrollRight,
                scope: this
            });
            this.beforeScroller = a;
            this.afterScroller = b
        }
    },
    destroy: function() {
        Ext.destroy(this.beforeRepeater, this.afterRepeater, this.beforeScroller, this.afterScroller, this.beforeCt, this.afterCt)
    },
    scrollBy: function(b, a) {
        this.scrollTo(this.getScrollPosition() + b, a)
    },
    getScrollAnim: function() {
        return {
            duration: this.scrollDuration,
            callback: this.updateScrollButtons,
            scope: this
        }
    },
    updateScrollButtons: function() {
        if (this.beforeScroller == undefined || this.afterScroller == undefined) {
            return
        }
        var d = this.atExtremeBefore() ? "addCls": "removeCls",
        c = this.atExtremeAfter() ? "addCls": "removeCls",
        a = this.beforeScrollerCls + "-disabled",
        b = this.afterScrollerCls + "-disabled";
        this.beforeScroller[d](a);
        this.afterScroller[c](b);
        this.scrolling = false
    },
    atExtremeBefore: function() {
        return this.getScrollPosition() === 0
    },
    scrollLeft: function() {
        this.scrollBy( - this.scrollIncrement, false)
    },
    scrollRight: function() {
        this.scrollBy(this.scrollIncrement, false)
    },
    getScrollPosition: function() {
        var a = this.layout;
        return parseInt(a.innerCt.dom["scroll" + a.parallelBeforeCap], 10) || 0
    },
    getMaxScrollPosition: function() {
        var a = this.layout;
        return a.innerCt.dom["scroll" + a.parallelPrefixCap] - this.layout.innerCt["get" + a.parallelPrefixCap]()
    },
    atExtremeAfter: function() {
        return this.getScrollPosition() >= this.getMaxScrollPosition()
    },
    scrollTo: function(a, b) {
        var f = this,
        e = f.layout,
        d = f.getScrollPosition(),
        c = Ext.Number.constrain(a, 0, f.getMaxScrollPosition());
        if (c != d && !f.scrolling) {
            if (b == undefined) {
                b = f.animateScroll
            }
            e.innerCt.scrollTo(e.parallelBefore, c, b ? f.getScrollAnim() : false);
            if (b) {
                f.scrolling = true
            } else {
                f.scrolling = false;
                f.updateScrollButtons()
            }
            f.fireEvent("scroll", f, c, b ? f.getScrollAnim() : false)
        }
    },
    scrollToItem: function(g, b) {
        var f = this,
        e = f.layout,
        a, d, c;
        g = f.getItem(g);
        if (g != undefined) {
            a = this.getItemVisibility(g);
            if (!a.fullyVisible) {
                d = g.getBox(true, true);
                c = d[e.parallelPosition];
                if (a.hiddenEnd) {
                    c -= (this.layout.innerCt["get" + e.parallelPrefixCap]() - d[e.parallelPrefix])
                }
                this.scrollTo(c, b)
            }
        }
    },
    getItemVisibility: function(f) {
        var e = this,
        d = e.getItem(f).getBox(true, true),
        c = e.layout,
        b = d[c.parallelPosition],
        g = b + d[c.parallelPrefix],
        h = e.getScrollPosition(),
        a = h + c.innerCt["get" + c.parallelPrefixCap]();
        return {
            hiddenStart: b < h,
            hiddenEnd: g > a,
            fullyVisible: b > h && g < a
        }
    }
});
Ext.define("Ext.Ajax", {
    extend: "Ext.data.Connection",
    singleton: true,
    autoAbort: false
});
Ext.define("Ext.data.Types", {
    singleton: true,
    requires: ["Ext.data.SortTypes"]
},
function() {
    var a = Ext.data.SortTypes;
    Ext.apply(Ext.data.Types, {
        stripRe: /[\$,%]/g,
        AUTO: {
            convert: function(b) {
                return b
            },
            sortType: a.none,
            type: "auto"
        },
        STRING: {
            convert: function(c) {
                var b = this.useNull ? null: "";
                return (c === undefined || c === null) ? b: String(c)
            },
            sortType: a.asUCString,
            type: "string"
        },
        INT: {
            convert: function(b) {
                return b !== undefined && b !== null && b !== "" ? parseInt(String(b).replace(Ext.data.Types.stripRe, ""), 10) : (this.useNull ? null: 0)
            },
            sortType: a.none,
            type: "int"
        },
        FLOAT: {
            convert: function(b) {
                return b !== undefined && b !== null && b !== "" ? parseFloat(String(b).replace(Ext.data.Types.stripRe, ""), 10) : (this.useNull ? null: 0)
            },
            sortType: a.none,
            type: "float"
        },
        BOOL: {
            convert: function(b) {
                if (this.useNull && (b === undefined || b === null || b === "")) {
                    return null
                }
                return b === true || b === "true" || b == 1
            },
            sortType: a.none,
            type: "bool"
        },
        DATE: {
            convert: function(c) {
                var d = this.dateFormat,
                b;
                if (!c) {
                    return null
                }
                if (Ext.isDate(c)) {
                    return c
                }
                if (d) {
                    if (d == "timestamp") {
                        return new Date(c * 1000)
                    }
                    if (d == "time") {
                        return new Date(parseInt(c, 10))
                    }
                    return Ext.Date.parse(c, d)
                }
                b = Date.parse(c);
                return b ? new Date(b) : null
            },
            sortType: a.asDate,
            type: "date"
        }
    });
    Ext.apply(Ext.data.Types, {
        BOOLEAN: this.BOOL,
        INTEGER: this.INT,
        NUMBER: this.FLOAT
    })
});
Ext.define("Ext.data.Field", {
    requires: ["Ext.data.Types", "Ext.data.SortTypes"],
    alias: "data.field",
    constructor: function(b) {
        if (Ext.isString(b)) {
            b = {
                name: b
            }
        }
        Ext.apply(this, b);
        var d = Ext.data.Types,
        a = this.sortType,
        c;
        if (this.type) {
            if (Ext.isString(this.type)) {
                this.type = d[this.type.toUpperCase()] || d.AUTO
            }
        } else {
            this.type = d.AUTO
        }
        if (Ext.isString(a)) {
            this.sortType = Ext.data.SortTypes[a]
        } else {
            if (Ext.isEmpty(a)) {
                this.sortType = this.type.sortType
            }
        }
        if (!this.convert) {
            this.convert = this.type.convert
        }
    },
    dateFormat: null,
    useNull: false,
    defaultValue: "",
    mapping: null,
    sortType: null,
    sortDir: "ASC",
    allowBlank: true,
    persist: true
});
Ext.define("Ext.layout.component.AbstractDock", {
    extend: "Ext.layout.component.Component",
    type: "dock",
    autoSizing: true,
    beforeLayout: function() {
        var a = this.callParent(arguments);
        if (a !== false && (!this.initializedBorders || this.childrenChanged) && (!this.owner.border || this.owner.manageBodyBorders)) {
            this.handleItemBorders();
            this.initializedBorders = true
        }
        return a
    },
    handleItemBorders: function() {
        var a = this.owner,
        e = a.body,
        l = this.getLayoutItems(),
        g = {
            top: [],
            right: [],
            bottom: [],
            left: []
        },
        b = this.borders,
        d = {
            top: "bottom",
            right: "left",
            bottom: "top",
            left: "right"
        },
        c,
        h,
        k,
        j,
        f;
        for (c = 0, h = l.length; c < h; c++) {
            k = l[c];
            j = k.dock;
            if (k.ignoreBorderManagement) {
                continue
            }
            if (!g[j].satisfied) {
                g[j].push(k);
                g[j].satisfied = true
            }
            if (!g.top.satisfied && d[j] !== "top") {
                g.top.push(k)
            }
            if (!g.right.satisfied && d[j] !== "right") {
                g.right.push(k)
            }
            if (!g.bottom.satisfied && d[j] !== "bottom") {
                g.bottom.push(k)
            }
            if (!g.left.satisfied && d[j] !== "left") {
                g.left.push(k)
            }
        }
        if (b) {
            for (f in b) {
                if (b.hasOwnProperty(f)) {
                    h = b[f].length;
                    if (!a.manageBodyBorders) {
                        for (c = 0; c < h; c++) {
                            b[f][c].removeCls(Ext.baseCSSPrefix + "docked-noborder-" + f)
                        }
                        if (!b[f].satisfied && !a.bodyBorder) {
                            e.removeCls(Ext.baseCSSPrefix + "docked-noborder-" + f)
                        }
                    } else {
                        if (b[f].satisfied) {
                            e.setStyle("border-" + f + "-width", "")
                        }
                    }
                }
            }
        }
        for (f in g) {
            if (g.hasOwnProperty(f)) {
                h = g[f].length;
                if (!a.manageBodyBorders) {
                    for (c = 0; c < h; c++) {
                        g[f][c].addCls(Ext.baseCSSPrefix + "docked-noborder-" + f)
                    }
                    if ((!g[f].satisfied && !a.bodyBorder) || a.bodyBorder === false) {
                        e.addCls(Ext.baseCSSPrefix + "docked-noborder-" + f)
                    }
                } else {
                    if (g[f].satisfied) {
                        e.setStyle("border-" + f + "-width", "1px")
                    }
                }
            }
        }
        this.borders = g
    },
    onLayout: function(a, n) {
        if (this.onLayout_running) {
            return
        }
        this.onLayout_running = true;
        var j = this,
        b = j.owner,
        g = b.body,
        f = b.layout,
        h = j.getTarget(),
        l = false,
        m = false,
        k,
        e,
        d;
        var c = j.info = {
            boxes: [],
            size: {
                width: a,
                height: n
            },
            bodyBox: {}
        };
        delete f.isAutoDock;
        Ext.applyIf(c, j.getTargetInfo());
        if (b && b.ownerCt && b.ownerCt.layout && b.ownerCt.layout.isLayout) {
            if (!Ext.isNumber(b.height) || !Ext.isNumber(b.width)) {
                b.ownerCt.layout.bindToOwnerCtComponent = true
            } else {
                b.ownerCt.layout.bindToOwnerCtComponent = false
            }
        }
        if (n == null || a == null) {
            k = c.padding;
            e = c.border;
            d = j.frameSize;
            if ((n == null) && (a == null)) {
                m = true;
                l = true;
                j.setTargetSize(null);
                j.setBodyBox({
                    width: null,
                    height: null
                })
            } else {
                if (n == null) {
                    m = true;
                    j.setTargetSize(a);
                    j.setBodyBox({
                        width: a - k.left - e.left - k.right - e.right - d.left - d.right,
                        height: null
                    })
                } else {
                    l = true;
                    j.setTargetSize(null, n);
                    j.setBodyBox({
                        width: null,
                        height: n - k.top - k.bottom - e.top - e.bottom - d.top - d.bottom
                    })
                }
            }
            if (f && f.isLayout) {
                f.bindToOwnerCtComponent = true;
                f.isAutoDock = f.autoSize !== true;
                f.layout();
                c.autoSizedCtLayout = f.autoSize === true;
                c.autoHeight = m;
                c.autoWidth = l
            }
            j.dockItems();
            j.setTargetSize(c.size.width, c.size.height)
        } else {
            j.setTargetSize(a, n);
            j.dockItems()
        }
        j.callParent(arguments);
        this.onLayout_running = false
    },
    dockItems: function() {
        this.calculateDockBoxes();
        var g = this.info,
        h = g.autoWidth,
        a = g.autoHeight,
        c = g.boxes,
        f = c.length,
        e, b, d;
        for (b = 0; b < f; b++) {
            e = c[b];
            d = e.item;
            d.setPosition(e.x, e.y);
            if ((h || a) && d.layout && d.layout.isLayout) {
                d.layout.bindToOwnerCtComponent = true
            }
        }
        if (!g.autoSizedCtLayout) {
            if (h) {
                g.bodyBox.width = null
            }
            if (a) {
                g.bodyBox.height = null
            }
        }
        this.setBodyBox(g.bodyBox)
    },
    calculateDockBoxes: function() {
        if (this.calculateDockBoxes_running) {
            return
        }
        this.calculateDockBoxes_running = true;
        var k = this,
        g = k.getTarget(),
        j = k.getLayoutItems(),
        a = k.owner,
        q = a.body,
        b = k.info,
        n = b.autoWidth,
        o = b.autoHeight,
        r = b.size,
        h = j.length,
        m = b.padding,
        d = b.border,
        c = k.frameSize,
        p,
        e,
        f,
        l;
        if (o) {
            r.height = q.getHeight() + m.top + d.top + m.bottom + d.bottom + c.top + c.bottom
        } else {
            r.height = g.getHeight()
        }
        if (n) {
            r.width = q.getWidth() + m.left + d.left + m.right + d.right + c.left + c.right
        } else {
            r.width = g.getWidth()
        }
        b.bodyBox = {
            x: m.left + c.left,
            y: m.top + c.top,
            width: r.width - m.left - d.left - m.right - d.right - c.left - c.right,
            height: r.height - d.top - m.top - d.bottom - m.bottom - c.top - c.bottom
        };
        for (e = 0; e < h; e++) {
            p = j[e];
            f = k.initBox(p);
            if (o === true) {
                f = k.adjustAutoBox(f, e)
            } else {
                f = k.adjustSizedBox(f, e)
            }
            b.boxes.push(f)
        }
        this.calculateDockBoxes_running = false
    },
    adjustSizedBox: function(e, d) {
        var a = this.info.bodyBox,
        b = this.frameSize,
        g = this.info,
        f = g.padding,
        h = e.type,
        c = g.border;
        switch (h) {
        case "top":
            e.y = a.y;
            break;
        case "left":
            e.x = a.x;
            break;
        case "bottom":
            e.y = (a.y + a.height) - e.height;
            break;
        case "right":
            e.x = (a.x + a.width) - e.width;
            break
        }
        if (e.ignoreFrame) {
            if (h == "bottom") {
                e.y += (b.bottom + f.bottom + c.bottom)
            } else {
                e.y -= (b.top + f.top + c.top)
            }
            if (h == "right") {
                e.x += (b.right + f.right + c.right)
            } else {
                e.x -= (b.left + f.left + c.left)
            }
        }
        if (!e.overlay) {
            switch (h) {
            case "top":
                a.y += e.height;
                a.height -= e.height;
                break;
            case "left":
                a.x += e.width;
                a.width -= e.width;
                break;
            case "bottom":
                a.height -= e.height;
                break;
            case "right":
                a.width -= e.width;
                break
            }
        }
        return e
    },
    adjustAutoBox: function(h, l) {
        var b = this.info,
        a = this.owner,
        m = b.bodyBox,
        q = b.size,
        j = b.boxes,
        f = j.length,
        o = h.type,
        e = this.frameSize,
        p = b.padding,
        d = b.border,
        c = b.autoSizedCtLayout,
        n = (f < l) ? f: l,
        g,
        k;
        if (o == "top" || o == "bottom") {
            for (g = 0; g < n; g++) {
                k = j[g];
                if (k.stretched && k.type == "left" || k.type == "right") {
                    k.height += h.height
                } else {
                    if (k.type == "bottom") {
                        k.y += h.height
                    }
                }
            }
        }
        switch (o) {
        case "top":
            h.y = m.y;
            if (!h.overlay) {
                m.y += h.height;
                if (b.autoHeight) {
                    q.height += h.height
                } else {
                    m.height -= h.height
                }
            }
            break;
        case "bottom":
            if (!h.overlay) {
                if (b.autoHeight) {
                    q.height += h.height
                } else {
                    m.height -= h.height
                }
            }
            h.y = (m.y + m.height);
            break;
        case "left":
            h.x = m.x;
            if (!h.overlay) {
                m.x += h.width;
                if (b.autoWidth) {
                    q.width += h.width
                } else {
                    m.width -= h.width
                }
            }
            break;
        case "right":
            if (!h.overlay) {
                if (b.autoWidth) {
                    q.width += h.width
                } else {
                    m.width -= h.width
                }
            }
            h.x = (m.x + m.width);
            break
        }
        if (h.ignoreFrame) {
            if (o == "bottom") {
                h.y += (e.bottom + p.bottom + d.bottom)
            } else {
                h.y -= (e.top + p.top + d.top)
            }
            if (o == "right") {
                h.x += (e.right + p.right + d.right)
            } else {
                h.x -= (e.left + p.left + d.left)
            }
        }
        return h
    },
    initBox: function(k) {
        var h = this,
        g = h.info.bodyBox,
        a = (k.dock == "top" || k.dock == "bottom"),
        b = h.owner,
        e = h.frameSize,
        c = h.info,
        j = c.padding,
        d = c.border,
        f = {
            item: k,
            overlay: k.overlay,
            type: k.dock,
            offsets: Ext.Element.parseBox(k.offsets || {}),
            ignoreFrame: k.ignoreParentFrame
        };
        if (k.stretch !== false) {
            f.stretched = true;
            if (a) {
                f.x = g.x + f.offsets.left;
                f.width = g.width - (f.offsets.left + f.offsets.right);
                if (f.ignoreFrame) {
                    f.width += (e.left + e.right + d.left + d.right + j.left + j.right)
                }
                k.setCalculatedSize(f.width - k.el.getMargin("lr"), undefined, b)
            } else {
                f.y = g.y + f.offsets.top;
                f.height = g.height - (f.offsets.bottom + f.offsets.top);
                if (f.ignoreFrame) {
                    f.height += (e.top + e.bottom + d.top + d.bottom + j.top + j.bottom)
                }
                k.setCalculatedSize(undefined, f.height - k.el.getMargin("tb"), b);
                if (!Ext.supports.ComputedStyle) {
                    k.el.repaint()
                }
            }
        } else {
            k.doComponentLayout();
            f.width = k.getWidth() - (f.offsets.left + f.offsets.right);
            f.height = k.getHeight() - (f.offsets.bottom + f.offsets.top);
            f.y += f.offsets.top;
            if (a) {
                f.x = (k.align == "right") ? g.width - f.width: g.x;
                f.x += f.offsets.left
            }
        }
        if (f.width === undefined) {
            f.width = k.getWidth() + k.el.getMargin("lr")
        }
        if (f.height === undefined) {
            f.height = k.getHeight() + k.el.getMargin("tb")
        }
        return f
    },
    getLayoutItems: function() {
        var c = this.owner.getDockedItems(),
        d = c.length,
        b = 0,
        a = [];
        for (; b < d; b++) {
            if (c[b].isVisible(true)) {
                a.push(c[b])
            }
        }
        return a
    },
    renderItems: function(g, e) {
        var a = e.dom.childNodes,
        d = a.length,
        f = g.length,
        k = 0,
        c, b, h, l;
        for (c = 0; c < d; c++) {
            h = Ext.get(a[c]);
            for (b = 0; b < f; b++) {
                l = g[b];
                if (l.rendered && (h.id == l.el.id || h.contains(l.el.id))) {
                    break
                }
            }
            if (b === f) {
                k++
            }
        }
        for (c = 0, b = 0; c < f; c++, b++) {
            l = g[c];
            if (c === b && (l.dock === "right" || l.dock === "bottom")) {
                b += k
            }
            if (l && !l.rendered) {
                this.renderItem(l, e, b)
            } else {
                if (!this.isValidParent(l, e, b)) {
                    this.moveItem(l, e, b)
                }
            }
        }
    },
    setBodyBox: function(f) {
        var h = this,
        a = h.owner,
        g = a.body,
        b = h.info,
        e = b.bodyMargin,
        j = b.padding,
        d = b.border,
        c = h.frameSize;
        if (a.collapsed) {
            return
        }
        if (Ext.isNumber(f.width)) {
            f.width -= e.left + e.right
        }
        if (Ext.isNumber(f.height)) {
            f.height -= e.top + e.bottom
        }
        h.setElementSize(g, f.width, f.height);
        if (Ext.isNumber(f.x)) {
            g.setLeft(f.x - j.left - c.left)
        }
        if (Ext.isNumber(f.y)) {
            g.setTop(f.y - j.top - c.top)
        }
    },
    configureItem: function(a, b) {
        this.callParent(arguments);
        if (a.dock == "top" || a.dock == "bottom") {
            a.layoutManagedWidth = 1;
            a.layoutManagedHeight = 2
        } else {
            a.layoutManagedWidth = 2;
            a.layoutManagedHeight = 1
        }
        a.addCls(Ext.baseCSSPrefix + "docked");
        a.addClsWithUI("docked-" + a.dock)
    },
    afterRemove: function(a) {
        this.callParent(arguments);
        if (this.itemCls) {
            a.el.removeCls(this.itemCls + "-" + a.dock)
        }
        var b = a.el.dom;
        if (!a.destroying && b) {
            b.parentNode.removeChild(b)
        }
        this.childrenChanged = true
    }
});
Ext.define("Ext.layout.component.Dock", {
    alias: ["layout.dock"],
    extend: "Ext.layout.component.AbstractDock"
});
Ext.define("Ext.layout.component.Tip", {
    alias: ["layout.tip"],
    extend: "Ext.layout.component.Dock",
    type: "tip",
    onLayout: function(b, j) {
        var g = this,
        c = g.owner,
        d = c.el,
        a, h, f, e, k = d.getXY();
        d.setXY([ - 9999, -9999]);
        this.callParent(arguments);
        if (!Ext.isNumber(b)) {
            a = c.minWidth;
            h = c.maxWidth;
            if (Ext.isStrict && (Ext.isIE6 || Ext.isIE7)) {
                e = g.doAutoWidth()
            } else {
                f = d.getWidth()
            }
            if (f < a) {
                e = a
            } else {
                if (f > h) {
                    e = h
                }
            }
            if (e) {
                this.callParent([e, j])
            }
        }
        d.setXY(k)
    },
    doAutoWidth: function() {
        var d = this,
        b = d.owner,
        a = b.body,
        c = a.getTextWidth();
        if (b.header) {
            c = Math.max(c, b.header.getWidth())
        }
        if (!Ext.isDefined(d.frameWidth)) {
            d.frameWidth = b.el.getWidth() - a.getWidth()
        }
        c += d.frameWidth + a.getPadding("lr");
        return c
    }
});
Ext.define("Ext.layout.container.Auto", {
    alias: ["layout.auto", "layout.autocontainer"],
    extend: "Ext.layout.container.Container",
    type: "autocontainer",
    bindToOwnerCtComponent: true,
    onLayout: function(a, f) {
        var e = this,
        b = e.getLayoutItems(),
        d = b.length,
        c;
        if (d) {
            if (!e.clearEl) {
                e.clearEl = e.getRenderTarget().createChild({
                    cls: Ext.baseCSSPrefix + "clear",
                    role: "presentation"
                })
            }
            for (c = 0; c < d; c++) {
                e.setItemSize(b[c])
            }
        }
    },
    configureItem: function(a) {
        this.callParent(arguments);
        a.layoutManagedHeight = 2;
        a.layoutManagedWidth = 2
    }
});
Ext.define("Ext.fx.target.Element", {
    extend: "Ext.fx.target.Target",
    type: "element",
    getElVal: function(b, a, c) {
        if (c == undefined) {
            if (a === "x") {
                c = b.getX()
            } else {
                if (a === "y") {
                    c = b.getY()
                } else {
                    if (a === "scrollTop") {
                        c = b.getScroll().top
                    } else {
                        if (a === "scrollLeft") {
                            c = b.getScroll().left
                        } else {
                            if (a === "height") {
                                c = b.getHeight()
                            } else {
                                if (a === "width") {
                                    c = b.getWidth()
                                } else {
                                    c = b.getStyle(a)
                                }
                            }
                        }
                    }
                }
            }
        }
        return c
    },
    getAttr: function(a, c) {
        var b = this.target;
        return [[b, this.getElVal(b, a, c)]]
    },
    setAttr: function(k) {
        var f = this.target,
        h = k.length,
        m, g, b, e, c, a, d, l;
        for (e = 0; e < h; e++) {
            m = k[e].attrs;
            for (g in m) {
                if (m.hasOwnProperty(g)) {
                    a = m[g].length;
                    for (c = 0; c < a; c++) {
                        b = m[g][c];
                        d = b[0];
                        l = b[1];
                        if (g === "x") {
                            d.setX(l)
                        } else {
                            if (g === "y") {
                                d.setY(l)
                            } else {
                                if (g === "scrollTop") {
                                    d.scrollTo("top", l)
                                } else {
                                    if (g === "scrollLeft") {
                                        d.scrollTo("left", l)
                                    } else {
                                        d.setStyle(g, l)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
});
Ext.define("Ext.fx.target.Sprite", {
    extend: "Ext.fx.target.Target",
    type: "draw",
    getFromPrim: function(b, a) {
        var c;
        if (a == "translate") {
            c = {
                x: b.attr.translation.x || 0,
                y: b.attr.translation.y || 0
            }
        } else {
            if (a == "rotate") {
                c = {
                    degrees: b.attr.rotation.degrees || 0,
                    x: b.attr.rotation.x,
                    y: b.attr.rotation.y
                }
            } else {
                c = b.attr[a]
            }
        }
        return c
    },
    getAttr: function(a, b) {
        return [[this.target, b != undefined ? b: this.getFromPrim(this.target, a)]]
    },
    setAttr: function(m) {
        var g = m.length,
        k = [],
        q,
        f,
        p,
        e,
        b,
        o,
        n,
        d,
        c,
        l,
        h,
        a;
        for (d = 0; d < g; d++) {
            q = m[d].attrs;
            for (f in q) {
                p = q[f];
                a = p.length;
                for (c = 0; c < a; c++) {
                    b = p[c][0];
                    e = p[c][1];
                    if (f === "translate") {
                        n = {
                            x: e.x,
                            y: e.y
                        }
                    } else {
                        if (f === "rotate") {
                            l = e.x;
                            if (isNaN(l)) {
                                l = null
                            }
                            h = e.y;
                            if (isNaN(h)) {
                                h = null
                            }
                            n = {
                                degrees: e.degrees,
                                x: l,
                                y: h
                            }
                        } else {
                            if (f === "width" || f === "height" || f === "x" || f === "y") {
                                n = parseFloat(e)
                            } else {
                                n = e
                            }
                        }
                    }
                    o = Ext.Array.indexOf(k, b);
                    if (o == -1) {
                        k.push([b, {}]);
                        o = k.length - 1
                    }
                    k[o][1][f] = n
                }
            }
        }
        g = k.length;
        for (d = 0; d < g; d++) {
            b = k[d];
            b[0].setAttributes(b[1])
        }
        this.target.redraw()
    }
});
Ext.define("Ext.fx.target.CompositeElement", {
    extend: "Ext.fx.target.Element",
    isComposite: true,
    constructor: function(a) {
        a.id = a.id || Ext.id(null, "ext-composite-");
        this.callParent([a])
    },
    getAttr: function(a, d) {
        var b = [],
        c = this.target;
        c.each(function(e) {
            b.push([e, this.getElVal(e, a, d)])
        },
        this);
        return b
    }
});
Ext.define("Ext.fx.target.CompositeSprite", {
    extend: "Ext.fx.target.Sprite",
    getAttr: function(a, d) {
        var b = [],
        c = this.target;
        c.each(function(e) {
            b.push([e, d != undefined ? d: this.getFromPrim(e, a)])
        },
        this);
        return b
    }
});
Ext.define("Ext.fx.target.Component", {
    extend: "Ext.fx.target.Target",
    type: "component",
    getPropMethod: {
        top: function() {
            return this.getPosition(true)[1]
        },
        left: function() {
            return this.getPosition(true)[0]
        },
        x: function() {
            return this.getPosition()[0]
        },
        y: function() {
            return this.getPosition()[1]
        },
        height: function() {
            return this.getHeight()
        },
        width: function() {
            return this.getWidth()
        },
        opacity: function() {
            return this.el.getStyle("opacity")
        }
    },
    compMethod: {
        top: "setPosition",
        left: "setPosition",
        x: "setPagePosition",
        y: "setPagePosition",
        height: "setSize",
        width: "setSize",
        opacity: "setOpacity"
    },
    getAttr: function(a, b) {
        return [[this.target, b !== undefined ? b: this.getPropMethod[a].call(this.target)]]
    },
    setAttr: function(s, e, b) {
        var q = this,
        l = q.target,
        p = s.length,
        u, m, a, f, d, n, k, c, r, t, g;
        for (f = 0; f < p; f++) {
            u = s[f].attrs;
            for (m in u) {
                k = u[m].length;
                n = {
                    setPosition: {},
                    setPagePosition: {},
                    setSize: {},
                    setOpacity: {}
                };
                for (d = 0; d < k; d++) {
                    a = u[m][d];
                    n[q.compMethod[m]].target = a[0];
                    n[q.compMethod[m]][m] = a[1]
                }
                if (n.setPosition.target) {
                    a = n.setPosition;
                    c = (a.left === undefined) ? undefined: parseInt(a.left, 10);
                    r = (a.top === undefined) ? undefined: parseInt(a.top, 10);
                    a.target.setPosition(c, r)
                }
                if (n.setPagePosition.target) {
                    a = n.setPagePosition;
                    a.target.setPagePosition(a.x, a.y)
                }
                if (n.setSize.target && n.setSize.target.el) {
                    a = n.setSize;
                    t = (a.width === undefined) ? a.target.getWidth() : parseInt(a.width, 10);
                    g = (a.height === undefined) ? a.target.getHeight() : parseInt(a.height, 10);
                    if (b || q.dynamic) {
                        a.target.componentLayout.childrenChanged = true;
                        if (q.layoutAnimation) {
                            a.target.setCalculatedSize(t, g)
                        } else {
                            a.target.setSize(t, g)
                        }
                    } else {
                        a.target.el.setSize(t, g)
                    }
                }
                if (n.setOpacity.target) {
                    a = n.setOpacity;
                    a.target.el.setStyle("opacity", a.opacity)
                }
            }
        }
    }
});
Ext.define("Ext.fx.Manager", {
    singleton: true,
    requires: ["Ext.util.MixedCollection", "Ext.fx.target.Element", "Ext.fx.target.CompositeElement", "Ext.fx.target.Sprite", "Ext.fx.target.CompositeSprite", "Ext.fx.target.Component"],
    mixins: {
        queue: "Ext.fx.Queue"
    },
    constructor: function() {
        this.items = Ext.create("Ext.util.MixedCollection");
        this.mixins.queue.constructor.call(this)
    },
    interval: 16,
    forceJS: true,
    createTarget: function(d) {
        var b = this,
        c = !b.forceJS && Ext.supports.Transitions,
        a;
        b.useCSS3 = c;
        if (Ext.isString(d)) {
            d = Ext.get(d)
        }
        if (d && d.tagName) {
            d = Ext.get(d);
            a = Ext.create("Ext.fx.target.Element" + (c ? "CSS": ""), d);
            b.targets.add(a);
            return a
        }
        if (Ext.isObject(d)) {
            if (d.dom) {
                a = Ext.create("Ext.fx.target.Element" + (c ? "CSS": ""), d)
            } else {
                if (d.isComposite) {
                    a = Ext.create("Ext.fx.target.CompositeElement" + (c ? "CSS": ""), d)
                } else {
                    if (d.isSprite) {
                        a = Ext.create("Ext.fx.target.Sprite", d)
                    } else {
                        if (d.isCompositeSprite) {
                            a = Ext.create("Ext.fx.target.CompositeSprite", d)
                        } else {
                            if (d.isComponent) {
                                a = Ext.create("Ext.fx.target.Component", d)
                            } else {
                                if (d.isAnimTarget) {
                                    return d
                                } else {
                                    return null
                                }
                            }
                        }
                    }
                }
            }
            b.targets.add(a);
            return a
        } else {
            return null
        }
    },
    addAnim: function(c) {
        var b = this.items,
        a = this.task;
        b.add(c);
        if (!a && b.length) {
            a = this.task = {
                run: this.runner,
                interval: this.interval,
                scope: this
            };
            Ext.TaskManager.start(a)
        }
    },
    removeAnim: function(c) {
        var b = this.items,
        a = this.task;
        b.remove(c);
        if (a && !b.length) {
            Ext.TaskManager.stop(a);
            delete this.task
        }
    },
    startingFilter: function(a) {
        return a.paused === false && a.running === false && a.iterations > 0
    },
    runningFilter: function(a) {
        return a.paused === false && a.running === true && a.isAnimator !== true
    },
    runner: function() {
        var b = this,
        a = b.items;
        b.targetData = {};
        b.targetArr = {};
        b.timestamp = new Date();
        a.filterBy(b.startingFilter).each(b.startAnim, b);
        a.filterBy(b.runningFilter).each(b.runAnim, b);
        b.applyPendingAttrs()
    },
    startAnim: function(a) {
        a.start(this.timestamp)
    },
    runAnim: function(d) {
        if (!d) {
            return
        }
        var c = this,
        b = d.target.getId(),
        f = c.useCSS3 && d.target.type == "element",
        a = c.timestamp - d.startTime,
        e,
        g;
        this.collectTargetData(d, a, f);
        if (f) {
            d.target.setAttr(c.targetData[b], true);
            c.targetData[b] = [];
            c.collectTargetData(d, d.duration, f);
            d.paused = true;
            e = d.target.target;
            if (d.target.isComposite) {
                e = d.target.target.last()
            }
            g = {};
            g[Ext.supports.CSS3TransitionEnd] = d.lastFrame;
            g.scope = d;
            g.single = true;
            e.on(g)
        } else {
            if (a >= d.duration) {
                c.applyPendingAttrs(true);
                delete c.targetData[b];
                delete c.targetArr[b];
                d.lastFrame()
            }
        }
    },
    collectTargetData: function(d, a, e) {
        var b = d.target.getId(),
        f = this.targetData[b],
        c;
        if (!f) {
            f = this.targetData[b] = [];
            this.targetArr[b] = d.target
        }
        c = {
            duration: d.duration,
            easing: (e && d.reverse) ? d.easingFn.reverse().toCSS3() : d.easing,
            attrs: {}
        };
        Ext.apply(c.attrs, d.runAnim(a));
        f.push(c)
    },
    applyPendingAttrs: function(d) {
        var c = this.targetData,
        b = this.targetArr,
        a;
        for (a in c) {
            if (c.hasOwnProperty(a)) {
                b[a].setAttr(c[a], false, d)
            }
        }
    }
});
Ext.define("Ext.fx.Animator", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.fx.Manager"],
    isAnimator: true,
    duration: 250,
    delay: 0,
    delayStart: 0,
    dynamic: false,
    easing: "ease",
    running: false,
    paused: false,
    damper: 1,
    iterations: 1,
    currentIteration: 0,
    keyframeStep: 0,
    animKeyFramesRE: /^(from|to|\d+%?)$/,
    constructor: function(a) {
        var b = this;
        a = Ext.apply(b, a || {});
        b.config = a;
        b.id = Ext.id(null, "ext-animator-");
        b.addEvents("beforeanimate", "keyframe", "afteranimate");
        b.mixins.observable.constructor.call(b, a);
        b.timeline = [];
        b.createTimeline(b.keyframes);
        if (b.target) {
            b.applyAnimator(b.target);
            Ext.fx.Manager.addAnim(b)
        }
    },
    sorter: function(d, c) {
        return d.pct - c.pct
    },
    createTimeline: function(f) {
        var j = this,
        m = [],
        k = j.to || {},
        c = j.duration,
        n,
        a,
        e,
        h,
        l,
        b,
        d,
        g;
        for (l in f) {
            if (f.hasOwnProperty(l) && j.animKeyFramesRE.test(l)) {
                g = {
                    attrs: Ext.apply(f[l], k)
                };
                if (l == "from") {
                    l = 0
                } else {
                    if (l == "to") {
                        l = 100
                    }
                }
                g.pct = parseInt(l, 10);
                m.push(g)
            }
        }
        Ext.Array.sort(m, j.sorter);
        h = m.length;
        for (e = 0; e < h; e++) {
            n = (m[e - 1]) ? c * (m[e - 1].pct / 100) : 0;
            a = c * (m[e].pct / 100);
            j.timeline.push({
                duration: a - n,
                attrs: m[e].attrs
            })
        }
    },
    applyAnimator: function(e) {
        var j = this,
        k = [],
        n = j.timeline,
        f = j.reverse,
        h = n.length,
        b,
        g,
        a,
        d,
        m,
        l,
        c;
        if (j.fireEvent("beforeanimate", j) !== false) {
            for (c = 0; c < h; c++) {
                b = n[c];
                m = b.attrs;
                g = m.easing || j.easing;
                a = m.damper || j.damper;
                delete m.easing;
                delete m.damper;
                b = Ext.create("Ext.fx.Anim", {
                    target: e,
                    easing: g,
                    damper: a,
                    duration: b.duration,
                    paused: true,
                    to: m
                });
                k.push(b)
            }
            j.animations = k;
            j.target = b.target;
            for (c = 0; c < h - 1; c++) {
                b = k[c];
                b.nextAnim = k[c + 1];
                b.on("afteranimate",
                function() {
                    this.nextAnim.paused = false
                });
                b.on("afteranimate",
                function() {
                    this.fireEvent("keyframe", this, ++this.keyframeStep)
                },
                j)
            }
            k[h - 1].on("afteranimate",
            function() {
                this.lastFrame()
            },
            j)
        }
    },
    start: function(d) {
        var e = this,
        c = e.delay,
        b = e.delayStart,
        a;
        if (c) {
            if (!b) {
                e.delayStart = d;
                return
            } else {
                a = d - b;
                if (a < c) {
                    return
                } else {
                    d = new Date(b.getTime() + c)
                }
            }
        }
        if (e.fireEvent("beforeanimate", e) !== false) {
            e.startTime = d;
            e.running = true;
            e.animations[e.keyframeStep].paused = false
        }
    },
    lastFrame: function() {
        var c = this,
        a = c.iterations,
        b = c.currentIteration;
        b++;
        if (b < a) {
            c.startTime = new Date();
            c.currentIteration = b;
            c.keyframeStep = 0;
            c.applyAnimator(c.target);
            c.animations[c.keyframeStep].paused = false
        } else {
            c.currentIteration = 0;
            c.end()
        }
    },
    end: function() {
        var a = this;
        a.fireEvent("afteranimate", a, a.startTime, new Date() - a.startTime)
    }
});
Ext.define("Ext.draw.Draw", {
    singleton: true,
    requires: ["Ext.draw.Color"],
    pathToStringRE: /,?([achlmqrstvxz]),?/gi,
    pathCommandRE: /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
    pathValuesRE: /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
    stopsRE: /^(\d+%?)$/,
    radian: Math.PI / 180,
    availableAnimAttrs: {
        along: "along",
        blur: null,
        "clip-rect": "csv",
        cx: null,
        cy: null,
        fill: "color",
        "fill-opacity": null,
        "font-size": null,
        height: null,
        opacity: null,
        path: "path",
        r: null,
        rotation: "csv",
        rx: null,
        ry: null,
        scale: "csv",
        stroke: "color",
        "stroke-opacity": null,
        "stroke-width": null,
        translation: "csv",
        width: null,
        x: null,
        y: null
    },
    is: function(b, a) {
        a = String(a).toLowerCase();
        return (a == "object" && b === Object(b)) || (a == "undefined" && typeof b == a) || (a == "null" && b === null) || (a == "array" && Array.isArray && Array.isArray(b)) || (Object.prototype.toString.call(b).toLowerCase().slice(8, -1)) == a
    },
    ellipsePath: function(b) {
        var a = b.attr;
        return Ext.String.format("M{0},{1}A{2},{3},0,1,1,{0},{4}A{2},{3},0,1,1,{0},{1}z", a.x, a.y - a.ry, a.rx, a.ry, a.y + a.ry)
    },
    rectPath: function(b) {
        var a = b.attr;
        if (a.radius) {
            return Ext.String.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", a.x + a.radius, a.y, a.width - a.radius * 2, a.radius, -a.radius, a.height - a.radius * 2, a.radius * 2 - a.width, a.radius * 2 - a.height)
        } else {
            return Ext.String.format("M{0},{1}l{2},0,0,{3},{4},0z", a.x, a.y, a.width, a.height, -a.width)
        }
    },
    path2string: function() {
        return this.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1")
    },
    pathToString: function(a) {
        return a.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1")
    },
    parsePathString: function(a) {
        if (!a) {
            return null
        }
        var d = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        },
        c = [],
        b = this;
        if (b.is(a, "array") && b.is(a[0], "array")) {
            c = b.pathClone(a)
        }
        if (!c.length) {
            String(a).replace(b.pathCommandRE,
            function(f, e, j) {
                var h = [],
                g = e.toLowerCase();
                j.replace(b.pathValuesRE,
                function(l, k) {
                    k && h.push( + k)
                });
                if (g == "m" && h.length > 2) {
                    c.push([e].concat(Ext.Array.splice(h, 0, 2)));
                    g = "l";
                    e = (e == "m") ? "l": "L"
                }
                while (h.length >= d[g]) {
                    c.push([e].concat(Ext.Array.splice(h, 0, d[g])));
                    if (!d[g]) {
                        break
                    }
                }
            })
        }
        c.toString = b.path2string;
        return c
    },
    mapPath: function(k, f) {
        if (!f) {
            return k
        }
        var g, e, c, h, a, d, b;
        k = this.path2curve(k);
        for (c = 0, h = k.length; c < h; c++) {
            b = k[c];
            for (a = 1, d = b.length; a < d - 1; a += 2) {
                g = f.x(b[a], b[a + 1]);
                e = f.y(b[a], b[a + 1]);
                b[a] = g;
                b[a + 1] = e
            }
        }
        return k
    },
    pathClone: function(f) {
        var c = [],
        a,
        e,
        b,
        d;
        if (!this.is(f, "array") || !this.is(f && f[0], "array")) {
            f = this.parsePathString(f)
        }
        for (b = 0, d = f.length; b < d; b++) {
            c[b] = [];
            for (a = 0, e = f[b].length; a < e; a++) {
                c[b][a] = f[b][a]
            }
        }
        c.toString = this.path2string;
        return c
    },
    pathToAbsolute: function(c) {
        if (!this.is(c, "array") || !this.is(c && c[0], "array")) {
            c = this.parsePathString(c)
        }
        var h = [],
        l = 0,
        k = 0,
        n = 0,
        m = 0,
        f = 0,
        g = c.length,
        b,
        d,
        e,
        a;
        if (g && c[0][0] == "M") {
            l = +c[0][1];
            k = +c[0][2];
            n = l;
            m = k;
            f++;
            h[0] = ["M", l, k]
        }
        for (; f < g; f++) {
            b = h[f] = [];
            d = c[f];
            if (d[0] != d[0].toUpperCase()) {
                b[0] = d[0].toUpperCase();
                switch (b[0]) {
                case "A":
                    b[1] = d[1];
                    b[2] = d[2];
                    b[3] = d[3];
                    b[4] = d[4];
                    b[5] = d[5];
                    b[6] = +(d[6] + l);
                    b[7] = +(d[7] + k);
                    break;
                case "V":
                    b[1] = +d[1] + k;
                    break;
                case "H":
                    b[1] = +d[1] + l;
                    break;
                case "M":
                    n = +d[1] + l;
                    m = +d[2] + k;
                default:
                    e = 1;
                    a = d.length;
                    for (; e < a; e++) {
                        b[e] = +d[e] + ((e % 2) ? l: k)
                    }
                }
            } else {
                e = 0;
                a = d.length;
                for (; e < a; e++) {
                    h[f][e] = d[e]
                }
            }
            switch (b[0]) {
            case "Z":
                l = n;
                k = m;
                break;
            case "H":
                l = b[1];
                break;
            case "V":
                k = b[1];
                break;
            case "M":
                d = h[f];
                a = d.length;
                n = d[a - 2];
                m = d[a - 1];
            default:
                d = h[f];
                a = d.length;
                l = d[a - 2];
                k = d[a - 1]
            }
        }
        h.toString = this.path2string;
        return h
    },
    pathToRelative: function(d) {
        if (!this.is(d, "array") || !this.is(d && d[0], "array")) {
            d = this.parsePathString(d)
        }
        var m = [],
        o = 0,
        n = 0,
        s = 0,
        q = 0,
        c = 0;
        if (d[0][0] == "M") {
            o = d[0][1];
            n = d[0][2];
            s = o;
            q = n;
            c++;
            m.push(["M", o, n])
        }
        for (var g = c,
        t = d.length; g < t; g++) {
            var a = m[g] = [],
            p = d[g];
            if (p[0] != p[0].toLowerCase()) {
                a[0] = p[0].toLowerCase();
                switch (a[0]) {
                case "a":
                    a[1] = p[1];
                    a[2] = p[2];
                    a[3] = p[3];
                    a[4] = p[4];
                    a[5] = p[5];
                    a[6] = +(p[6] - o).toFixed(3);
                    a[7] = +(p[7] - n).toFixed(3);
                    break;
                case "v":
                    a[1] = +(p[1] - n).toFixed(3);
                    break;
                case "m":
                    s = p[1];
                    q = p[2];
                default:
                    for (var f = 1,
                    h = p.length; f < h; f++) {
                        a[f] = +(p[f] - ((f % 2) ? o: n)).toFixed(3)
                    }
                }
            } else {
                a = m[g] = [];
                if (p[0] == "m") {
                    s = p[1] + o;
                    q = p[2] + n
                }
                for (var e = 0,
                b = p.length; e < b; e++) {
                    m[g][e] = p[e]
                }
            }
            var l = m[g].length;
            switch (m[g][0]) {
            case "z":
                o = s;
                n = q;
                break;
            case "h":
                o += +m[g][l - 1];
                break;
            case "v":
                n += +m[g][l - 1];
                break;
            default:
                o += +m[g][l - 2];
                n += +m[g][l - 1]
            }
        }
        m.toString = this.path2string;
        return m
    },
    path2curve: function(j) {
        var d = this,
        g = d.pathToAbsolute(j),
        c = g.length,
        h = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        b,
        a,
        f,
        e;
        for (b = 0; b < c; b++) {
            g[b] = d.command2curve(g[b], h);
            if (g[b].length > 7) {
                g[b].shift();
                e = g[b];
                while (e.length) {
                    Ext.Array.splice(g, b++, 0, ["C"].concat(Ext.Array.splice(e, 0, 6)))
                }
                Ext.Array.erase(g, b, 1);
                c = g.length
            }
            a = g[b];
            f = a.length;
            h.x = a[f - 2];
            h.y = a[f - 1];
            h.bx = parseFloat(a[f - 4]) || h.x;
            h.by = parseFloat(a[f - 3]) || h.y
        }
        return g
    },
    interpolatePaths: function(q, k) {
        var h = this,
        d = h.pathToAbsolute(q),
        l = h.pathToAbsolute(k),
        m = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        a = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        b = function(p, r) {
            if (p[r].length > 7) {
                p[r].shift();
                var s = p[r];
                while (s.length) {
                    Ext.Array.splice(p, r++, 0, ["C"].concat(Ext.Array.splice(s, 0, 6)))
                }
                Ext.Array.erase(p, r, 1);
                n = Math.max(d.length, l.length || 0)
            }
        },
        c = function(u, t, r, p, s) {
            if (u && t && u[s][0] == "M" && t[s][0] != "M") {
                Ext.Array.splice(t, s, 0, ["M", p.x, p.y]);
                r.bx = 0;
                r.by = 0;
                r.x = u[s][1];
                r.y = u[s][2];
                n = Math.max(d.length, l.length || 0)
            }
        };
        for (var g = 0,
        n = Math.max(d.length, l.length || 0); g < n; g++) {
            d[g] = h.command2curve(d[g], m);
            b(d, g); (l[g] = h.command2curve(l[g], a));
            b(l, g);
            c(d, l, m, a, g);
            c(l, d, a, m, g);
            var f = d[g],
            o = l[g],
            e = f.length,
            j = o.length;
            m.x = f[e - 2];
            m.y = f[e - 1];
            m.bx = parseFloat(f[e - 4]) || m.x;
            m.by = parseFloat(f[e - 3]) || m.y;
            a.bx = (parseFloat(o[j - 4]) || a.x);
            a.by = (parseFloat(o[j - 3]) || a.y);
            a.x = o[j - 2];
            a.y = o[j - 1]
        }
        return [d, l]
    },
    command2curve: function(c, b) {
        var a = this;
        if (!c) {
            return ["C", b.x, b.y, b.x, b.y, b.x, b.y]
        }
        if (c[0] != "T" && c[0] != "Q") {
            b.qx = b.qy = null
        }
        switch (c[0]) {
        case "M":
            b.X = c[1];
            b.Y = c[2];
            break;
        case "A":
            c = ["C"].concat(a.arc2curve.apply(a, [b.x, b.y].concat(c.slice(1))));
            break;
        case "S":
            c = ["C", b.x + (b.x - (b.bx || b.x)), b.y + (b.y - (b.by || b.y))].concat(c.slice(1));
            break;
        case "T":
            b.qx = b.x + (b.x - (b.qx || b.x));
            b.qy = b.y + (b.y - (b.qy || b.y));
            c = ["C"].concat(a.quadratic2curve(b.x, b.y, b.qx, b.qy, c[1], c[2]));
            break;
        case "Q":
            b.qx = c[1];
            b.qy = c[2];
            c = ["C"].concat(a.quadratic2curve(b.x, b.y, c[1], c[2], c[3], c[4]));
            break;
        case "L":
            c = ["C"].concat(b.x, b.y, c[1], c[2], c[1], c[2]);
            break;
        case "H":
            c = ["C"].concat(b.x, b.y, c[1], b.y, c[1], b.y);
            break;
        case "V":
            c = ["C"].concat(b.x, b.y, b.x, c[1], b.x, c[1]);
            break;
        case "Z":
            c = ["C"].concat(b.x, b.y, b.X, b.Y, b.X, b.Y);
            break
        }
        return c
    },
    quadratic2curve: function(b, d, g, e, a, c) {
        var f = 1 / 3,
        h = 2 / 3;
        return [f * b + h * g, f * d + h * e, f * a + h * g, f * c + h * e, a, c]
    },
    rotate: function(b, g, a) {
        var d = Math.cos(a),
        c = Math.sin(a),
        f = b * d - g * c,
        e = b * c + g * d;
        return {
            x: f,
            y: e
        }
    },
    arc2curve: function(u, ag, I, G, A, n, g, s, af, B) {
        var w = this,
        e = Math.PI,
        z = w.radian,
        F = e * 120 / 180,
        b = z * ( + A || 0),
        N = [],
        K = Math,
        U = K.cos,
        a = K.sin,
        W = K.sqrt,
        v = K.abs,
        o = K.asin,
        J,
        c,
        q,
        P,
        O,
        ab,
        d,
        S,
        V,
        D,
        C,
        m,
        l,
        r,
        j,
        ae,
        f,
        ad,
        Q,
        T,
        R,
        ac,
        aa,
        Z,
        X,
        M,
        Y,
        L,
        E,
        H,
        p;
        if (!B) {
            J = w.rotate(u, ag, -b);
            u = J.x;
            ag = J.y;
            J = w.rotate(s, af, -b);
            s = J.x;
            af = J.y;
            c = U(z * A);
            q = a(z * A);
            P = (u - s) / 2;
            O = (ag - af) / 2;
            ab = (P * P) / (I * I) + (O * O) / (G * G);
            if (ab > 1) {
                ab = W(ab);
                I = ab * I;
                G = ab * G
            }
            d = I * I;
            S = G * G;
            V = (n == g ? -1 : 1) * W(v((d * S - d * O * O - S * P * P) / (d * O * O + S * P * P)));
            D = V * I * O / G + (u + s) / 2;
            C = V * -G * P / I + (ag + af) / 2;
            m = o(((ag - C) / G).toFixed(7));
            l = o(((af - C) / G).toFixed(7));
            m = u < D ? e - m: m;
            l = s < D ? e - l: l;
            if (m < 0) {
                m = e * 2 + m
            }
            if (l < 0) {
                l = e * 2 + l
            }
            if (g && m > l) {
                m = m - e * 2
            }
            if (!g && l > m) {
                l = l - e * 2
            }
        } else {
            m = B[0];
            l = B[1];
            D = B[2];
            C = B[3]
        }
        r = l - m;
        if (v(r) > F) {
            E = l;
            H = s;
            p = af;
            l = m + F * (g && l > m ? 1 : -1);
            s = D + I * U(l);
            af = C + G * a(l);
            N = w.arc2curve(s, af, I, G, A, 0, g, H, p, [l, E, D, C])
        }
        r = l - m;
        j = U(m);
        ae = a(m);
        f = U(l);
        ad = a(l);
        Q = K.tan(r / 4);
        T = 4 / 3 * I * Q;
        R = 4 / 3 * G * Q;
        ac = [u, ag];
        aa = [u + T * ae, ag - R * j];
        Z = [s + T * ad, af - R * f];
        X = [s, af];
        aa[0] = 2 * ac[0] - aa[0];
        aa[1] = 2 * ac[1] - aa[1];
        if (B) {
            return [aa, Z, X].concat(N)
        } else {
            N = [aa, Z, X].concat(N).join().split(",");
            M = [];
            L = N.length;
            for (Y = 0; Y < L; Y++) {
                M[Y] = Y % 2 ? w.rotate(N[Y - 1], N[Y], b).y: w.rotate(N[Y], N[Y + 1], b).x
            }
            return M
        }
    },
    rotateAndTranslatePath: function(h) {
        var c = h.rotation.degrees,
        d = h.rotation.x,
        b = h.rotation.y,
        n = h.translation.x,
        k = h.translation.y,
        m, f, a, l, e, g = [];
        if (!c && !n && !k) {
            return this.pathToAbsolute(h.attr.path)
        }
        n = n || 0;
        k = k || 0;
        m = this.pathToAbsolute(h.attr.path);
        for (f = m.length; f--;) {
            a = g[f] = m[f].slice();
            if (a[0] == "A") {
                l = this.rotatePoint(a[6], a[7], c, d, b);
                a[6] = l.x + n;
                a[7] = l.y + k
            } else {
                e = 1;
                while (a[e + 1] != null) {
                    l = this.rotatePoint(a[e], a[e + 1], c, d, b);
                    a[e] = l.x + n;
                    a[e + 1] = l.y + k;
                    e += 2
                }
            }
        }
        return g
    },
    rotatePoint: function(b, g, e, a, f) {
        if (!e) {
            return {
                x: b,
                y: g
            }
        }
        a = a || 0;
        f = f || 0;
        b = b - a;
        g = g - f;
        e = e * this.radian;
        var d = Math.cos(e),
        c = Math.sin(e);
        return {
            x: b * d - g * c + a,
            y: b * c + g * d + f
        }
    },
    pathDimensions: function(l) {
        if (!l || !(l + "")) {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        }
        l = this.path2curve(l);
        var j = 0,
        h = 0,
        d = [],
        b = [],
        e = 0,
        g = l.length,
        c,
        a,
        k,
        f;
        for (; e < g; e++) {
            c = l[e];
            if (c[0] == "M") {
                j = c[1];
                h = c[2];
                d.push(j);
                b.push(h)
            } else {
                f = this.curveDim(j, h, c[1], c[2], c[3], c[4], c[5], c[6]);
                d = d.concat(f.min.x, f.max.x);
                b = b.concat(f.min.y, f.max.y);
                j = c[5];
                h = c[6]
            }
        }
        a = Math.min.apply(0, d);
        k = Math.min.apply(0, b);
        return {
            x: a,
            y: k,
            path: l,
            width: Math.max.apply(0, d) - a,
            height: Math.max.apply(0, b) - k
        }
    },
    intersectInside: function(b, c, a) {
        return (a[0] - c[0]) * (b[1] - c[1]) > (a[1] - c[1]) * (b[0] - c[0])
    },
    intersectIntersection: function(n, m, f, d) {
        var c = [],
        b = f[0] - d[0],
        a = f[1] - d[1],
        k = n[0] - m[0],
        h = n[1] - m[1],
        l = f[0] * d[1] - f[1] * d[0],
        j = n[0] * m[1] - n[1] * m[0],
        g = 1 / (b * h - a * k);
        c[0] = (l * k - j * b) * g;
        c[1] = (l * h - j * a) * g;
        return c
    },
    intersect: function(n, c) {
        var m = this,
        h = 0,
        l = c.length,
        g = c[l - 1],
        p = n,
        f,
        q,
        k,
        o,
        a,
        b,
        d;
        for (; h < l; ++h) {
            f = c[h];
            b = p;
            p = [];
            q = b[b.length - 1];
            d = 0;
            a = b.length;
            for (; d < a; d++) {
                k = b[d];
                if (m.intersectInside(k, g, f)) {
                    if (!m.intersectInside(q, g, f)) {
                        p.push(m.intersectIntersection(q, k, g, f))
                    }
                    p.push(k)
                } else {
                    if (m.intersectInside(q, g, f)) {
                        p.push(m.intersectIntersection(q, k, g, f))
                    }
                }
                q = k
            }
            g = f
        }
        return p
    },
    curveDim: function(f, d, h, g, t, s, p, m) {
        var r = (t - 2 * h + f) - (p - 2 * t + h),
        o = 2 * (h - f) - 2 * (t - h),
        l = f - h,
        k = ( - o + Math.sqrt(o * o - 4 * r * l)) / 2 / r,
        j = ( - o - Math.sqrt(o * o - 4 * r * l)) / 2 / r,
        n = [d, m],
        q = [f, p],
        e;
        if (Math.abs(k) > 1000000000000) {
            k = 0.5
        }
        if (Math.abs(j) > 1000000000000) {
            j = 0.5
        }
        if (k > 0 && k < 1) {
            e = this.findDotAtSegment(f, d, h, g, t, s, p, m, k);
            q.push(e.x);
            n.push(e.y)
        }
        if (j > 0 && j < 1) {
            e = this.findDotAtSegment(f, d, h, g, t, s, p, m, j);
            q.push(e.x);
            n.push(e.y)
        }
        r = (s - 2 * g + d) - (m - 2 * s + g);
        o = 2 * (g - d) - 2 * (s - g);
        l = d - g;
        k = ( - o + Math.sqrt(o * o - 4 * r * l)) / 2 / r;
        j = ( - o - Math.sqrt(o * o - 4 * r * l)) / 2 / r;
        if (Math.abs(k) > 1000000000000) {
            k = 0.5
        }
        if (Math.abs(j) > 1000000000000) {
            j = 0.5
        }
        if (k > 0 && k < 1) {
            e = this.findDotAtSegment(f, d, h, g, t, s, p, m, k);
            q.push(e.x);
            n.push(e.y)
        }
        if (j > 0 && j < 1) {
            e = this.findDotAtSegment(f, d, h, g, t, s, p, m, j);
            q.push(e.x);
            n.push(e.y)
        }
        return {
            min: {
                x: Math.min.apply(0, q),
                y: Math.min.apply(0, n)
            },
            max: {
                x: Math.max.apply(0, q),
                y: Math.max.apply(0, n)
            }
        }
    },
    getAnchors: function(e, d, k, j, v, u, q) {
        q = q || 4;
        var h = Math,
        p = h.PI,
        r = p / 2,
        m = h.abs,
        a = h.sin,
        b = h.cos,
        f = h.atan,
        t, s, g, l, o, n, x, w, c;
        t = (k - e) / q;
        s = (v - k) / q;
        if ((j >= d && j >= u) || (j <= d && j <= u)) {
            g = l = r
        } else {
            g = f((k - e) / m(j - d));
            if (d < j) {
                g = p - g
            }
            l = f((v - k) / m(j - u));
            if (u < j) {
                l = p - l
            }
        }
        c = r - ((g + l) % (p * 2)) / 2;
        if (c > r) {
            c -= p
        }
        g += c;
        l += c;
        o = k - t * a(g);
        n = j + t * b(g);
        x = k + s * a(l);
        w = j + s * b(l);
        if ((j > d && n < d) || (j < d && n > d)) {
            o += m(d - n) * (o - k) / (n - j);
            n = d
        }
        if ((j > u && w < u) || (j < u && w > u)) {
            x -= m(u - w) * (x - k) / (w - j);
            w = u
        }
        return {
            x1: o,
            y1: n,
            x2: x,
            y2: w
        }
    },
    smooth: function(a, q) {
        var p = this.path2curve(a),
        e = [p[0]],
        h = p[0][1],
        g = p[0][2],
        r,
        t,
        u = 1,
        k = p.length,
        f = 1,
        m = h,
        l = g,
        c = 0,
        b = 0;
        for (; u < k; u++) {
            var z = p[u],
            w = z.length,
            v = p[u - 1],
            n = v.length,
            s = p[u + 1],
            o = s && s.length;
            if (z[0] == "M") {
                m = z[1];
                l = z[2];
                r = u + 1;
                while (p[r][0] != "C") {
                    r++
                }
                c = p[r][5];
                b = p[r][6];
                e.push(["M", m, l]);
                f = e.length;
                h = m;
                g = l;
                continue
            }
            if (z[w - 2] == m && z[w - 1] == l && (!s || s[0] == "M")) {
                var d = e[f].length;
                t = this.getAnchors(v[n - 2], v[n - 1], m, l, e[f][d - 2], e[f][d - 1], q);
                e[f][1] = t.x2;
                e[f][2] = t.y2
            } else {
                if (!s || s[0] == "M") {
                    t = {
                        x1: z[w - 2],
                        y1: z[w - 1]
                    }
                } else {
                    t = this.getAnchors(v[n - 2], v[n - 1], z[w - 2], z[w - 1], s[o - 2], s[o - 1], q)
                }
            }
            e.push(["C", h, g, t.x1, t.y1, z[w - 2], z[w - 1]]);
            h = t.x2;
            g = t.y2
        }
        return e
    },
    findDotAtSegment: function(b, a, d, c, j, h, g, f, k) {
        var e = 1 - k;
        return {
            x: Math.pow(e, 3) * b + Math.pow(e, 2) * 3 * k * d + e * 3 * k * k * j + Math.pow(k, 3) * g,
            y: Math.pow(e, 3) * a + Math.pow(e, 2) * 3 * k * c + e * 3 * k * k * h + Math.pow(k, 3) * f
        }
    },
    snapEnds: function(p, q, d) {
        if (Ext.isDate(p)) {
            return this.snapEndsByDate(p, q, d)
        }
        var c = (q - p) / d,
        a = Math.floor(Math.log(c) / Math.LN10) + 1,
        e = Math.pow(10, a),
        r,
        n = Math.round((c % e) * Math.pow(10, 2 - a)),
        b = [[0, 15], [20, 4], [30, 2], [40, 4], [50, 9], [60, 4], [70, 2], [80, 4], [100, 15]],
        g = 0,
        o,
        j,
        h,
        f,
        k = 1000000000,
        l = b.length;
        r = p = Math.floor(p / e) * e;
        for (h = 0; h < l; h++) {
            o = b[h][0];
            j = (o - n) < 0 ? 1000000 : (o - n) / b[h][1];
            if (j < k) {
                f = o;
                k = j
            }
        }
        c = Math.floor(c * Math.pow(10, -a)) * Math.pow(10, a) + f * Math.pow(10, a - 2);
        while (r < q) {
            r += c;
            g++
        }
        q = +r.toFixed(10);
        return {
            from: p,
            to: q,
            power: a,
            step: c,
            steps: g
        }
    },
    snapEndsByDate: function(h, g, b, a) {
        var d = false,
        f = [[Ext.Date.MILLI, [1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500]], [Ext.Date.SECOND, [1, 2, 3, 5, 10, 15, 30]], [Ext.Date.MINUTE, [1, 2, 3, 5, 10, 20, 30]], [Ext.Date.HOUR, [1, 2, 3, 4, 6, 12]], [Ext.Date.DAY, [1, 2, 3, 7, 14]], [Ext.Date.MONTH, [1, 2, 3, 4, 6]]],
        c,
        e;
        Ext.each(f,
        function(k, j) {
            for (c = 0; c < k[1].length; c++) {
                if (g < Ext.Date.add(h, k[0], k[1][c] * b)) {
                    d = [k[0], k[1][c]];
                    return false
                }
            }
        });
        if (!d) {
            e = this.snapEnds(h.getFullYear(), g.getFullYear() + 1, b, a);
            d = [Date.YEAR, Math.round(e.step)]
        }
        return this.snapEndsByDateAndStep(h, g, d, a)
    },
    snapEndsByDateAndStep: function(h, g, e, a) {
        var d = [h.getFullYear(), h.getMonth(), h.getDate(), h.getHours(), h.getMinutes(), h.getSeconds(), h.getMilliseconds()],
        b = 0,
        f,
        c;
        if (a) {
            f = h
        } else {
            switch (e[0]) {
            case Ext.Date.MILLI:
                f = new Date(d[0], d[1], d[2], d[3], d[4], d[5], Math.floor(d[6] / e[1]) * e[1]);
                break;
            case Ext.Date.SECOND:
                f = new Date(d[0], d[1], d[2], d[3], d[4], Math.floor(d[5] / e[1]) * e[1], 0);
                break;
            case Ext.Date.MINUTE:
                f = new Date(d[0], d[1], d[2], d[3], Math.floor(d[4] / e[1]) * e[1], 0, 0);
                break;
            case Ext.Date.HOUR:
                f = new Date(d[0], d[1], d[2], Math.floor(d[3] / e[1]) * e[1], 0, 0, 0);
                break;
            case Ext.Date.DAY:
                f = new Date(d[0], d[1], Math.floor(d[2] - 1 / e[1]) * e[1] + 1, 0, 0, 0, 0);
                break;
            case Ext.Date.MONTH:
                f = new Date(d[0], Math.floor(d[1] / e[1]) * e[1], 1, 0, 0, 0, 0);
                break;
            default:
                f = new Date(Math.floor(d[0] / e[1]) * e[1], 0, 1, 0, 0, 0, 0);
                break
            }
        }
        c = f;
        while (c < g) {
            c = Ext.Date.add(c, e[0], e[1]);
            b++
        }
        if (a) {
            c = g
        }
        return {
            from: +f,
            to: +c,
            step: (c - f) / b,
            steps: b
        }
    },
    sorter: function(d, c) {
        return d.offset - c.offset
    },
    rad: function(a) {
        return a % 360 * Math.PI / 180
    },
    degrees: function(a) {
        return a * 180 / Math.PI % 360
    },
    withinBox: function(a, c, b) {
        b = b || {};
        return (a >= b.x && a <= (b.x + b.width) && c >= b.y && c <= (b.y + b.height))
    },
    parseGradient: function(k) {
        var e = this,
        f = k.type || "linear",
        c = k.angle || 0,
        h = e.radian,
        l = k.stops,
        a = [],
        j,
        b,
        g,
        d;
        if (f == "linear") {
            b = [0, 0, Math.cos(c * h), Math.sin(c * h)];
            g = 1 / (Math.max(Math.abs(b[2]), Math.abs(b[3])) || 1);
            b[2] *= g;
            b[3] *= g;
            if (b[2] < 0) {
                b[0] = -b[2];
                b[2] = 0
            }
            if (b[3] < 0) {
                b[1] = -b[3];
                b[3] = 0
            }
        }
        for (j in l) {
            if (l.hasOwnProperty(j) && e.stopsRE.test(j)) {
                d = {
                    offset: parseInt(j, 10),
                    color: Ext.draw.Color.toHex(l[j].color) || "#ffffff",
                    opacity: l[j].opacity || 1
                };
                a.push(d)
            }
        }
        Ext.Array.sort(a, e.sorter);
        if (f == "linear") {
            return {
                id: k.id,
                type: f,
                vector: b,
                stops: a
            }
        } else {
            return {
                id: k.id,
                type: f,
                centerX: k.centerX,
                centerY: k.centerY,
                focalX: k.focalX,
                focalY: k.focalY,
                radius: k.radius,
                vector: b,
                stops: a
            }
        }
    }
});
Ext.define("Ext.fx.PropertyHandler", {
    requires: ["Ext.draw.Draw"],
    statics: {
        defaultHandler: {
            pixelDefaultsRE: /width|height|top$|bottom$|left$|right$/i,
            unitRE: /^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/,
            scrollRE: /^scroll/i,
            computeDelta: function(j, c, a, f, h) {
                a = (typeof a == "number") ? a: 1;
                var g = this.unitRE,
                d = g.exec(j),
                b,
                e;
                if (d) {
                    j = d[1];
                    e = d[2];
                    if (!this.scrollRE.test(h) && !e && this.pixelDefaultsRE.test(h)) {
                        e = "px"
                    }
                }
                j = +j || 0;
                d = g.exec(c);
                if (d) {
                    c = d[1];
                    e = d[2] || e
                }
                c = +c || 0;
                b = (f != null) ? f: j;
                return {
                    from: j,
                    delta: (c - b) * a,
                    units: e
                }
            },
            get: function(n, b, a, m, h) {
                var l = n.length,
                d = [],
                e,
                g,
                k,
                c,
                f;
                for (e = 0; e < l; e++) {
                    if (m) {
                        g = m[e][1].from
                    }
                    if (Ext.isArray(n[e][1]) && Ext.isArray(b)) {
                        k = [];
                        c = 0;
                        f = n[e][1].length;
                        for (; c < f; c++) {
                            k.push(this.computeDelta(n[e][1][c], b[c], a, g, h))
                        }
                        d.push([n[e][0], k])
                    } else {
                        d.push([n[e][0], this.computeDelta(n[e][1], b, a, g, h)])
                    }
                }
                return d
            },
            set: function(k, f) {
                var g = k.length,
                c = [],
                d,
                a,
                h,
                e,
                b;
                for (d = 0; d < g; d++) {
                    a = k[d][1];
                    if (Ext.isArray(a)) {
                        h = [];
                        b = 0;
                        e = a.length;
                        for (; b < e; b++) {
                            h.push(a[b].from + (a[b].delta * f) + (a[b].units || 0))
                        }
                        c.push([k[d][0], h])
                    } else {
                        c.push([k[d][0], a.from + (a.delta * f) + (a.units || 0)])
                    }
                }
                return c
            }
        },
        color: {
            rgbRE: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,
            hexRE: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,
            hex3RE: /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i,
            parseColor: function(a, d) {
                d = (typeof d == "number") ? d: 1;
                var e, c = false,
                b;
                Ext.each([this.hexRE, this.rgbRE, this.hex3RE],
                function(g, f) {
                    e = (f % 2 == 0) ? 16 : 10;
                    b = g.exec(a);
                    if (b && b.length == 4) {
                        if (f == 2) {
                            b[1] += b[1];
                            b[2] += b[2];
                            b[3] += b[3]
                        }
                        c = {
                            red: parseInt(b[1], e),
                            green: parseInt(b[2], e),
                            blue: parseInt(b[3], e)
                        };
                        return false
                    }
                });
                return c || a
            },
            computeDelta: function(g, a, e, c) {
                g = this.parseColor(g);
                a = this.parseColor(a, e);
                var f = c ? c: g,
                b = typeof f,
                d = typeof a;
                if (b == "string" || b == "undefined" || d == "string" || d == "undefined") {
                    return a || f
                }
                return {
                    from: g,
                    delta: {
                        red: Math.round((a.red - f.red) * e),
                        green: Math.round((a.green - f.green) * e),
                        blue: Math.round((a.blue - f.blue) * e)
                    }
                }
            },
            get: function(h, a, f, d) {
                var g = h.length,
                c = [],
                e,
                b;
                for (e = 0; e < g; e++) {
                    if (d) {
                        b = d[e][1].from
                    }
                    c.push([h[e][0], this.computeDelta(h[e][1], a, f, b)])
                }
                return c
            },
            set: function(j, e) {
                var f = j.length,
                c = [],
                d,
                b,
                a,
                g,
                h;
                for (d = 0; d < f; d++) {
                    b = j[d][1];
                    if (b) {
                        g = b.from;
                        h = b.delta;
                        b = (typeof b == "object" && "red" in b) ? "rgb(" + b.red + ", " + b.green + ", " + b.blue + ")": b;
                        b = (typeof b == "object" && b.length) ? b[0] : b;
                        if (typeof b == "undefined") {
                            return []
                        }
                        a = typeof b == "string" ? b: "rgb(" + [(g.red + Math.round(h.red * e)) % 256, (g.green + Math.round(h.green * e)) % 256, (g.blue + Math.round(h.blue * e)) % 256].join(",") + ")";
                        c.push([j[d][0], a])
                    }
                }
                return c
            }
        },
        object: {
            interpolate: function(d, b) {
                b = (typeof b == "number") ? b: 1;
                var a = {},
                c;
                for (c in d) {
                    a[c] = parseInt(d[c], 10) * b
                }
                return a
            },
            computeDelta: function(g, a, c, b) {
                g = this.interpolate(g);
                a = this.interpolate(a, c);
                var f = b ? b: g,
                e = {},
                d;
                for (d in a) {
                    e[d] = a[d] - f[d]
                }
                return {
                    from: g,
                    delta: e
                }
            },
            get: function(h, a, f, d) {
                var g = h.length,
                c = [],
                e,
                b;
                for (e = 0; e < g; e++) {
                    if (d) {
                        b = d[e][1].from
                    }
                    c.push([h[e][0], this.computeDelta(h[e][1], a, f, b)])
                }
                return c
            },
            set: function(k, f) {
                var g = k.length,
                c = [],
                e = {},
                d,
                h,
                j,
                b,
                a;
                for (d = 0; d < g; d++) {
                    b = k[d][1];
                    h = b.from;
                    j = b.delta;
                    for (a in h) {
                        e[a] = Math.round(h[a] + j[a] * f)
                    }
                    c.push([k[d][0], e])
                }
                return c
            }
        },
        path: {
            computeDelta: function(e, a, c, b) {
                c = (typeof c == "number") ? c: 1;
                var d;
                e = +e || 0;
                a = +a || 0;
                d = (b != null) ? b: e;
                return {
                    from: e,
                    delta: (a - d) * c
                }
            },
            forcePath: function(a) {
                if (!Ext.isArray(a) && !Ext.isArray(a[0])) {
                    a = Ext.draw.Draw.parsePathString(a)
                }
                return a
            },
            get: function(b, h, a, p) {
                var c = this.forcePath(h),
                m = [],
                r = b.length,
                d,
                g,
                n,
                f,
                o,
                l,
                e,
                s,
                q;
                for (n = 0; n < r; n++) {
                    q = this.forcePath(b[n][1]);
                    f = Ext.draw.Draw.interpolatePaths(q, c);
                    q = f[0];
                    c = f[1];
                    d = q.length;
                    s = [];
                    for (l = 0; l < d; l++) {
                        f = [q[l][0]];
                        g = q[l].length;
                        for (e = 1; e < g; e++) {
                            o = p && p[0][1][l][e].from;
                            f.push(this.computeDelta(q[l][e], c[l][e], a, o))
                        }
                        s.push(f)
                    }
                    m.push([b[n][0], s])
                }
                return m
            },
            set: function(o, m) {
                var n = o.length,
                e = [],
                g,
                f,
                d,
                h,
                l,
                c,
                a,
                b;
                for (g = 0; g < n; g++) {
                    c = o[g][1];
                    h = [];
                    a = c.length;
                    for (f = 0; f < a; f++) {
                        l = [c[f][0]];
                        b = c[f].length;
                        for (d = 1; d < b; d++) {
                            l.push(c[f][d].from + c[f][d].delta * m)
                        }
                        h.push(l.join(","))
                    }
                    e.push([o[g][0], h.join(",")])
                }
                return e
            }
        }
    }
},
function() {
    Ext.each(["outlineColor", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "fill", "stroke"],
    function(a) {
        this[a] = this.color
    },
    this)
});
Ext.define("Ext.fx.Anim", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.fx.Manager", "Ext.fx.Animator", "Ext.fx.Easing", "Ext.fx.CubicBezier", "Ext.fx.PropertyHandler"],
    isAnimation: true,
    duration: 250,
    delay: 0,
    delayStart: 0,
    dynamic: false,
    easing: "ease",
    damper: 1,
    bezierRE: /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    reverse: false,
    running: false,
    paused: false,
    iterations: 1,
    alternate: false,
    currentIteration: 0,
    startTime: 0,
    constructor: function(a) {
        var b = this,
        c;
        a = a || {};
        if (a.keyframes) {
            return Ext.create("Ext.fx.Animator", a)
        }
        a = Ext.apply(b, a);
        if (b.from === undefined) {
            b.from = {}
        }
        b.propHandlers = {};
        b.config = a;
        b.target = Ext.fx.Manager.createTarget(b.target);
        b.easingFn = Ext.fx.Easing[b.easing];
        b.target.dynamic = b.dynamic;
        if (!b.easingFn) {
            b.easingFn = String(b.easing).match(b.bezierRE);
            if (b.easingFn && b.easingFn.length == 5) {
                c = b.easingFn;
                b.easingFn = Ext.fx.CubicBezier.cubicBezier( + c[1], +c[2], +c[3], +c[4])
            }
        }
        b.id = Ext.id(null, "ext-anim-");
        Ext.fx.Manager.addAnim(b);
        b.addEvents("beforeanimate", "afteranimate", "lastframe");
        b.mixins.observable.constructor.call(b, a);
        if (a.callback) {
            b.on("afteranimate", a.callback, a.scope)
        }
        return b
    },
    setAttr: function(a, b) {
        return Ext.fx.Manager.items.get(this.id).setAttr(this.target, a, b)
    },
    initAttrs: function() {
        var e = this,
        g = e.from,
        h = e.to,
        f = e.initialFrom || {},
        c = {},
        a, b, j, d;
        for (d in h) {
            if (h.hasOwnProperty(d)) {
                a = e.target.getAttr(d, g[d]);
                b = h[d];
                if (!Ext.fx.PropertyHandler[d]) {
                    if (Ext.isObject(b)) {
                        j = e.propHandlers[d] = Ext.fx.PropertyHandler.object
                    } else {
                        j = e.propHandlers[d] = Ext.fx.PropertyHandler.defaultHandler
                    }
                } else {
                    j = e.propHandlers[d] = Ext.fx.PropertyHandler[d]
                }
                c[d] = j.get(a, b, e.damper, f[d], d)
            }
        }
        e.currentAttrs = c
    },
    start: function(d) {
        var e = this,
        c = e.delay,
        b = e.delayStart,
        a;
        if (c) {
            if (!b) {
                e.delayStart = d;
                return
            } else {
                a = d - b;
                if (a < c) {
                    return
                } else {
                    d = new Date(b.getTime() + c)
                }
            }
        }
        if (e.fireEvent("beforeanimate", e) !== false) {
            e.startTime = d;
            if (!e.paused && !e.currentAttrs) {
                e.initAttrs()
            }
            e.running = true
        }
    },
    runAnim: function(l) {
        var h = this,
        k = h.currentAttrs,
        d = h.duration,
        c = h.easingFn,
        b = h.propHandlers,
        f = {},
        g, j, e, a;
        if (l >= d) {
            l = d;
            a = true
        }
        if (h.reverse) {
            l = d - l
        }
        for (e in k) {
            if (k.hasOwnProperty(e)) {
                j = k[e];
                g = a ? 1 : c(l / d);
                f[e] = b[e].set(j, g)
            }
        }
        return f
    },
    lastFrame: function() {
        var c = this,
        a = c.iterations,
        b = c.currentIteration;
        b++;
        if (b < a) {
            if (c.alternate) {
                c.reverse = !c.reverse
            }
            c.startTime = new Date();
            c.currentIteration = b;
            c.paused = false
        } else {
            c.currentIteration = 0;
            c.end();
            c.fireEvent("lastframe", c, c.startTime)
        }
    },
    end: function() {
        var a = this;
        a.startTime = 0;
        a.paused = false;
        a.running = false;
        Ext.fx.Manager.removeAnim(a);
        a.fireEvent("afteranimate", a, a.startTime)
    }
});
Ext.enableFx = true;
Ext.define("Ext.state.Manager", {
    singleton: true,
    requires: ["Ext.state.Provider"],
    constructor: function() {
        this.provider = Ext.create("Ext.state.Provider")
    },
    setProvider: function(a) {
        this.provider = a
    },
    get: function(b, a) {
        return this.provider.get(b, a)
    },
    set: function(a, b) {
        this.provider.set(a, b)
    },
    clear: function(a) {
        this.provider.clear(a)
    },
    getProvider: function() {
        return this.provider
    }
});
Ext.define("Ext.state.Stateful", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.state.Manager"],
    stateful: true,
    saveDelay: 100,
    autoGenIdRe: /^((\w+-)|(ext-comp-))\d{4,}$/i,
    constructor: function(a) {
        var b = this;
        a = a || {};
        if (Ext.isDefined(a.stateful)) {
            b.stateful = a.stateful
        }
        if (Ext.isDefined(a.saveDelay)) {
            b.saveDelay = a.saveDelay
        }
        b.stateId = b.stateId || a.stateId;
        if (!b.stateEvents) {
            b.stateEvents = []
        }
        if (a.stateEvents) {
            b.stateEvents.concat(a.stateEvents)
        }
        this.addEvents("beforestaterestore", "staterestore", "beforestatesave", "statesave");
        b.mixins.observable.constructor.call(b);
        if (b.stateful !== false) {
            b.initStateEvents();
            b.initState()
        }
    },
    initStateEvents: function() {
        this.addStateEvents(this.stateEvents)
    },
    addStateEvents: function(c) {
        if (!Ext.isArray(c)) {
            c = [c]
        }
        var d = this,
        b = 0,
        a = c.length;
        for (; b < a; ++b) {
            d.on(c[b], d.onStateChange, d)
        }
    },
    onStateChange: function() {
        var b = this,
        a = b.saveDelay;
        if (a > 0) {
            if (!b.stateTask) {
                b.stateTask = Ext.create("Ext.util.DelayedTask", b.saveState, b)
            }
            b.stateTask.delay(b.saveDelay)
        } else {
            b.saveState()
        }
    },
    saveState: function() {
        var a = this,
        c, b;
        if (a.stateful !== false) {
            c = a.getStateId();
            if (c) {
                b = a.getState();
                if (a.fireEvent("beforestatesave", a, b) !== false) {
                    Ext.state.Manager.set(c, b);
                    a.fireEvent("statesave", a, b)
                }
            }
        }
    },
    getState: function() {
        return null
    },
    applyState: function(a) {
        if (a) {
            Ext.apply(this, a)
        }
    },
    getStateId: function() {
        var a = this,
        b = a.stateId;
        if (!b) {
            b = a.autoGenIdRe.test(String(a.id)) ? null: a.id
        }
        return b
    },
    initState: function() {
        var a = this,
        c = a.getStateId(),
        b;
        if (a.stateful !== false) {
            if (c) {
                b = Ext.state.Manager.get(c);
                if (b) {
                    b = Ext.apply({},
                    b);
                    if (a.fireEvent("beforestaterestore", a, b) !== false) {
                        a.applyState(b);
                        a.fireEvent("staterestore", a, b)
                    }
                }
            }
        }
    },
    savePropToState: function(f, e, d) {
        var b = this,
        c = b[f],
        a = b.initialConfig;
        if (b.hasOwnProperty(f)) {
            if (!a || a[f] !== c) {
                if (e) {
                    e[d || f] = c
                }
                return true
            }
        }
        return false
    },
    savePropsToState: function(c, b) {
        var a = this;
        Ext.each(c,
        function(d) {
            a.savePropToState(d, b)
        });
        return b
    },
    destroy: function() {
        var a = this.stateTask;
        if (a) {
            a.cancel()
        }
        this.clearListeners()
    }
});
Ext.define("Ext.AbstractComponent", {
    requires: ["Ext.ComponentQuery", "Ext.ComponentManager"],
    mixins: {
        observable: "Ext.util.Observable",
        animate: "Ext.util.Animate",
        state: "Ext.state.Stateful"
    },
    uses: ["Ext.PluginManager", "Ext.ComponentManager", "Ext.Element", "Ext.DomHelper", "Ext.XTemplate", "Ext.ComponentQuery", "Ext.ComponentLoader", "Ext.EventManager", "Ext.layout.Layout", "Ext.layout.component.Auto", "Ext.LoadMask", "Ext.ZIndexManager"],
    statics: {
        AUTO_ID: 1000
    },
    isComponent: true,
    getAutoId: function() {
        return++Ext.AbstractComponent.AUTO_ID
    },
    renderTpl: null,
    tplWriteMode: "overwrite",
    baseCls: Ext.baseCSSPrefix + "component",
    disabledCls: Ext.baseCSSPrefix + "item-disabled",
    ui: "default",
    uiCls: [],
    hidden: false,
    disabled: false,
    draggable: false,
    floating: false,
    hideMode: "display",
    styleHtmlContent: false,
    styleHtmlCls: Ext.baseCSSPrefix + "html",
    autoShow: false,
    autoRender: false,
    needsLayout: false,
    allowDomMove: true,
    rendered: false,
    componentLayoutCounter: 0,
    weight: 0,
    trimRe: /^\s+|\s+$/g,
    spacesRe: /\s+/,
    maskOnDisable: true,
    constructor: function(b) {
        var d = this,
        c, a;
        b = b || {};
        d.initialConfig = b;
        Ext.apply(d, b);
        d.addEvents("beforeactivate", "activate", "beforedeactivate", "deactivate", "added", "disable", "enable", "beforeshow", "show", "beforehide", "hide", "removed", "beforerender", "render", "afterrender", "beforedestroy", "destroy", "resize", "move");
        d.getId();
        d.mons = [];
        d.additionalCls = [];
        d.renderData = d.renderData || {};
        d.renderSelectors = d.renderSelectors || {};
        if (d.plugins) {
            d.plugins = [].concat(d.plugins);
            d.constructPlugins()
        }
        d.initComponent();
        Ext.ComponentManager.register(d);
        d.mixins.observable.constructor.call(d);
        d.mixins.state.constructor.call(d, b);
        this.addStateEvents("resize");
        if (d.plugins) {
            d.plugins = [].concat(d.plugins);
            for (c = 0, a = d.plugins.length; c < a; c++) {
                d.plugins[c] = d.initPlugin(d.plugins[c])
            }
        }
        d.loader = d.getLoader();
        if (d.renderTo) {
            d.render(d.renderTo)
        }
        if (d.autoShow) {
            d.show()
        }
        if (Ext.isDefined(d.disabledClass)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Ext.Component: disabledClass has been deprecated. Please use disabledCls.")
            }
            d.disabledCls = d.disabledClass;
            delete d.disabledClass
        }
    },
    initComponent: function() {
        this.constructPlugins()
    },
    getState: function() {
        var f = this,
        e = f.ownerCt ? (f.shadowOwnerCt || f.ownerCt).getLayout() : null,
        g = {
            collapsed: f.collapsed
        },
        c = f.width,
        b = f.height,
        a = f.collapseMemento,
        d;
        if (f.collapsed && a) {
            if (Ext.isDefined(a.data.width)) {
                c = a.width
            }
            if (Ext.isDefined(a.data.height)) {
                b = a.height
            }
        }
        if (e && f.flex) {
            g.flex = f.flex;
            if (e.perpendicularPrefix) {
                g[e.perpendicularPrefix] = f["get" + e.perpendicularPrefixCap]()
            } else {
                if (Ext.isDefined(Ext.global.console)) {
                    Ext.global.console.warn("Ext.Component: Specified a flex value on a component not inside a Box layout")
                }
            }
        } else {
            if (e && f.anchor) {
                g.anchor = f.anchor;
                d = f.anchor.split(" ").concat(null);
                if (!d[0]) {
                    if (f.width) {
                        g.width = c
                    }
                }
                if (!d[1]) {
                    if (f.height) {
                        g.height = b
                    }
                }
            } else {
                if (f.width) {
                    g.width = c
                }
                if (f.height) {
                    g.height = b
                }
            }
        }
        if (g.width == f.initialConfig.width) {
            delete g.width
        }
        if (g.height == f.initialConfig.height) {
            delete g.height
        }
        if (e && e.align && (e.align.indexOf("stretch") !== -1)) {
            delete g[e.perpendicularPrefix]
        }
        return g
    },
    show: Ext.emptyFn,
    animate: function(b) {
        var f = this,
        k;
        b = b || {};
        k = b.to || {};
        if (Ext.fx.Manager.hasFxBlock(f.id)) {
            return f
        }
        if (!b.dynamic && (k.height || k.width)) {
            var e = f.getWidth(),
            l = e,
            d = f.getHeight(),
            c = d,
            a = false;
            if (k.height && k.height > d) {
                c = k.height;
                a = true
            }
            if (k.width && k.width > e) {
                l = k.width;
                a = true
            }
            if (a) {
                var j = !Ext.isNumber(f.width),
                g = !Ext.isNumber(f.height);
                f.componentLayout.childrenChanged = true;
                f.setSize(l, c, f.ownerCt);
                f.el.setSize(e, d);
                if (j) {
                    delete f.width
                }
                if (g) {
                    delete f.height
                }
            }
        }
        return f.mixins.animate.animate.apply(f, arguments)
    },
    findLayoutController: function() {
        return this.findParentBy(function(a) {
            return ! a.ownerCt || (a.layout.layoutBusy && !a.ownerCt.layout.layoutBusy)
        })
    },
    onShow: function() {
        var a = this.needsLayout;
        if (Ext.isObject(a)) {
            this.doComponentLayout(a.width, a.height, a.isSetSize, a.ownerCt)
        }
    },
    constructPlugin: function(a) {
        if (a.ptype && typeof a.init != "function") {
            a.cmp = this;
            a = Ext.PluginManager.create(a)
        } else {
            if (typeof a == "string") {
                a = Ext.PluginManager.create({
                    ptype: a,
                    cmp: this
                })
            }
        }
        return a
    },
    constructPlugins: function() {
        var d = this,
        b = d.plugins,
        c, a;
        if (b) {
            for (c = 0, a = b.length; c < a; c++) {
                b[c] = d.constructPlugin(b[c])
            }
        }
    },
    initPlugin: function(a) {
        a.init(this);
        return a
    },
    doAutoRender: function() {
        var a = this;
        if (a.floating) {
            a.render(document.body)
        } else {
            a.render(Ext.isBoolean(a.autoRender) ? Ext.getBody() : a.autoRender)
        }
    },
    render: function(b, a) {
        var c = this;
        if (!c.rendered && c.fireEvent("beforerender", c) !== false) {
            c.rendering = true;
            if (c.el) {
                c.el = Ext.get(c.el)
            }
            if (c.floating) {
                c.onFloatRender()
            }
            b = c.initContainer(b);
            c.onRender(b, a);
            c.el.setVisibilityMode(Ext.Element[c.hideMode.toUpperCase()]);
            if (c.overCls) {
                c.el.hover(c.addOverCls, c.removeOverCls, c)
            }
            c.fireEvent("render", c);
            c.initContent();
            c.afterRender(b);
            c.fireEvent("afterrender", c);
            c.initEvents();
            if (c.hidden) {
                c.el.hide()
            }
            if (c.disabled) {
                c.disable(true)
            }
            delete c.rendering
        }
        return c
    },
    onRender: function(b, a) {
        var f = this,
        d = f.el,
        e = f.initStyles(),
        h,
        g,
        c;
        a = f.getInsertPosition(a);
        if (!d) {
            if (a) {
                d = Ext.DomHelper.insertBefore(a, f.getElConfig(), true)
            } else {
                d = Ext.DomHelper.append(b, f.getElConfig(), true)
            }
        } else {
            if (f.allowDomMove !== false) {
                if (a) {
                    b.dom.insertBefore(d.dom, a)
                } else {
                    b.dom.appendChild(d.dom)
                }
            }
        }
        if (Ext.scopeResetCSS && !f.ownerCt) {
            if (d.dom == Ext.getBody().dom) {
                d.parent().addCls(Ext.baseCSSPrefix + "reset")
            } else {
                f.resetEl = d.wrap({
                    cls: Ext.baseCSSPrefix + "reset"
                })
            }
        }
        f.setUI(f.ui);
        d.addCls(f.initCls());
        d.setStyle(e);
        f.el = d;
        f.initFrame();
        h = f.initRenderTpl();
        if (h) {
            g = f.initRenderData();
            h.append(f.getTargetEl(), g)
        }
        f.applyRenderSelectors();
        f.rendered = true
    },
    afterRender: function() {
        var a = this,
        c, b;
        a.getComponentLayout();
        if (a.collapsed || (!a.ownerCt || (a.height || a.width))) {
            a.setSize(a.width, a.height)
        } else {
            a.renderChildren()
        }
        if (a.floating && (a.x === undefined || a.y === undefined)) {
            if (a.floatParent) {
                b = a.el.getAlignToXY(a.floatParent.getTargetEl(), "c-c");
                c = a.floatParent.getTargetEl().translatePoints(b[0], b[1])
            } else {
                b = a.el.getAlignToXY(a.container, "c-c");
                c = a.container.translatePoints(b[0], b[1])
            }
            a.x = a.x === undefined ? c.left: a.x;
            a.y = a.y === undefined ? c.top: a.y
        }
        if (Ext.isDefined(a.x) || Ext.isDefined(a.y)) {
            a.setPosition(a.x, a.y)
        }
        if (a.styleHtmlContent) {
            a.getTargetEl().addCls(a.styleHtmlCls)
        }
    },
    registerFloatingItem: function(b) {
        var a = this;
        if (!a.floatingItems) {
            a.floatingItems = Ext.create("Ext.ZIndexManager", a)
        }
        a.floatingItems.register(b)
    },
    renderChildren: function() {
        var b = this,
        a = b.getComponentLayout();
        b.suspendLayout = true;
        a.renderChildren();
        delete b.suspendLayout
    },
    frameCls: Ext.baseCSSPrefix + "frame",
    frameIdRegex: /[-]frame\d+[TMB][LCR]$/,
    frameElementCls: {
        tl: [],
        tc: [],
        tr: [],
        ml: [],
        mc: [],
        mr: [],
        bl: [],
        bc: [],
        br: []
    },
    frameTpl: ['<tpl if="top">', '<tpl if="left"><div id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl></tpl>" style="background-position: {tl}; padding-left: {frameWidth}px" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl></tpl>" style="background-position: {tr}; padding-right: {frameWidth}px" role="presentation"></tpl>', '<div id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl></tpl>" style="background-position: {tc}; height: {frameWidth}px" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', "</tpl>", '<tpl if="left"><div id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl></tpl>" style="background-position: {ml}; padding-left: {frameWidth}px" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl></tpl>" style="background-position: {mr}; padding-right: {frameWidth}px" role="presentation"></tpl>', '<div id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl></tpl>" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', '<tpl if="bottom">', '<tpl if="left"><div id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl></tpl>" style="background-position: {bl}; padding-left: {frameWidth}px" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl></tpl>" style="background-position: {br}; padding-right: {frameWidth}px" role="presentation"></tpl>', '<div id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl></tpl>" style="background-position: {bc}; height: {frameWidth}px" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', "</tpl>"],
    frameTableTpl: ["<table><tbody>", '<tpl if="top">', "<tr>", '<tpl if="left"><td id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl></tpl>" style="background-position: {tl}; padding-left:{frameWidth}px" role="presentation"></td></tpl>', '<td id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl></tpl>" style="background-position: {tc}; height: {frameWidth}px" role="presentation"></td>', '<tpl if="right"><td id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl></tpl>" style="background-position: {tr}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', "</tr>", "</tpl>", "<tr>", '<tpl if="left"><td id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl></tpl>" style="background-position: {ml}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', '<td id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl></tpl>" style="background-position: 0 0;" role="presentation"></td>', '<tpl if="right"><td id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl></tpl>" style="background-position: {mr}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', "</tr>", '<tpl if="bottom">', "<tr>", '<tpl if="left"><td id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl></tpl>" style="background-position: {bl}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', '<td id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl></tpl>" style="background-position: {bc}; height: {frameWidth}px" role="presentation"></td>', '<tpl if="right"><td id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl if="uiCls"><tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl></tpl>" style="background-position: {br}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', "</tr>", "</tpl>", "</tbody></table>"],
    initFrame: function() {
        if (Ext.supports.CSS3BorderRadius) {
            return false
        }
        var e = this,
        d = e.getFrameInfo(),
        b = d.width,
        a = e.getFrameTpl(d.table),
        c;
        if (e.frame) {
            e.frameGenId = c = (e.frameGenId || 0) + 1;
            c = e.id + "-frame" + c;
            a.insertFirst(e.el, Ext.apply({},
            {
                fgid: c,
                ui: e.ui,
                uiCls: e.uiCls,
                frameCls: e.frameCls,
                baseCls: e.baseCls,
                frameWidth: b,
                top: !!d.top,
                left: !!d.left,
                right: !!d.right,
                bottom: !!d.bottom
            },
            e.getFramePositions(d)));
            e.frameBody = e.el.down("." + e.frameCls + "-mc");
            e.removeChildEls(function(f) {
                return f.id && e.frameIdRegex.test(f.id)
            });
            Ext.each(["TL", "TC", "TR", "ML", "MC", "MR", "BL", "BC", "BR"],
            function(f) {
                e.childEls.push({
                    name: "frame" + f,
                    id: c + f
                })
            })
        }
    },
    updateFrame: function() {
        if (Ext.supports.CSS3BorderRadius) {
            return false
        }
        var e = this,
        g = this.frameSize && this.frameSize.table,
        f = this.frameTL,
        d = this.frameBL,
        c = this.frameML,
        a = this.frameMC,
        b;
        this.initFrame();
        if (a) {
            if (e.frame) {
                delete e.frameTL;
                delete e.frameTC;
                delete e.frameTR;
                delete e.frameML;
                delete e.frameMC;
                delete e.frameMR;
                delete e.frameBL;
                delete e.frameBC;
                delete e.frameBR;
                this.applyRenderSelectors();
                b = this.frameMC.dom.className;
                a.insertAfter(this.frameMC);
                this.frameMC.remove();
                this.frameBody = this.frameMC = a;
                a.dom.className = b;
                if (g) {
                    e.el.query("> table")[1].remove()
                } else {
                    if (f) {
                        f.remove()
                    }
                    if (d) {
                        d.remove()
                    }
                    c.remove()
                }
            } else {}
        } else {
            if (e.frame) {
                this.applyRenderSelectors()
            }
        }
    },
    getFrameInfo: function() {
        if (Ext.supports.CSS3BorderRadius) {
            return false
        }
        var c = this,
        f = c.el.getStyle("background-position-x"),
        e = c.el.getStyle("background-position-y"),
        d,
        b = false,
        a;
        if (!f && !e) {
            d = c.el.getStyle("background-position").split(" ");
            f = d[0];
            e = d[1]
        }
        if (parseInt(f, 10) >= 1000000 && parseInt(e, 10) >= 1000000) {
            a = Math.max;
            b = {
                table: f.substr(0, 3) == "110",
                vertical: e.substr(0, 3) == "110",
                top: a(f.substr(3, 2), f.substr(5, 2)),
                right: a(f.substr(5, 2), e.substr(3, 2)),
                bottom: a(e.substr(3, 2), e.substr(5, 2)),
                left: a(e.substr(5, 2), f.substr(3, 2))
            };
            b.width = a(b.top, b.right, b.bottom, b.left);
            c.el.setStyle("background-image", "none")
        }
        if (c.frame === true && !b) {
            Ext.Error.raise("You have set frame: true explicity on this component while it doesn't have any framing defined in the CSS template. In this case IE can't figure out what sizes to use and thus framing on this component will be disabled.")
        }
        c.frame = c.frame || !!b;
        c.frameSize = b || false;
        return b
    },
    getFramePositions: function(e) {
        var g = this,
        h = e.width,
        j = g.dock,
        d, b, f, c, a;
        if (e.vertical) {
            b = "0 -" + (h * 0) + "px";
            f = "0 -" + (h * 1) + "px";
            if (j && j == "right") {
                b = "right -" + (h * 0) + "px";
                f = "right -" + (h * 1) + "px"
            }
            d = {
                tl: "0 -" + (h * 0) + "px",
                tr: "0 -" + (h * 1) + "px",
                bl: "0 -" + (h * 2) + "px",
                br: "0 -" + (h * 3) + "px",
                ml: "-" + (h * 1) + "px 0",
                mr: "right 0",
                tc: b,
                bc: f
            }
        } else {
            c = "-" + (h * 0) + "px 0";
            a = "right 0";
            if (j && j == "bottom") {
                c = "left bottom";
                a = "right bottom"
            }
            d = {
                tl: "0 -" + (h * 2) + "px",
                tr: "right -" + (h * 3) + "px",
                bl: "0 -" + (h * 4) + "px",
                br: "right -" + (h * 5) + "px",
                ml: c,
                mr: a,
                tc: "0 -" + (h * 0) + "px",
                bc: "0 -" + (h * 1) + "px"
            }
        }
        return d
    },
    getFrameTpl: function(a) {
        return a ? this.getTpl("frameTableTpl") : this.getTpl("frameTpl")
    },
    initCls: function() {
        var b = this,
        a = [];
        a.push(b.baseCls);
        if (Ext.isDefined(b.cmpCls)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Ext.Component: cmpCls has been deprecated. Please use componentCls.")
            }
            b.componentCls = b.cmpCls;
            delete b.cmpCls
        }
        if (b.componentCls) {
            a.push(b.componentCls)
        } else {
            b.componentCls = b.baseCls
        }
        if (b.cls) {
            a.push(b.cls);
            delete b.cls
        }
        return a.concat(b.additionalCls)
    },
    setUI: function(f) {
        var e = this,
        b = Ext.Array.clone(e.uiCls),
        g = [],
        d = [],
        a,
        c;
        for (c = 0; c < b.length; c++) {
            a = b[c];
            d = d.concat(e.removeClsWithUI(a, true));
            g.push(a)
        }
        if (d.length) {
            e.removeCls(d)
        }
        e.removeUIFromElement();
        e.ui = f;
        e.addUIToElement();
        d = [];
        for (c = 0; c < g.length; c++) {
            a = g[c];
            d = d.concat(e.addClsWithUI(a, true))
        }
        if (d.length) {
            e.addCls(d)
        }
    },
    addClsWithUI: function(a, e) {
        var d = this,
        c = [],
        b;
        if (!Ext.isArray(a)) {
            a = [a]
        }
        for (b = 0; b < a.length; b++) {
            if (a[b] && !d.hasUICls(a[b])) {
                d.uiCls = Ext.Array.clone(d.uiCls);
                d.uiCls.push(a[b]);
                c = c.concat(d.addUIClsToElement(a[b]))
            }
        }
        if (e !== true) {
            d.addCls(c)
        }
        return c
    },
    removeClsWithUI: function(a, e) {
        var d = this,
        c = [],
        b;
        if (!Ext.isArray(a)) {
            a = [a]
        }
        for (b = 0; b < a.length; b++) {
            if (a[b] && d.hasUICls(a[b])) {
                d.uiCls = Ext.Array.remove(d.uiCls, a[b]);
                c = c.concat(d.removeUIClsFromElement(a[b]))
            }
        }
        if (e !== true) {
            d.removeCls(c)
        }
        return c
    },
    hasUICls: function(a) {
        var b = this,
        c = b.uiCls || [];
        return Ext.Array.contains(c, a)
    },
    addUIClsToElement: function(k, a) {
        var g = this,
        l = [],
        h = g.frameElementCls;
        l.push(Ext.baseCSSPrefix + k);
        l.push(g.baseCls + "-" + k);
        l.push(g.baseCls + "-" + g.ui + "-" + k);
        if (!a && g.frame && !Ext.supports.CSS3BorderRadius) {
            var e = ["tl", "tc", "tr", "ml", "mc", "mr", "bl", "bc", "br"],
            c,
            f,
            d,
            b;
            for (f = 0; f < e.length; f++) {
                b = g["frame" + e[f].toUpperCase()];
                c = [g.baseCls + "-" + g.ui + "-" + e[f], g.baseCls + "-" + g.ui + "-" + k + "-" + e[f]];
                if (b && b.dom) {
                    b.addCls(c)
                } else {
                    for (d = 0; d < c.length; d++) {
                        if (Ext.Array.indexOf(h[e[f]], c[d]) == -1) {
                            h[e[f]].push(c[d])
                        }
                    }
                }
            }
        }
        g.frameElementCls = h;
        return l
    },
    removeUIClsFromElement: function(b, h) {
        var g = this,
        a = [],
        f = g.frameElementCls;
        a.push(Ext.baseCSSPrefix + b);
        a.push(g.baseCls + "-" + b);
        a.push(g.baseCls + "-" + g.ui + "-" + b);
        if (!h && g.frame && !Ext.supports.CSS3BorderRadius) {
            var d = ["tl", "tc", "tr", "ml", "mc", "mr", "bl", "bc", "br"],
            c,
            e;
            b = g.baseCls + "-" + g.ui + "-" + b + "-" + d[c];
            for (c = 0; c < d.length; c++) {
                e = g["frame" + d[c].toUpperCase()];
                if (e && e.dom) {
                    e.removeCls(b)
                } else {
                    Ext.Array.remove(f[d[c]], b)
                }
            }
        }
        g.frameElementCls = f;
        return a
    },
    addUIToElement: function(g) {
        var f = this,
        e = f.frameElementCls;
        f.addCls(f.baseCls + "-" + f.ui);
        if (f.frame && !Ext.supports.CSS3BorderRadius) {
            var c = ["tl", "tc", "tr", "ml", "mc", "mr", "bl", "bc", "br"],
            b,
            d,
            a;
            for (b = 0; b < c.length; b++) {
                d = f["frame" + c[b].toUpperCase()];
                a = f.baseCls + "-" + f.ui + "-" + c[b];
                if (d) {
                    d.addCls(a)
                } else {
                    if (!Ext.Array.contains(e[c[b]], a)) {
                        e[c[b]].push(a)
                    }
                }
            }
        }
    },
    removeUIFromElement: function() {
        var g = this,
        f = g.frameElementCls;
        g.removeCls(g.baseCls + "-" + g.ui);
        if (g.frame && !Ext.supports.CSS3BorderRadius) {
            var d = ["tl", "tc", "tr", "ml", "mc", "mr", "bl", "bc", "br"],
            c,
            b,
            e,
            a;
            for (c = 0; c < d.length; c++) {
                e = g["frame" + d[c].toUpperCase()];
                a = g.baseCls + "-" + g.ui + "-" + d[c];
                if (e) {
                    e.removeCls(a)
                } else {
                    Ext.Array.remove(f[d[c]], a)
                }
            }
        }
    },
    getElConfig: function() {
        if (Ext.isString(this.autoEl)) {
            this.autoEl = {
                tag: this.autoEl
            }
        }
        var a = this.autoEl || {
            tag: "div"
        };
        a.id = this.id;
        return a
    },
    getInsertPosition: function(a) {
        if (a !== undefined) {
            if (Ext.isNumber(a)) {
                a = this.container.dom.childNodes[a]
            } else {
                a = Ext.getDom(a)
            }
        }
        return a
    },
    initContainer: function(a) {
        var b = this;
        if (!a && b.el) {
            a = b.el.dom.parentNode;
            b.allowDomMove = false
        }
        b.container = Ext.get(a);
        if (b.ctCls) {
            b.container.addCls(b.ctCls)
        }
        return b.container
    },
    initRenderData: function() {
        var a = this;
        return Ext.applyIf(a.renderData, {
            id: a.id,
            ui: a.ui,
            uiCls: a.uiCls,
            baseCls: a.baseCls,
            componentCls: a.componentCls,
            frame: a.frame
        })
    },
    getTpl: function(c) {
        var e = this,
        b = e.self.prototype,
        d, a;
        if (e.hasOwnProperty(c)) {
            a = e[c];
            if (a && !(a instanceof Ext.XTemplate)) {
                e[c] = Ext.ClassManager.dynInstantiate("Ext.XTemplate", a)
            }
            return e[c]
        }
        if (! (b[c] instanceof Ext.XTemplate)) {
            d = b;
            do {
                if (d.hasOwnProperty(c)) {
                    a = d[c];
                    if (a && !(a instanceof Ext.XTemplate)) {
                        d[c] = Ext.ClassManager.dynInstantiate("Ext.XTemplate", a);
                        break
                    }
                }
                d = d.superclass
            } while ( d )
        }
        return b[c]
    },
    initRenderTpl: function() {
        return this.getTpl("renderTpl")
    },
    initStyles: function() {
        var b = {},
        c = this,
        a = Ext.Element;
        if (Ext.isString(c.style)) {
            b = a.parseStyles(c.style)
        } else {
            b = Ext.apply({},
            c.style)
        }
        if (c.padding !== undefined) {
            b.padding = a.unitizeBox((c.padding === true) ? 5 : c.padding)
        }
        if (c.margin !== undefined) {
            b.margin = a.unitizeBox((c.margin === true) ? 5 : c.margin)
        }
        delete c.style;
        return b
    },
    initContent: function() {
        var b = this,
        d = b.getTargetEl(),
        a,
        c;
        if (b.html) {
            d.update(Ext.DomHelper.markup(b.html));
            delete b.html
        }
        if (b.contentEl) {
            a = Ext.get(b.contentEl);
            c = Ext.baseCSSPrefix;
            a.removeCls([c + "hidden", c + "hide-display", c + "hide-offsets", c + "hide-nosize"]);
            d.appendChild(a.dom)
        }
        if (b.tpl) {
            if (!b.tpl.isTemplate) {
                b.tpl = Ext.create("Ext.XTemplate", b.tpl)
            }
            if (b.data) {
                b.tpl[b.tplWriteMode](d, b.data);
                delete b.data
            }
        }
    },
    initEvents: function() {
        var c = this,
        e = c.afterRenderEvents,
        b, d, a = function(f) {
            c.mon(b, f)
        };
        if (e) {
            for (d in e) {
                if (e.hasOwnProperty(d)) {
                    b = c[d];
                    if (b && b.on) {
                        Ext.each(e[d], a)
                    }
                }
            }
        }
    },
    addChildEls: function() {
        var b = this,
        a = b.childEls || (b.childEls = []);
        a.push.apply(a, arguments)
    },
    removeChildEls: function(f) {
        var e = this,
        a = e.childEls,
        d = (e.childEls = []),
        g,
        b,
        c;
        for (b = 0, g = a.length; b < g; ++b) {
            c = a[b];
            if (!f(c)) {
                d.push(c)
            }
        }
    },
    applyRenderSelectors: function() {
        var f = this,
        g = f.childEls,
        h = f.renderSelectors,
        a = f.el,
        d = a.dom,
        j, k, c, e, b;
        if (g) {
            j = f.id + "-";
            for (e = g.length; e--;) {
                k = c = g[e];
                if (typeof(k) != "string") {
                    c = k.id || (j + k.itemId);
                    k = k.name
                } else {
                    c = j + c
                }
                f[k] = a.getById(c)
            }
        }
        if (h) {
            for (b in h) {
                if (h.hasOwnProperty(b) && h[b]) {
                    f[b] = Ext.get(Ext.DomQuery.selectNode(h[b], d))
                }
            }
        }
    },
    is: function(a) {
        return Ext.ComponentQuery.is(this, a)
    },
    up: function(b) {
        var a = this.ownerCt;
        if (b) {
            for (; a; a = a.ownerCt) {
                if (Ext.ComponentQuery.is(a, b)) {
                    return a
                }
            }
        }
        return a
    },
    nextSibling: function(b) {
        var f = this.ownerCt,
        d, e, a, g;
        if (f) {
            d = f.items;
            a = d.indexOf(this) + 1;
            if (a) {
                if (b) {
                    for (e = d.getCount(); a < e; a++) {
                        if ((g = d.getAt(a)).is(b)) {
                            return g
                        }
                    }
                } else {
                    if (a < d.getCount()) {
                        return d.getAt(a)
                    }
                }
            }
        }
        return null
    },
    previousSibling: function(b) {
        var e = this.ownerCt,
        d, a, f;
        if (e) {
            d = e.items;
            a = d.indexOf(this);
            if (a != -1) {
                if (b) {
                    for (--a; a >= 0; a--) {
                        if ((f = d.getAt(a)).is(b)) {
                            return f
                        }
                    }
                } else {
                    if (a) {
                        return d.getAt(--a)
                    }
                }
            }
        }
        return null
    },
    previousNode: function(c, d) {
        var g = this,
        b, f, a, e;
        if (d && g.is(c)) {
            return g
        }
        b = this.prev(c);
        if (b) {
            return b
        }
        if (g.ownerCt) {
            for (f = g.ownerCt.items.items, e = Ext.Array.indexOf(f, g) - 1; e > -1; e--) {
                if (f[e].query) {
                    b = f[e].query(c);
                    b = b[b.length - 1];
                    if (b) {
                        return b
                    }
                }
            }
            return g.ownerCt.previousNode(c, true)
        }
    },
    nextNode: function(c, d) {
        var g = this,
        b, f, a, e;
        if (d && g.is(c)) {
            return g
        }
        b = this.next(c);
        if (b) {
            return b
        }
        if (g.ownerCt) {
            for (f = g.ownerCt.items, e = f.indexOf(g) + 1, f = f.items, a = f.length; e < a; e++) {
                if (f[e].down) {
                    b = f[e].down(c);
                    if (b) {
                        return b
                    }
                }
            }
            return g.ownerCt.nextNode(c)
        }
    },
    getId: function() {
        return this.id || (this.id = "ext-comp-" + (this.getAutoId()))
    },
    getItemId: function() {
        return this.itemId || this.id
    },
    getEl: function() {
        return this.el
    },
    getTargetEl: function() {
        return this.frameBody || this.el
    },
    isXType: function(b, a) {
        if (Ext.isFunction(b)) {
            b = b.xtype
        } else {
            if (Ext.isObject(b)) {
                b = b.statics().xtype
            }
        }
        return ! a ? ("/" + this.getXTypes() + "/").indexOf("/" + b + "/") != -1 : this.self.xtype == b
    },
    getXTypes: function() {
        var c = this.self,
        d, b, a;
        if (!c.xtypes) {
            d = [];
            b = this;
            while (b) {
                a = b.xtypes;
                if (a !== undefined) {
                    d.unshift.apply(d, a)
                }
                b = b.superclass
            }
            c.xtypeChain = d;
            c.xtypes = d.join("/")
        }
        return c.xtypes
    },
    update: function(b, c, a) {
        var d = this;
        if (d.tpl && !Ext.isString(b)) {
            d.data = b;
            if (d.rendered) {
                d.tpl[d.tplWriteMode](d.getTargetEl(), b || {})
            }
        } else {
            d.html = Ext.isObject(b) ? Ext.DomHelper.markup(b) : b;
            if (d.rendered) {
                d.getTargetEl().update(d.html, c, a)
            }
        }
        if (d.rendered) {
            d.doComponentLayout()
        }
    },
    setVisible: function(a) {
        return this[a ? "show": "hide"]()
    },
    isVisible: function(a) {
        var c = this,
        e = c,
        d = !c.hidden,
        b = c.ownerCt;
        c.hiddenAncestor = false;
        if (c.destroyed) {
            return false
        }
        if (a && d && c.rendered && b) {
            while (b) {
                if (b.hidden || (b.collapsed && !(b.getDockedItems && Ext.Array.contains(b.getDockedItems(), e)))) {
                    c.hiddenAncestor = b;
                    d = false;
                    break
                }
                e = b;
                b = b.ownerCt
            }
        }
        return d
    },
    enable: function(a) {
        var b = this;
        if (b.rendered) {
            b.el.removeCls(b.disabledCls);
            b.el.dom.disabled = false;
            b.onEnable()
        }
        b.disabled = false;
        if (a !== true) {
            b.fireEvent("enable", b)
        }
        return b
    },
    disable: function(a) {
        var b = this;
        if (b.rendered) {
            b.el.addCls(b.disabledCls);
            b.el.dom.disabled = true;
            b.onDisable()
        }
        b.disabled = true;
        if (a !== true) {
            b.fireEvent("disable", b)
        }
        return b
    },
    onEnable: function() {
        if (this.maskOnDisable) {
            this.el.unmask()
        }
    },
    onDisable: function() {
        if (this.maskOnDisable) {
            this.el.mask()
        }
    },
    isDisabled: function() {
        return this.disabled
    },
    setDisabled: function(a) {
        return this[a ? "disable": "enable"]()
    },
    isHidden: function() {
        return this.hidden
    },
    addCls: function(a) {
        var b = this;
        if (!a) {
            return b
        }
        if (!Ext.isArray(a)) {
            a = a.replace(b.trimRe, "").split(b.spacesRe)
        }
        if (b.rendered) {
            b.el.addCls(a)
        } else {
            b.additionalCls = Ext.Array.unique(b.additionalCls.concat(a))
        }
        return b
    },
    addClass: function() {
        return this.addCls.apply(this, arguments)
    },
    removeCls: function(a) {
        var b = this;
        if (!a) {
            return b
        }
        if (!Ext.isArray(a)) {
            a = a.replace(b.trimRe, "").split(b.spacesRe)
        }
        if (b.rendered) {
            b.el.removeCls(a)
        } else {
            if (b.additionalCls.length) {
                Ext.each(a,
                function(c) {
                    Ext.Array.remove(b.additionalCls, c)
                })
            }
        }
        return b
    },
    removeClass: function() {
        if (Ext.isDefined(Ext.global.console)) {
            Ext.global.console.warn("Ext.Component: removeClass has been deprecated. Please use removeCls.")
        }
        return this.removeCls.apply(this, arguments)
    },
    addOverCls: function() {
        var a = this;
        if (!a.disabled) {
            a.el.addCls(a.overCls)
        }
    },
    removeOverCls: function() {
        this.el.removeCls(this.overCls)
    },
    addListener: function(b, f, e, a) {
        var g = this,
        d, c;
        if (Ext.isString(b) && (Ext.isObject(f) || a && a.element)) {
            if (a.element) {
                d = f;
                f = {};
                f[b] = d;
                b = a.element;
                if (e) {
                    f.scope = e
                }
                for (c in a) {
                    if (a.hasOwnProperty(c)) {
                        if (g.eventOptionsRe.test(c)) {
                            f[c] = a[c]
                        }
                    }
                }
            }
            if (g[b] && g[b].on) {
                g.mon(g[b], f)
            } else {
                g.afterRenderEvents = g.afterRenderEvents || {};
                if (!g.afterRenderEvents[b]) {
                    g.afterRenderEvents[b] = []
                }
                g.afterRenderEvents[b].push(f)
            }
        }
        return g.mixins.observable.addListener.apply(g, arguments)
    },
    removeManagedListenerItem: function(b, a, h, d, f, e) {
        var g = this,
        c = a.options ? a.options.element: null;
        if (c) {
            c = g[c];
            if (c && c.un) {
                if (b || (a.item === h && a.ename === d && (!f || a.fn === f) && (!e || a.scope === e))) {
                    c.un(a.ename, a.fn, a.scope);
                    if (!b) {
                        Ext.Array.remove(g.managedListeners, a)
                    }
                }
            }
        } else {
            return g.mixins.observable.removeManagedListenerItem.apply(g, arguments)
        }
    },
    getBubbleTarget: function() {
        return this.ownerCt
    },
    isFloating: function() {
        return this.floating
    },
    isDraggable: function() {
        return !! this.draggable
    },
    isDroppable: function() {
        return !! this.droppable
    },
    onAdded: function(a, b) {
        this.ownerCt = a;
        this.fireEvent("added", this, a, b)
    },
    onRemoved: function() {
        var a = this;
        a.fireEvent("removed", a, a.ownerCt);
        delete a.ownerCt
    },
    beforeDestroy: Ext.emptyFn,
    onResize: Ext.emptyFn,
    setSize: function(b, a) {
        var c = this,
        d;
        if (Ext.isObject(b)) {
            a = b.height;
            b = b.width
        }
        if (Ext.isNumber(b)) {
            b = Ext.Number.constrain(b, c.minWidth, c.maxWidth)
        }
        if (Ext.isNumber(a)) {
            a = Ext.Number.constrain(a, c.minHeight, c.maxHeight)
        }
        if (!c.rendered || !c.isVisible()) {
            if (c.hiddenAncestor) {
                d = c.hiddenAncestor.layoutOnShow;
                d.remove(c);
                d.add(c)
            }
            c.needsLayout = {
                width: b,
                height: a,
                isSetSize: true
            };
            if (!c.rendered) {
                c.width = (b !== undefined) ? b: c.width;
                c.height = (a !== undefined) ? a: c.height
            }
            return c
        }
        c.doComponentLayout(b, a, true);
        return c
    },
    isFixedWidth: function() {
        var b = this,
        a = b.layoutManagedWidth;
        if (Ext.isDefined(b.width) || a == 1) {
            return true
        }
        if (a == 2) {
            return false
        }
        return (b.ownerCt && b.ownerCt.isFixedWidth())
    },
    isFixedHeight: function() {
        var a = this,
        b = a.layoutManagedHeight;
        if (Ext.isDefined(a.height) || b == 1) {
            return true
        }
        if (b == 2) {
            return false
        }
        return (a.ownerCt && a.ownerCt.isFixedHeight())
    },
    setCalculatedSize: function(b, a, e) {
        var c = this,
        d;
        if (Ext.isObject(b)) {
            e = b.ownerCt;
            a = b.height;
            b = b.width
        }
        if (Ext.isNumber(b)) {
            b = Ext.Number.constrain(b, c.minWidth, c.maxWidth)
        }
        if (Ext.isNumber(a)) {
            a = Ext.Number.constrain(a, c.minHeight, c.maxHeight)
        }
        if (!c.rendered || !c.isVisible()) {
            if (c.hiddenAncestor) {
                d = c.hiddenAncestor.layoutOnShow;
                d.remove(c);
                d.add(c)
            }
            c.needsLayout = {
                width: b,
                height: a,
                isSetSize: false,
                ownerCt: e
            };
            return c
        }
        c.doComponentLayout(b, a, false, e);
        return c
    },
    doComponentLayout: function(e, b, c, g) {
        var f = this,
        d = f.getComponentLayout(),
        a = d.lastComponentSize || {
            width: undefined,
            height: undefined
        };
        if (f.rendered && d) {
            if (!Ext.isDefined(e)) {
                if (f.isFixedWidth()) {
                    e = Ext.isDefined(f.width) ? f.width: a.width
                }
            }
            if (!Ext.isDefined(b)) {
                if (f.isFixedHeight()) {
                    b = Ext.isDefined(f.height) ? f.height: a.height
                }
            }
            if (c) {
                f.width = e;
                f.height = b
            }
            d.layout(e, b, c, g)
        }
        return f
    },
    forceComponentLayout: function() {
        this.doComponentLayout()
    },
    setComponentLayout: function(b) {
        var a = this.componentLayout;
        if (a && a.isLayout && a != b) {
            a.setOwner(null)
        }
        this.componentLayout = b;
        b.setOwner(this)
    },
    getComponentLayout: function() {
        var a = this;
        if (!a.componentLayout || !a.componentLayout.isLayout) {
            a.setComponentLayout(Ext.layout.Layout.create(a.componentLayout, "autocomponent"))
        }
        return a.componentLayout
    },
    afterComponentLayout: function(c, a, b, g) {
        var f = this,
        e = f.componentLayout,
        d = f.preLayoutSize; ++f.componentLayoutCounter;
        if (!d || ((c !== d.width) || (a !== d.height))) {
            f.fireEvent("resize", f, c, a)
        }
    },
    beforeComponentLayout: function(c, a, b, d) {
        this.preLayoutSize = this.componentLayout.lastComponentSize;
        return true
    },
    setPosition: function(a, c) {
        var b = this;
        if (Ext.isObject(a)) {
            c = a.y;
            a = a.x
        }
        if (!b.rendered) {
            return b
        }
        if (a !== undefined || c !== undefined) {
            b.el.setBox(a, c);
            b.onPosition(a, c);
            b.fireEvent("move", b, a, c)
        }
        return b
    },
    onPosition: Ext.emptyFn,
    setWidth: function(a) {
        return this.setSize(a)
    },
    setHeight: function(a) {
        return this.setSize(undefined, a)
    },
    getSize: function() {
        return this.el.getSize()
    },
    getWidth: function() {
        return this.el.getWidth()
    },
    getHeight: function() {
        return this.el.getHeight()
    },
    getLoader: function() {
        var c = this,
        b = c.autoLoad ? (Ext.isObject(c.autoLoad) ? c.autoLoad: {
            url: c.autoLoad
        }) : null,
        a = c.loader || b;
        if (a) {
            if (!a.isLoader) {
                c.loader = Ext.create("Ext.ComponentLoader", Ext.apply({
                    target: c,
                    autoLoad: b
                },
                a))
            } else {
                a.setTarget(c)
            }
            return c.loader
        }
        return null
    },
    setLoading: function(c, d) {
        var b = this,
        a;
        if (b.rendered) {
            if (c !== false && !b.collapsed) {
                if (Ext.isObject(c)) {
                    a = c
                } else {
                    if (Ext.isString(c)) {
                        a = {
                            msg: c
                        }
                    } else {
                        a = {}
                    }
                }
                b.loadMask = b.loadMask || Ext.create("Ext.LoadMask", d ? b.getTargetEl() : b.el, a);
                b.loadMask.show()
            } else {
                if (b.loadMask) {
                    Ext.destroy(b.loadMask);
                    b.loadMask = null
                }
            }
        }
        return b.loadMask
    },
    setDocked: function(b, c) {
        var a = this;
        a.dock = b;
        if (c && a.ownerCt && a.rendered) {
            a.ownerCt.doComponentLayout()
        }
        return a
    },
    onDestroy: function() {
        var a = this;
        if (a.monitorResize && Ext.EventManager.resizeEvent) {
            Ext.EventManager.resizeEvent.removeListener(a.setSize, a)
        }
        Ext.destroy(a.componentLayout, a.loadMask, a.floatingItems)
    },
    cleanElementRefs: function() {
        var g = this,
        e = 0,
        f = g.childEls,
        d = g.renderSelectors,
        b, c, a;
        if (g.rendered) {
            if (f) {
                for (a = f.length; e < a; ++e) {
                    c = f[e];
                    if (typeof(c) != "string") {
                        c = c.name
                    }
                    delete g[c]
                }
            }
            if (d) {
                for (b in d) {
                    if (d.hasOwnProperty(b)) {
                        delete g[b]
                    }
                }
            }
        }
        delete g.rendered;
        delete g.el;
        delete g.frameBody
    },
    destroy: function() {
        var a = this;
        if (!a.isDestroyed) {
            if (a.fireEvent("beforedestroy", a) !== false) {
                a.destroying = true;
                a.beforeDestroy();
                if (a.floating) {
                    delete a.floatParent;
                    if (a.zIndexManager) {
                        a.zIndexManager.unregister(a)
                    }
                } else {
                    if (a.ownerCt && a.ownerCt.remove) {
                        a.ownerCt.remove(a, false)
                    }
                }
                a.onDestroy();
                Ext.destroy(a.plugins);
                if (a.rendered) {
                    a.el.remove()
                }
                a.fireEvent("destroy", a);
                Ext.ComponentManager.unregister(a);
                a.mixins.state.destroy.call(a);
                a.clearListeners();
                a.cleanElementRefs();
                a.destroying = false;
                a.isDestroyed = true
            }
        }
    },
    getPlugin: function(b) {
        var c = 0,
        a = this.plugins,
        d = a.length;
        for (; c < d; c++) {
            if (a[c].pluginId === b) {
                return a[c]
            }
        }
    },
    isDescendantOf: function(a) {
        return !! this.findParentBy(function(b) {
            return b === a
        })
    }
},
function() {
    this.createAlias({
        on: "addListener",
        prev: "previousSibling",
        next: "nextSibling"
    })
});
Ext.define("Ext.Component", {
    alias: ["widget.component", "widget.box"],
    extend: "Ext.AbstractComponent",
    requires: ["Ext.util.DelayedTask"],
    uses: ["Ext.Layer", "Ext.resizer.Resizer", "Ext.util.ComponentDragger"],
    mixins: {
        floating: "Ext.util.Floating"
    },
    statics: {
        DIRECTION_TOP: "top",
        DIRECTION_RIGHT: "right",
        DIRECTION_BOTTOM: "bottom",
        DIRECTION_LEFT: "left",
        VERTICAL_DIRECTION_Re: /^(?:top|bottom)$/,
        INVALID_ID_CHARS_Re: /[\.,\s]/g
    },
    resizeHandles: "all",
    floating: false,
    toFrontOnShow: true,
    hideMode: "display",
    hideParent: false,
    ariaRole: "presentation",
    bubbleEvents: [],
    actionMode: "el",
    monPropRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate)$/,
    constructor: function(a) {
        var b = this;
        a = a || {};
        if (a.initialConfig) {
            if (a.isAction) {
                b.baseAction = a
            }
            a = a.initialConfig
        } else {
            if (a.tagName || a.dom || Ext.isString(a)) {
                a = {
                    applyTo: a,
                    id: a.id || a
                }
            }
        }
        b.callParent([a]);
        if (b.baseAction) {
            b.baseAction.addComponent(b)
        }
    },
    initComponent: function() {
        var a = this;
        a.callParent();
        if (a.listeners) {
            a.on(a.listeners);
            delete a.listeners
        }
        a.enableBubble(a.bubbleEvents);
        a.mons = []
    },
    afterRender: function() {
        var b = this,
        a = b.resizable;
        if (b.floating) {
            b.makeFloating(b.floating)
        } else {
            b.el.setVisibilityMode(Ext.Element[b.hideMode.toUpperCase()])
        }
        if (Ext.isDefined(b.autoScroll)) {
            b.setAutoScroll(b.autoScroll)
        }
        b.callParent();
        if (! (b.x && b.y) && (b.pageX || b.pageY)) {
            b.setPagePosition(b.pageX, b.pageY)
        }
        if (a) {
            b.initResizable(a)
        }
        if (b.draggable) {
            b.initDraggable()
        }
        b.initAria()
    },
    initAria: function() {
        var a = this.getActionEl(),
        b = this.ariaRole;
        if (b) {
            a.dom.setAttribute("role", b)
        }
    },
    setAutoScroll: function(a) {
        var b = this,
        c;
        a = !!a;
        if (b.rendered) {
            c = b.getTargetEl();
            c.setStyle("overflow", a ? "auto": "");
            if (a && (Ext.isIE6 || Ext.isIE7)) {
                c.position()
            }
        }
        b.autoScroll = a;
        return b
    },
    makeFloating: function(a) {
        this.mixins.floating.constructor.call(this, a)
    },
    initResizable: function(a) {
        var b = this;
        a = Ext.apply({
            target: b,
            dynamic: false,
            constrainTo: b.constrainTo || (b.floatParent ? b.floatParent.getTargetEl() : b.el.getScopeParent()),
            handles: b.resizeHandles
        },
        a);
        a.target = b;
        b.resizer = Ext.create("Ext.resizer.Resizer", a)
    },
    getDragEl: function() {
        return this.el
    },
    initDraggable: function() {
        var b = this,
        a = Ext.applyIf({
            el: b.getDragEl(),
            constrainTo: b.constrain ? (b.constrainTo || (b.floatParent ? b.floatParent.getTargetEl() : b.el.getScopeParent())) : undefined
        },
        b.draggable);
        if (b.constrain || b.constrainDelegate) {
            a.constrain = b.constrain;
            a.constrainDelegate = b.constrainDelegate
        }
        b.dd = Ext.create("Ext.util.ComponentDragger", b, a)
    },
    setPosition: function(k, h, a) {
        var f = this,
        b = f.el,
        l = {},
        g, j, e, d, c;
        if (Ext.isArray(k)) {
            a = h;
            h = k[1];
            k = k[0]
        }
        f.x = k;
        f.y = h;
        if (!f.rendered) {
            return f
        }
        g = f.adjustPosition(k, h);
        j = g.x;
        e = g.y;
        d = Ext.isNumber(j);
        c = Ext.isNumber(e);
        if (d || c) {
            if (a) {
                if (d) {
                    l.left = j
                }
                if (c) {
                    l.top = e
                }
                f.stopAnimation();
                f.animate(Ext.apply({
                    duration: 1000,
                    listeners: {
                        afteranimate: Ext.Function.bind(f.afterSetPosition, f, [j, e])
                    },
                    to: l
                },
                a))
            } else {
                if (!d) {
                    b.setTop(e)
                } else {
                    if (!c) {
                        b.setLeft(j)
                    } else {
                        b.setLeftTop(j, e)
                    }
                }
                f.afterSetPosition(j, e)
            }
        }
        return f
    },
    afterSetPosition: function(b, a) {
        this.onPosition(b, a);
        this.fireEvent("move", this, b, a)
    },
    showAt: function(a, d, b) {
        var c = this;
        if (c.floating) {
            c.setPosition(a, d, b)
        } else {
            c.setPagePosition(a, d, b)
        }
        c.show()
    },
    setPagePosition: function(a, e, b) {
        var c = this,
        d;
        if (Ext.isArray(a)) {
            e = a[1];
            a = a[0]
        }
        c.pageX = a;
        c.pageY = e;
        if (c.floating && c.floatParent) {
            d = c.floatParent.getTargetEl().getViewRegion();
            if (Ext.isNumber(a) && Ext.isNumber(d.left)) {
                a -= d.left
            }
            if (Ext.isNumber(e) && Ext.isNumber(d.top)) {
                e -= d.top
            }
            c.setPosition(a, e, b)
        } else {
            d = c.el.translatePoints(a, e);
            c.setPosition(d.left, d.top, b)
        }
        return c
    },
    getBox: function(b) {
        var c = this.getPosition(b),
        a = this.getSize();
        a.x = c[0];
        a.y = c[1];
        return a
    },
    updateBox: function(a) {
        this.setSize(a.width, a.height);
        this.setPagePosition(a.x, a.y);
        return this
    },
    getOuterSize: function() {
        var a = this.el;
        return {
            width: a.getWidth() + a.getMargin("lr"),
            height: a.getHeight() + a.getMargin("tb")
        }
    },
    adjustPosition: function(a, c) {
        if (this.floating && this.floatParent) {
            var b = this.floatParent.getTargetEl().getViewRegion();
            a += b.left;
            c += b.top
        }
        return {
            x: a,
            y: c
        }
    },
    getPosition: function(a) {
        var c = this,
        b = c.el,
        d, e;
        if ((a === true) || (c.floating && !c.floatParent)) {
            return [b.getLeft(true), b.getTop(true)]
        }
        d = c.xy || b.getXY();
        if (c.floating) {
            e = c.floatParent.getTargetEl().getViewRegion();
            d[0] -= e.left;
            d[1] -= e.top
        }
        return d
    },
    getId: function() {
        var a = this,
        b;
        if (!a.id) {
            b = a.getXType();
            b = b ? b.replace(Ext.Component.INVALID_ID_CHARS_Re, "-") : "ext-comp";
            a.id = b + "-" + a.getAutoId()
        }
        return a.id
    },
    onEnable: function() {
        var a = this.getActionEl();
        a.dom.removeAttribute("aria-disabled");
        a.dom.disabled = false;
        this.callParent()
    },
    onDisable: function() {
        var a = this.getActionEl();
        a.dom.setAttribute("aria-disabled", true);
        a.dom.disabled = true;
        this.callParent()
    },
    show: function(d, a, b) {
        var c = this;
        if (c.rendered && c.isVisible()) {
            if (c.toFrontOnShow && c.floating) {
                c.toFront()
            }
        } else {
            if (c.fireEvent("beforeshow", c) !== false) {
                c.hidden = false;
                if (!c.rendered && (c.autoRender || c.floating)) {
                    c.doAutoRender()
                }
                if (c.rendered) {
                    c.beforeShow();
                    c.onShow.apply(c, arguments);
                    if (c.ownerCt && !c.floating && !(c.ownerCt.suspendLayout || c.ownerCt.layout.layoutBusy)) {
                        c.ownerCt.doLayout()
                    }
                    c.afterShow.apply(c, arguments)
                }
            }
        }
        return c
    },
    beforeShow: Ext.emptyFn,
    onShow: function() {
        var a = this;
        a.el.show();
        a.callParent(arguments);
        if (a.floating && a.constrain) {
            a.doConstrain()
        }
    },
    afterShow: function(g, b, e) {
        var f = this,
        a, c, d;
        g = g || f.animateTarget;
        if (!f.ghost) {
            g = null
        }
        if (g) {
            g = g.el ? g.el: Ext.get(g);
            c = f.el.getBox();
            a = g.getBox();
            f.el.addCls(Ext.baseCSSPrefix + "hide-offsets");
            d = f.ghost();
            d.el.stopAnimation();
            d.el.setX( - 10000);
            d.el.animate({
                from: a,
                to: c,
                listeners: {
                    afteranimate: function() {
                        delete d.componentLayout.lastComponentSize;
                        f.unghost();
                        f.el.removeCls(Ext.baseCSSPrefix + "hide-offsets");
                        f.onShowComplete(b, e)
                    }
                }
            })
        } else {
            f.onShowComplete(b, e)
        }
    },
    onShowComplete: function(a, b) {
        var c = this;
        if (c.floating) {
            c.toFront()
        }
        Ext.callback(a, b || c);
        c.fireEvent("show", c)
    },
    hide: function() {
        var a = this;
        a.showOnParentShow = false;
        if (! (a.rendered && !a.isVisible()) && a.fireEvent("beforehide", a) !== false) {
            a.hidden = true;
            if (a.rendered) {
                a.onHide.apply(a, arguments);
                if (a.ownerCt && !a.floating && !(a.ownerCt.suspendLayout || a.ownerCt.layout.layoutBusy)) {
                    a.ownerCt.doLayout()
                }
            }
        }
        return a
    },
    onHide: function(f, a, d) {
        var e = this,
        c, b;
        f = f || e.animateTarget;
        if (!e.ghost) {
            f = null
        }
        if (f) {
            f = f.el ? f.el: Ext.get(f);
            c = e.ghost();
            c.el.stopAnimation();
            b = f.getBox();
            b.width += "px";
            b.height += "px";
            c.el.animate({
                to: b,
                listeners: {
                    afteranimate: function() {
                        delete c.componentLayout.lastComponentSize;
                        c.el.hide();
                        e.afterHide(a, d)
                    }
                }
            })
        }
        e.el.hide();
        if (!f) {
            e.afterHide(a, d)
        }
    },
    afterHide: function(a, b) {
        Ext.callback(a, b || this);
        this.fireEvent("hide", this)
    },
    onDestroy: function() {
        var a = this;
        if (a.rendered) {
            Ext.destroy(a.proxy, a.proxyWrap, a.resizer);
            if (a.actionMode == "container" || a.removeMode == "container") {
                a.container.remove()
            }
        }
        delete a.focusTask;
        a.callParent()
    },
    deleteMembers: function() {
        var b = arguments,
        a = b.length,
        c = 0;
        for (; c < a; ++c) {
            delete this[b[c]]
        }
    },
    focus: function(d, b) {
        var c = this,
        a;
        if (b) {
            if (!c.focusTask) {
                c.focusTask = Ext.create("Ext.util.DelayedTask", c.focus)
            }
            c.focusTask.delay(Ext.isNumber(b) ? b: 10, null, c, [d, false]);
            return c
        }
        if (c.rendered && !c.isDestroyed) {
            a = c.getFocusEl();
            a.focus();
            if (a.dom && d === true) {
                a.dom.select()
            }
            if (c.floating) {
                c.toFront(true)
            }
        }
        return c
    },
    getFocusEl: function() {
        return this.el
    },
    blur: function() {
        if (this.rendered) {
            this.getFocusEl().blur()
        }
        return this
    },
    getEl: function() {
        return this.el
    },
    getResizeEl: function() {
        return this.el
    },
    getPositionEl: function() {
        return this.el
    },
    getActionEl: function() {
        return this.el
    },
    getVisibilityEl: function() {
        return this.el
    },
    onResize: Ext.emptyFn,
    getBubbleTarget: function() {
        return this.ownerCt
    },
    getContentTarget: function() {
        return this.el
    },
    cloneConfig: function(c) {
        c = c || {};
        var d = c.id || Ext.id(),
        a = Ext.applyIf(c, this.initialConfig),
        b;
        a.id = d;
        b = Ext.getClass(this);
        return new b(a)
    },
    getXType: function() {
        return this.self.xtype
    },
    findParentBy: function(a) {
        var b;
        for (b = this.ownerCt; b && !a(b, this); b = b.ownerCt) {}
        return b || null
    },
    findParentByType: function(a) {
        return Ext.isFunction(a) ? this.findParentBy(function(b) {
            return b.constructor === a
        }) : this.up(a)
    },
    bubble: function(c, b, a) {
        var d = this;
        while (d) {
            if (c.apply(b || d, a || [d]) === false) {
                break
            }
            d = d.ownerCt
        }
        return this
    },
    getProxy: function() {
        var a = this,
        b;
        if (!a.proxy) {
            b = Ext.getBody();
            if (Ext.scopeResetCSS) {
                a.proxyWrap = b = Ext.getBody().createChild({
                    cls: Ext.baseCSSPrefix + "reset"
                })
            }
            a.proxy = a.el.createProxy(Ext.baseCSSPrefix + "proxy-el", b, true)
        }
        return a.proxy
    }
});
Ext.define("Ext.button.Button", {
    alias: "widget.button",
    extend: "Ext.Component",
    requires: ["Ext.menu.Manager", "Ext.util.ClickRepeater", "Ext.layout.component.Button", "Ext.util.TextMetrics", "Ext.util.KeyMap"],
    alternateClassName: "Ext.Button",
    isButton: true,
    componentLayout: "button",
    hidden: false,
    disabled: false,
    pressed: false,
    enableToggle: false,
    menuAlign: "tl-bl?",
    textAlign: "center",
    type: "button",
    clickEvent: "click",
    preventDefault: true,
    handleMouseEvents: true,
    tooltipType: "qtip",
    baseCls: Ext.baseCSSPrefix + "btn",
    pressedCls: "pressed",
    overCls: "over",
    focusCls: "focus",
    menuActiveCls: "menu-active",
    ariaRole: "button",
    renderTpl: '<em id="{id}-btnWrap" class="{splitCls}"><tpl if="href"><a id="{id}-btnEl" href="{href}" target="{target}"<tpl if="tabIndex"> tabIndex="{tabIndex}"</tpl> role="link"><span id="{id}-btnInnerEl" class="{baseCls}-inner">{text}</span><span id="{id}-btnIconEl" class="{baseCls}-icon"></span></a></tpl><tpl if="!href"><button id="{id}-btnEl" type="{type}" hidefocus="true"<tpl if="tabIndex"> tabIndex="{tabIndex}"</tpl> role="button" autocomplete="off"><span id="{id}-btnInnerEl" class="{baseCls}-inner" style="{innerSpanStyle}">{text}</span><span id="{id}-btnIconEl" class="{baseCls}-icon {iconCls}">&#160;</span></button></tpl></em>',
    scale: "small",
    allowedScales: ["small", "medium", "large"],
    iconAlign: "left",
    arrowAlign: "right",
    arrowCls: "arrow",
    maskOnDisable: false,
    initComponent: function() {
        var a = this;
        a.callParent(arguments);
        a.addEvents("click", "toggle", "mouseover", "mouseout", "menushow", "menuhide", "menutriggerover", "menutriggerout");
        if (a.menu) {
            a.split = true;
            a.menu = Ext.menu.Manager.get(a.menu);
            a.menu.ownerCt = a
        }
        if (a.url) {
            a.href = a.url
        }
        if (a.href && !a.hasOwnProperty("preventDefault")) {
            a.preventDefault = false
        }
        if (Ext.isString(a.toggleGroup)) {
            a.enableToggle = true
        }
    },
    initAria: function() {
        this.callParent();
        var a = this.getActionEl();
        if (this.menu) {
            a.dom.setAttribute("aria-haspopup", true)
        }
    },
    getActionEl: function() {
        return this.btnEl
    },
    getFocusEl: function() {
        return this.btnEl
    },
    setButtonCls: function() {
        var d = this,
        b = [],
        a = d.btnIconEl,
        c = "x-hide-display";
        if (d.useSetClass) {
            if (!Ext.isEmpty(d.oldCls)) {
                d.removeClsWithUI(d.oldCls);
                d.removeClsWithUI(d.pressedCls)
            }
            if (d.iconCls || d.icon) {
                if (d.text) {
                    b.push("icon-text-" + d.iconAlign)
                } else {
                    b.push("icon")
                }
                if (a) {
                    a.removeCls(c)
                }
            } else {
                if (d.text) {
                    b.push("noicon")
                }
                if (a) {
                    a.addCls(c)
                }
            }
            d.oldCls = b;
            d.addClsWithUI(b);
            d.addClsWithUI(d.pressed ? d.pressedCls: null)
        }
    },
    onRender: function(d, a) {
        var e = this,
        c, b;
        Ext.applyIf(e.renderData, e.getTemplateArgs());
        e.addChildEls("btnEl", "btnWrap", "btnInnerEl", "btnIconEl");
        if (e.scale) {
            e.ui = e.ui + "-" + e.scale
        }
        e.callParent(arguments);
        if (e.split && e.arrowTooltip) {
            e.arrowEl.dom.setAttribute(e.getTipAttr(), e.arrowTooltip)
        }
        e.mon(e.btnEl, {
            scope: e,
            focus: e.onFocus,
            blur: e.onBlur
        });
        b = e.el;
        if (e.icon) {
            e.setIcon(e.icon)
        }
        if (e.iconCls) {
            e.setIconCls(e.iconCls)
        }
        if (e.tooltip) {
            e.setTooltip(e.tooltip, true)
        }
        if (e.textAlign) {
            e.setTextAlign(e.textAlign)
        }
        if (e.handleMouseEvents) {
            e.mon(b, {
                scope: e,
                mouseover: e.onMouseOver,
                mouseout: e.onMouseOut,
                mousedown: e.onMouseDown
            });
            if (e.split) {
                e.mon(b, {
                    mousemove: e.onMouseMove,
                    scope: e
                })
            }
        }
        if (e.menu) {
            e.mon(e.menu, {
                scope: e,
                show: e.onMenuShow,
                hide: e.onMenuHide
            });
            e.keyMap = Ext.create("Ext.util.KeyMap", e.el, {
                key: Ext.EventObject.DOWN,
                handler: e.onDownKey,
                scope: e
            })
        }
        if (e.repeat) {
            c = Ext.create("Ext.util.ClickRepeater", b, Ext.isObject(e.repeat) ? e.repeat: {});
            e.mon(c, "click", e.onRepeatClick, e)
        } else {
            e.mon(b, e.clickEvent, e.onClick, e)
        }
        Ext.ButtonToggleManager.register(e)
    },
    getTemplateArgs: function() {
        var c = this,
        b = c.getPersistentBtnPadding(),
        a = "";
        if (Math.max.apply(Math, b) > 0) {
            a = "margin:" + Ext.Array.map(b,
            function(d) {
                return - d + "px"
            }).join(" ")
        }
        return {
            href: c.getHref(),
            target: c.target || "_blank",
            type: c.type,
            splitCls: c.getSplitCls(),
            cls: c.cls,
            iconCls: c.iconCls || "",
            text: c.text || "&#160;",
            tabIndex: c.tabIndex,
            innerSpanStyle: a
        }
    },
    getHref: function() {
        var a = this,
        b = Ext.apply({},
        a.baseParams);
        b = Ext.apply(b, a.params);
        return a.href ? Ext.urlAppend(a.href, Ext.Object.toQueryString(b)) : false
    },
    setParams: function(a) {
        this.params = a;
        this.btnEl.dom.href = this.getHref()
    },
    getSplitCls: function() {
        var a = this;
        return a.split ? (a.baseCls + "-" + a.arrowCls) + " " + (a.baseCls + "-" + a.arrowCls + "-" + a.arrowAlign) : ""
    },
    afterRender: function() {
        var a = this;
        a.useSetClass = true;
        a.setButtonCls();
        a.doc = Ext.getDoc();
        this.callParent(arguments)
    },
    setIconCls: function(b) {
        var d = this,
        a = d.btnIconEl,
        c = d.iconCls;
        d.iconCls = b;
        if (a) {
            a.removeCls(c);
            a.addCls(b || "");
            d.setButtonCls()
        }
        return d
    },
    setTooltip: function(c, a) {
        var b = this;
        if (b.rendered) {
            if (!a) {
                b.clearTip()
            }
            if (Ext.isObject(c)) {
                Ext.tip.QuickTipManager.register(Ext.apply({
                    target: b.btnEl.id
                },
                c));
                b.tooltip = c
            } else {
                b.btnEl.dom.setAttribute(b.getTipAttr(), c)
            }
        } else {
            b.tooltip = c
        }
        return b
    },
    setTextAlign: function(c) {
        var b = this,
        a = b.btnEl;
        if (a) {
            a.removeCls(b.baseCls + "-" + b.textAlign);
            a.addCls(b.baseCls + "-" + c)
        }
        b.textAlign = c;
        return b
    },
    getTipAttr: function() {
        return this.tooltipType == "qtip" ? "data-qtip": "title"
    },
    getRefItems: function(a) {
        var c = this.menu,
        b;
        if (c) {
            b = c.getRefItems(a);
            b.unshift(c)
        }
        return b || []
    },
    clearTip: function() {
        if (Ext.isObject(this.tooltip)) {
            Ext.tip.QuickTipManager.unregister(this.btnEl)
        }
    },
    beforeDestroy: function() {
        var a = this;
        if (a.rendered) {
            a.clearTip()
        }
        if (a.menu && a.destroyMenu !== false) {
            Ext.destroy(a.menu)
        }
        Ext.destroy(a.btnInnerEl, a.repeater);
        a.callParent()
    },
    onDestroy: function() {
        var a = this;
        if (a.rendered) {
            a.doc.un("mouseover", a.monitorMouseOver, a);
            a.doc.un("mouseup", a.onMouseUp, a);
            delete a.doc;
            Ext.ButtonToggleManager.unregister(a);
            Ext.destroy(a.keyMap);
            delete a.keyMap
        }
        a.callParent()
    },
    setHandler: function(b, a) {
        this.handler = b;
        this.scope = a;
        return this
    },
    setText: function(b) {
        var a = this;
        a.text = b;
        if (a.el) {
            a.btnInnerEl.update(b || "&#160;");
            a.setButtonCls()
        }
        a.doComponentLayout();
        return a
    },
    setIcon: function(b) {
        var c = this,
        a = c.btnIconEl;
        c.icon = b;
        if (a) {
            a.setStyle("background-image", b ? "url(" + b + ")": "");
            c.setButtonCls()
        }
        return c
    },
    getText: function() {
        return this.text
    },
    toggle: function(c, a) {
        var b = this;
        c = c === undefined ? !b.pressed: !!c;
        if (c !== b.pressed) {
            if (b.rendered) {
                b[c ? "addClsWithUI": "removeClsWithUI"](b.pressedCls)
            }
            b.btnEl.dom.setAttribute("aria-pressed", c);
            b.pressed = c;
            if (!a) {
                b.fireEvent("toggle", b, c);
                Ext.callback(b.toggleHandler, b.scope || b, [b, c])
            }
        }
        return b
    },
    maybeShowMenu: function() {
        var a = this;
        if (a.menu && !a.hasVisibleMenu() && !a.ignoreNextClick) {
            a.showMenu()
        }
    },
    showMenu: function() {
        var a = this;
        if (a.rendered && a.menu) {
            if (a.tooltip && a.getTipAttr() != "title") {
                Ext.tip.QuickTipManager.getQuickTip().cancelShow(a.btnEl)
            }
            if (a.menu.isVisible()) {
                a.menu.hide()
            }
            a.menu.showBy(a.el, a.menuAlign)
        }
        return a
    },
    hideMenu: function() {
        if (this.hasVisibleMenu()) {
            this.menu.hide()
        }
        return this
    },
    hasVisibleMenu: function() {
        var a = this.menu;
        return a && a.rendered && a.isVisible()
    },
    onRepeatClick: function(a, b) {
        this.onClick(b)
    },
    onClick: function(b) {
        var a = this;
        if (a.preventDefault || (a.disabled && a.getHref()) && b) {
            b.preventDefault()
        }
        if (b.button !== 0) {
            return
        }
        if (!a.disabled) {
            a.doToggle();
            a.maybeShowMenu();
            a.fireHandler(b)
        }
    },
    fireHandler: function(c) {
        var b = this,
        a = b.handler;
        b.fireEvent("click", b, c);
        if (a) {
            a.call(b.scope || b, b, c)
        }
        b.onBlur()
    },
    doToggle: function() {
        var a = this;
        if (a.enableToggle && (a.allowDepress !== false || !a.pressed)) {
            a.toggle()
        }
    },
    onMouseOver: function(b) {
        var a = this;
        if (!a.disabled && !b.within(a.el, true, true)) {
            a.onMouseEnter(b)
        }
    },
    onMouseOut: function(b) {
        var a = this;
        if (!b.within(a.el, true, true)) {
            if (a.overMenuTrigger) {
                a.onMenuTriggerOut(b)
            }
            a.onMouseLeave(b)
        }
    },
    onMouseMove: function(g) {
        var d = this,
        c = d.el,
        f = d.overMenuTrigger,
        b, a;
        if (d.split) {
            if (d.arrowAlign === "right") {
                b = g.getX() - c.getX();
                a = c.getWidth()
            } else {
                b = g.getY() - c.getY();
                a = c.getHeight()
            }
            if (b > (a - d.getTriggerSize())) {
                if (!f) {
                    d.onMenuTriggerOver(g)
                }
            } else {
                if (f) {
                    d.onMenuTriggerOut(g)
                }
            }
        }
    },
    getTriggerSize: function() {
        var e = this,
        c = e.triggerSize,
        b, a, d;
        if (c === d) {
            b = e.arrowAlign;
            a = b.charAt(0);
            c = e.triggerSize = e.el.getFrameWidth(a) + e.btnWrap.getFrameWidth(a) + (e.frameSize && e.frameSize[b] || 0)
        }
        return c
    },
    onMouseEnter: function(b) {
        var a = this;
        a.addClsWithUI(a.overCls);
        a.fireEvent("mouseover", a, b)
    },
    onMouseLeave: function(b) {
        var a = this;
        a.removeClsWithUI(a.overCls);
        a.fireEvent("mouseout", a, b)
    },
    onMenuTriggerOver: function(b) {
        var a = this;
        a.overMenuTrigger = true;
        a.fireEvent("menutriggerover", a, a.menu, b)
    },
    onMenuTriggerOut: function(b) {
        var a = this;
        delete a.overMenuTrigger;
        a.fireEvent("menutriggerout", a, a.menu, b)
    },
    enable: function(a) {
        var b = this;
        b.callParent(arguments);
        b.removeClsWithUI("disabled");
        return b
    },
    disable: function(a) {
        var b = this;
        b.callParent(arguments);
        b.addClsWithUI("disabled");
        b.removeClsWithUI(b.overCls);
        return b
    },
    setScale: function(c) {
        var a = this,
        b = a.ui.replace("-" + a.scale, "");
        if (!Ext.Array.contains(a.allowedScales, c)) {
            throw ("#setScale: scale must be an allowed scale (" + a.allowedScales.join(", ") + ")")
        }
        a.scale = c;
        a.setUI(b)
    },
    setUI: function(b) {
        var a = this;
        if (a.scale && !b.match(a.scale)) {
            b = b + "-" + a.scale
        }
        a.callParent([b])
    },
    onFocus: function(b) {
        var a = this;
        if (!a.disabled) {
            a.addClsWithUI(a.focusCls)
        }
    },
    onBlur: function(b) {
        var a = this;
        a.removeClsWithUI(a.focusCls)
    },
    onMouseDown: function(b) {
        var a = this;
        if (!a.disabled && b.button === 0) {
            a.addClsWithUI(a.pressedCls);
            a.doc.on("mouseup", a.onMouseUp, a)
        }
    },
    onMouseUp: function(b) {
        var a = this;
        if (b.button === 0) {
            if (!a.pressed) {
                a.removeClsWithUI(a.pressedCls)
            }
            a.doc.un("mouseup", a.onMouseUp, a)
        }
    },
    onMenuShow: function(b) {
        var a = this;
        a.ignoreNextClick = 0;
        a.addClsWithUI(a.menuActiveCls);
        a.fireEvent("menushow", a, a.menu)
    },
    onMenuHide: function(b) {
        var a = this;
        a.removeClsWithUI(a.menuActiveCls);
        a.ignoreNextClick = Ext.defer(a.restoreClick, 250, a);
        a.fireEvent("menuhide", a, a.menu)
    },
    restoreClick: function() {
        this.ignoreNextClick = 0
    },
    onDownKey: function() {
        var a = this;
        if (!a.disabled) {
            if (a.menu) {
                a.showMenu()
            }
        }
    },
    getPersistentBtnPadding: function() {
        var a = Ext.button.Button,
        e = a.persistentPadding,
        c, b, d, f;
        if (!e) {
            e = a.persistentPadding = [0, 0, 0, 0];
            if (!Ext.isIE) {
                c = Ext.create("Ext.button.Button", {
                    renderTo: Ext.getBody(),
                    text: "test",
                    style: "position:absolute;top:-999px;"
                });
                d = c.btnEl;
                f = c.btnInnerEl;
                d.setSize(null, null);
                b = f.getOffsetsTo(d);
                e[0] = b[1];
                e[1] = d.getWidth() - f.getWidth() - b[0];
                e[2] = d.getHeight() - f.getHeight() - b[1];
                e[3] = b[0];
                c.destroy()
            }
        }
        return e
    }
},
function() {
    var a = {};
    function b(e, h) {
        var f, d, c;
        if (h) {
            f = a[e.toggleGroup];
            for (d = 0, c = f.length; d < c; d++) {
                if (f[d] !== e) {
                    f[d].toggle(false)
                }
            }
        }
    }
    Ext.ButtonToggleManager = {
        register: function(c) {
            if (!c.toggleGroup) {
                return
            }
            var d = a[c.toggleGroup];
            if (!d) {
                d = a[c.toggleGroup] = []
            }
            d.push(c);
            c.on("toggle", b)
        },
        unregister: function(c) {
            if (!c.toggleGroup) {
                return
            }
            var d = a[c.toggleGroup];
            if (d) {
                Ext.Array.remove(d, c);
                c.un("toggle", b)
            }
        },
        getPressed: function(f) {
            var e = a[f],
            d = 0,
            c;
            if (e) {
                for (c = e.length; d < c; d++) {
                    if (e[d].pressed === true) {
                        return e[d]
                    }
                }
            }
            return null
        }
    }
});
Ext.define("Ext.ProgressBar", {
    extend: "Ext.Component",
    alias: "widget.progressbar",
    requires: ["Ext.Template", "Ext.CompositeElement", "Ext.TaskManager", "Ext.layout.component.ProgressBar"],
    uses: ["Ext.fx.Anim"],
    baseCls: Ext.baseCSSPrefix + "progress",
    config: {
        animate: false,
        text: ""
    },
    waitTimer: null,
    renderTpl: ['<div class="{baseCls}-text {baseCls}-text-back">', "<div>&#160;</div>", "</div>", '<div id="{id}-bar" class="{baseCls}-bar">', '<div class="{baseCls}-text">', "<div>&#160;</div>", "</div>", "</div>"],
    componentLayout: "progressbar",
    initComponent: function() {
        this.callParent();
        this.addChildEls("bar");
        this.addEvents("update")
    },
    afterRender: function() {
        var a = this;
        a.textEl = a.textEl ? Ext.get(a.textEl) : a.el.select("." + a.baseCls + "-text");
        a.callParent(arguments);
        if (a.value) {
            a.updateProgress(a.value, a.text)
        } else {
            a.updateText(a.text)
        }
    },
    updateProgress: function(d, e, a) {
        var c = this,
        b;
        c.value = d || 0;
        if (e) {
            c.updateText(e)
        }
        if (c.rendered && !c.isDestroyed) {
            if (c.isVisible(true)) {
                b = Math.floor(c.value * c.el.getWidth(true));
                if (Ext.isForcedBorderBox) {
                    b += c.bar.getBorderWidth("lr")
                }
                if (a === true || (a !== false && c.animate)) {
                    c.bar.stopAnimation();
                    c.bar.animate(Ext.apply({
                        to: {
                            width: b + "px"
                        }
                    },
                    c.animate))
                } else {
                    c.bar.setWidth(b)
                }
            } else {
                c.doComponentLayout()
            }
        }
        c.fireEvent("update", c, c.value, e);
        return c
    },
    updateText: function(b) {
        var a = this;
        a.text = b;
        if (a.rendered) {
            a.textEl.update(a.text)
        }
        return a
    },
    applyText: function(a) {
        this.updateText(a)
    },
    wait: function(b) {
        var a = this;
        if (!a.waitTimer) {
            scope = a;
            b = b || {};
            a.updateText(b.text);
            a.waitTimer = Ext.TaskManager.start({
                run: function(c) {
                    var d = b.increment || 10;
                    c -= 1;
                    a.updateProgress(((((c + d) % d) + 1) * (100 / d)) * 0.01, null, b.animate)
                },
                interval: b.interval || 1000,
                duration: b.duration,
                onStop: function() {
                    if (b.fn) {
                        b.fn.apply(b.scope || a)
                    }
                    a.reset()
                },
                scope: scope
            })
        }
        return a
    },
    isWaiting: function() {
        return this.waitTimer !== null
    },
    reset: function(a) {
        var b = this;
        b.updateProgress(0);
        b.clearTimer();
        if (a === true) {
            b.hide()
        }
        return b
    },
    clearTimer: function() {
        var a = this;
        if (a.waitTimer) {
            a.waitTimer.onStop = null;
            Ext.TaskManager.stop(a.waitTimer);
            a.waitTimer = null
        }
    },
    onDestroy: function() {
        var a = this;
        a.clearTimer();
        if (a.rendered) {
            if (a.textEl.isComposite) {
                a.textEl.clear()
            }
            Ext.destroyMembers(a, "textEl", "progressBar")
        }
        a.callParent()
    }
});
Ext.define("Ext.form.field.Base", {
    extend: "Ext.Component",
    mixins: {
        labelable: "Ext.form.Labelable",
        field: "Ext.form.field.Field"
    },
    alias: "widget.field",
    alternateClassName: ["Ext.form.Field", "Ext.form.BaseField"],
    requires: ["Ext.util.DelayedTask", "Ext.XTemplate", "Ext.layout.component.field.Field"],
    fieldSubTpl: ['<input id="{id}" type="{type}" ', '<tpl if="name">name="{name}" </tpl>', '<tpl if="size">size="{size}" </tpl>', '<tpl if="tabIdx">tabIndex="{tabIdx}" </tpl>', 'class="{fieldCls} {typeCls}" autocomplete="off" />', {
        compiled: true,
        disableFormats: true
    }],
    inputType: "text",
    invalidText: "The value in this field is invalid",
    fieldCls: Ext.baseCSSPrefix + "form-field",
    focusCls: Ext.baseCSSPrefix + "form-focus",
    dirtyCls: Ext.baseCSSPrefix + "form-dirty",
    checkChangeEvents: Ext.isIE && (!document.documentMode || document.documentMode < 9) ? ["change", "propertychange"] : ["change", "input", "textInput", "keyup", "dragdrop"],
    checkChangeBuffer: 50,
    componentLayout: "field",
    readOnly: false,
    readOnlyCls: Ext.baseCSSPrefix + "form-readonly",
    validateOnBlur: true,
    hasFocus: false,
    baseCls: Ext.baseCSSPrefix + "field",
    maskOnDisable: false,
    initComponent: function() {
        var a = this;
        a.callParent();
        a.subTplData = a.subTplData || {};
        a.addEvents("focus", "blur", "specialkey");
        a.initLabelable();
        a.initField();
        if (!a.name) {
            a.name = a.getInputId()
        }
    },
    getInputId: function() {
        return this.inputId || (this.inputId = Ext.id())
    },
    getSubTplData: function() {
        var c = this,
        b = c.inputType,
        a = c.getInputId();
        return Ext.applyIf(c.subTplData, {
            id: a,
            cmpId: c.id,
            name: c.name || a,
            type: b,
            size: c.size || 20,
            cls: c.cls,
            fieldCls: c.fieldCls,
            tabIdx: c.tabIndex,
            typeCls: Ext.baseCSSPrefix + "form-" + (b === "password" ? "text": b)
        })
    },
    afterRender: function() {
        this.callParent();
        if (this.inputEl) {
            this.inputEl.selectable()
        }
    },
    getSubTplMarkup: function() {
        return this.getTpl("fieldSubTpl").apply(this.getSubTplData())
    },
    initRenderTpl: function() {
        var a = this;
        if (!a.hasOwnProperty("renderTpl")) {
            a.renderTpl = a.getTpl("labelableRenderTpl")
        }
        return a.callParent()
    },
    initRenderData: function() {
        return Ext.applyIf(this.callParent(), this.getLabelableRenderData())
    },
    setFieldStyle: function(a) {
        var b = this,
        c = b.inputEl;
        if (c) {
            c.applyStyles(a)
        }
        b.fieldStyle = a
    },
    onRender: function() {
        var b = this,
        a = b.fieldStyle;
        b.onLabelableRender();
        b.addChildEls({
            name: "inputEl",
            id: b.getInputId()
        });
        b.callParent(arguments);
        b.setRawValue(b.rawValue);
        if (b.readOnly) {
            b.setReadOnly(true)
        }
        if (b.disabled) {
            b.disable()
        }
        if (a) {
            b.setFieldStyle(a)
        }
        b.renderActiveError()
    },
    initAria: function() {
        var a = this;
        a.callParent();
        a.getActionEl().dom.setAttribute("aria-describedby", Ext.id(a.errorEl))
    },
    getFocusEl: function() {
        return this.inputEl
    },
    isFileUpload: function() {
        return this.inputType === "file"
    },
    extractFileInput: function() {
        var b = this,
        a = b.isFileUpload() ? b.inputEl.dom: null,
        c;
        if (a) {
            c = a.cloneNode(true);
            a.parentNode.replaceChild(c, a);
            b.inputEl = Ext.get(c)
        }
        return a
    },
    getSubmitData: function() {
        var a = this,
        b = null,
        c;
        if (!a.disabled && a.submitValue && !a.isFileUpload()) {
            c = a.getSubmitValue();
            if (c !== null) {
                b = {};
                b[a.getName()] = c
            }
        }
        return b
    },
    getSubmitValue: function() {
        return this.processRawValue(this.getRawValue())
    },
    getRawValue: function() {
        var b = this,
        a = (b.inputEl ? b.inputEl.getValue() : Ext.value(b.rawValue, ""));
        b.rawValue = a;
        return a
    },
    setRawValue: function(b) {
        var a = this;
        b = Ext.value(b, "");
        a.rawValue = b;
        if (a.inputEl) {
            a.inputEl.dom.value = b
        }
        return b
    },
    valueToRaw: function(a) {
        return "" + Ext.value(a, "")
    },
    rawToValue: function(a) {
        return a
    },
    processRawValue: function(a) {
        return a
    },
    getValue: function() {
        var a = this,
        b = a.rawToValue(a.processRawValue(a.getRawValue()));
        a.value = b;
        return b
    },
    setValue: function(b) {
        var a = this;
        a.setRawValue(a.valueToRaw(b));
        return a.mixins.field.setValue.call(a, b)
    },
    onDisable: function() {
        var a = this,
        b = a.inputEl;
        a.callParent();
        if (b) {
            b.dom.disabled = true
        }
    },
    onEnable: function() {
        var a = this,
        b = a.inputEl;
        a.callParent();
        if (b) {
            b.dom.disabled = false
        }
    },
    setReadOnly: function(c) {
        var a = this,
        b = a.inputEl;
        if (b) {
            b.dom.readOnly = c;
            b.dom.setAttribute("aria-readonly", c)
        }
        a[c ? "addCls": "removeCls"](a.readOnlyCls);
        a.readOnly = c
    },
    fireKey: function(a) {
        if (a.isSpecialKey()) {
            this.fireEvent("specialkey", this, Ext.create("Ext.EventObjectImpl", a))
        }
    },
    initEvents: function() {
        var b = this,
        c = b.inputEl,
        a, d;
        if (c) {
            b.mon(c, Ext.EventManager.getKeyEvent(), b.fireKey, b);
            b.mon(c, "focus", b.onFocus, b);
            b.mon(c, "blur", b.onBlur, b, b.inEditor ? {
                buffer: 10
            }: null);
            a = Ext.create("Ext.util.DelayedTask", b.checkChange, b);
            b.onChangeEvent = d = function() {
                a.delay(b.checkChangeBuffer)
            };
            Ext.each(b.checkChangeEvents,
            function(e) {
                if (e === "propertychange") {
                    b.usesPropertychange = true
                }
                b.mon(c, e, d)
            },
            b)
        }
        b.callParent()
    },
    doComponentLayout: function() {
        var c = this,
        d = c.inputEl,
        a = c.usesPropertychange,
        b = "propertychange",
        e = c.onChangeEvent;
        if (a) {
            c.mun(d, b, e)
        }
        c.callParent(arguments);
        if (a) {
            c.mon(d, b, e)
        }
    },
    preFocus: Ext.emptyFn,
    onFocus: function() {
        var b = this,
        a = b.focusCls,
        c = b.inputEl;
        b.preFocus();
        if (a && c) {
            c.addCls(a)
        }
        if (!b.hasFocus) {
            b.hasFocus = true;
            b.componentLayout.onFocus();
            b.fireEvent("focus", b)
        }
    },
    beforeBlur: Ext.emptyFn,
    onBlur: function() {
        var b = this,
        a = b.focusCls,
        c = b.inputEl;
        if (b.destroying) {
            return
        }
        b.beforeBlur();
        if (a && c) {
            c.removeCls(a)
        }
        if (b.validateOnBlur) {
            b.validate()
        }
        b.hasFocus = false;
        b.fireEvent("blur", b);
        b.postBlur()
    },
    postBlur: Ext.emptyFn,
    onDirtyChange: function(a) {
        this[a ? "addCls": "removeCls"](this.dirtyCls)
    },
    isValid: function() {
        var a = this;
        return a.disabled || a.validateValue(a.processRawValue(a.getRawValue()))
    },
    validateValue: function(b) {
        var a = this,
        d = a.getErrors(b),
        c = Ext.isEmpty(d);
        if (!a.preventMark) {
            if (c) {
                a.clearInvalid()
            } else {
                a.markInvalid(d)
            }
        }
        return c
    },
    markInvalid: function(c) {
        var b = this,
        a = b.getActiveError();
        b.setActiveErrors(Ext.Array.from(c));
        if (a !== b.getActiveError()) {
            b.doComponentLayout()
        }
    },
    clearInvalid: function() {
        var b = this,
        a = b.hasActiveError();
        b.unsetActiveError();
        if (a) {
            b.doComponentLayout()
        }
    },
    renderActiveError: function() {
        var b = this,
        a = b.hasActiveError();
        if (b.inputEl) {
            b.inputEl[a ? "addCls": "removeCls"](b.invalidCls + "-field")
        }
        b.mixins.labelable.renderActiveError.call(b)
    },
    getActionEl: function() {
        return this.inputEl || this.el
    }
});
Ext.define("Ext.form.field.Text", {
    extend: "Ext.form.field.Base",
    alias: "widget.textfield",
    requires: ["Ext.form.field.VTypes", "Ext.layout.component.field.Text"],
    alternateClassName: ["Ext.form.TextField", "Ext.form.Text"],
    size: 20,
    growMin: 30,
    growMax: 800,
    growAppend: "W",
    allowBlank: true,
    minLength: 0,
    maxLength: Number.MAX_VALUE,
    minLengthText: "The minimum length for this field is {0}",
    maxLengthText: "The maximum length for this field is {0}",
    blankText: "This field is required",
    regexText: "",
    emptyCls: Ext.baseCSSPrefix + "form-empty-field",
    ariaRole: "textbox",
    componentLayout: "textfield",
    initComponent: function() {
        this.callParent();
        this.addEvents("autosize", "keydown", "keyup", "keypress")
    },
    initEvents: function() {
        var b = this,
        a = b.inputEl;
        b.callParent();
        if (b.selectOnFocus || b.emptyText) {
            b.mon(a, "mousedown", b.onMouseDown, b)
        }
        if (b.maskRe || (b.vtype && b.disableKeyFilter !== true && (b.maskRe = Ext.form.field.VTypes[b.vtype + "Mask"]))) {
            b.mon(a, "keypress", b.filterKeys, b)
        }
        if (b.enableKeyEvents) {
            b.mon(a, {
                scope: b,
                keyup: b.onKeyUp,
                keydown: b.onKeyDown,
                keypress: b.onKeyPress
            })
        }
    },
    isEqual: function(b, a) {
        return this.isEqualAsString(b, a)
    },
    onChange: function() {
        this.callParent();
        this.autoSize()
    },
    afterRender: function() {
        var a = this;
        if (a.enforceMaxLength) {
            a.inputEl.dom.maxLength = a.maxLength
        }
        a.applyEmptyText();
        a.autoSize();
        a.callParent()
    },
    onMouseDown: function(b) {
        var a = this;
        if (!a.hasFocus) {
            a.mon(a.inputEl, "mouseup", Ext.emptyFn, a, {
                single: true,
                preventDefault: true
            })
        }
    },
    processRawValue: function(b) {
        var a = this,
        d = a.stripCharsRe,
        c;
        if (d) {
            c = b.replace(d, "");
            if (c !== b) {
                a.setRawValue(c);
                b = c
            }
        }
        return b
    },
    onDisable: function() {
        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = "on"
        }
    },
    onEnable: function() {
        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = ""
        }
    },
    onKeyDown: function(a) {
        this.fireEvent("keydown", this, a)
    },
    onKeyUp: function(a) {
        this.fireEvent("keyup", this, a)
    },
    onKeyPress: function(a) {
        this.fireEvent("keypress", this, a)
    },
    reset: function() {
        this.callParent();
        this.applyEmptyText()
    },
    applyEmptyText: function() {
        var b = this,
        a = b.emptyText,
        c;
        if (b.rendered && a) {
            c = b.getRawValue().length < 1 && !b.hasFocus;
            if (Ext.supports.Placeholder) {
                b.inputEl.dom.placeholder = a
            } else {
                if (c) {
                    b.setRawValue(a)
                }
            }
            if (c) {
                b.inputEl.addCls(b.emptyCls)
            }
            b.autoSize()
        }
    },
    preFocus: function() {
        var b = this,
        c = b.inputEl,
        a = b.emptyText,
        d;
        if (a && !Ext.supports.Placeholder && c.dom.value === a) {
            b.setRawValue("");
            d = true;
            c.removeCls(b.emptyCls)
        } else {
            if (Ext.supports.Placeholder) {
                b.inputEl.removeCls(b.emptyCls)
            }
        }
        if (b.selectOnFocus || d) {
            c.dom.select()
        }
    },
    onFocus: function() {
        var a = this;
        a.callParent(arguments);
        if (a.emptyText) {
            a.autoSize()
        }
    },
    postBlur: function() {
        this.applyEmptyText()
    },
    filterKeys: function(c) {
        if (c.ctrlKey && !c.altKey) {
            return
        }
        var b = c.getKey(),
        a = String.fromCharCode(c.getCharCode());
        if (Ext.isGecko && (c.isNavKeyPress() || b === c.BACKSPACE || (b === c.DELETE && c.button === -1))) {
            return
        }
        if (!Ext.isGecko && c.isSpecialKey() && !a) {
            return
        }
        if (!this.maskRe.test(a)) {
            c.stopEvent()
        }
    },
    getRawValue: function() {
        var b = this,
        a = b.callParent();
        if (a === b.emptyText) {
            a = ""
        }
        return a
    },
    setValue: function(b) {
        var a = this,
        c = a.inputEl;
        if (c && a.emptyText && !Ext.isEmpty(b)) {
            c.removeCls(a.emptyCls)
        }
        a.callParent(arguments);
        a.applyEmptyText();
        return a
    },
    getErrors: function(l) {
        var f = this,
        k = f.callParent(arguments),
        a = f.validator,
        d = f.emptyText,
        c = f.allowBlank,
        e = f.vtype,
        g = Ext.form.field.VTypes,
        h = f.regex,
        j = Ext.String.format,
        b;
        l = l || f.processRawValue(f.getRawValue());
        if (Ext.isFunction(a)) {
            b = a.call(f, l);
            if (b !== true) {
                k.push(b)
            }
        }
        if (l.length < 1 || l === d) {
            if (!c) {
                k.push(f.blankText)
            }
            return k
        }
        if (l.length < f.minLength) {
            k.push(j(f.minLengthText, f.minLength))
        }
        if (l.length > f.maxLength) {
            k.push(j(f.maxLengthText, f.maxLength))
        }
        if (e) {
            if (!g[e](l, f)) {
                k.push(f.vtypeText || g[e + "Text"])
            }
        }
        if (h && !h.test(l)) {
            k.push(f.regexText || f.invalidText)
        }
        return k
    },
    selectText: function(h, a) {
        var g = this,
        c = g.getRawValue(),
        d = true,
        f = g.inputEl.dom,
        e,
        b;
        if (c.length > 0) {
            h = h === e ? 0 : h;
            a = a === e ? c.length: a;
            if (f.setSelectionRange) {
                f.setSelectionRange(h, a)
            } else {
                if (f.createTextRange) {
                    b = f.createTextRange();
                    b.moveStart("character", h);
                    b.moveEnd("character", a - c.length);
                    b.select()
                }
            }
            d = Ext.isGecko || Ext.isOpera
        }
        if (d) {
            g.focus()
        }
    },
    autoSize: function() {
        var b = this,
        a;
        if (b.grow && b.rendered) {
            b.doComponentLayout();
            a = b.inputEl.getWidth();
            if (a !== b.lastInputWidth) {
                b.fireEvent("autosize", a);
                b.lastInputWidth = a
            }
        }
    },
    initAria: function() {
        this.callParent();
        this.getActionEl().dom.setAttribute("aria-required", this.allowBlank === false)
    },
    getBodyNaturalWidth: function() {
        return Math.round(this.size * 6.5) + 20
    }
});
Ext.define("Ext.form.field.TextArea", {
    extend: "Ext.form.field.Text",
    alias: ["widget.textareafield", "widget.textarea"],
    alternateClassName: "Ext.form.TextArea",
    requires: ["Ext.XTemplate", "Ext.layout.component.field.TextArea"],
    fieldSubTpl: ['<textarea id="{id}" ', '<tpl if="name">name="{name}" </tpl>', '<tpl if="rows">rows="{rows}" </tpl>', '<tpl if="cols">cols="{cols}" </tpl>', '<tpl if="tabIdx">tabIndex="{tabIdx}" </tpl>', 'class="{fieldCls} {typeCls}" ', 'autocomplete="off">', "</textarea>", {
        compiled: true,
        disableFormats: true
    }],
    growMin: 60,
    growMax: 1000,
    growAppend: "\n-",
    cols: 20,
    rows: 4,
    enterIsSpecial: false,
    preventScrollbars: false,
    componentLayout: "textareafield",
    onRender: function(b, a) {
        var c = this;
        Ext.applyIf(c.subTplData, {
            cols: c.cols,
            rows: c.rows
        });
        c.callParent(arguments)
    },
    afterRender: function() {
        var a = this;
        a.callParent(arguments);
        if (a.grow) {
            if (a.preventScrollbars) {
                a.inputEl.setStyle("overflow", "hidden")
            }
            a.inputEl.setHeight(a.growMin)
        }
    },
    fireKey: function(a) {
        if (a.isSpecialKey() && (this.enterIsSpecial || (a.getKey() !== a.ENTER || a.hasModifier()))) {
            this.fireEvent("specialkey", this, a)
        }
    },
    autoSize: function() {
        var b = this,
        a;
        if (b.grow && b.rendered) {
            b.doComponentLayout();
            a = b.inputEl.getHeight();
            if (a !== b.lastInputHeight) {
                b.fireEvent("autosize", a);
                b.lastInputHeight = a
            }
        }
    },
    initAria: function() {
        this.callParent(arguments);
        this.getActionEl().dom.setAttribute("aria-multiline", true)
    },
    getBodyNaturalWidth: function() {
        return Math.round(this.cols * 6.5) + 20
    }
});
Ext.define("Ext.toolbar.Fill", {
    extend: "Ext.Component",
    alias: "widget.tbfill",
    alternateClassName: "Ext.Toolbar.Fill",
    isFill: true,
    flex: 1
});
Ext.define("Ext.container.AbstractContainer", {
    extend: "Ext.Component",
    requires: ["Ext.util.MixedCollection", "Ext.layout.container.Auto", "Ext.ZIndexManager"],
    suspendLayout: false,
    autoDestroy: true,
    defaultType: "panel",
    isContainer: true,
    layoutCounter: 0,
    baseCls: Ext.baseCSSPrefix + "container",
    bubbleEvents: ["add", "remove"],
    initComponent: function() {
        var a = this;
        a.addEvents("afterlayout", "beforeadd", "beforeremove", "add", "remove");
        a.layoutOnShow = Ext.create("Ext.util.MixedCollection");
        a.callParent();
        a.initItems()
    },
    initItems: function() {
        var b = this,
        a = b.items;
        b.items = Ext.create("Ext.util.MixedCollection", false, b.getComponentId);
        if (a) {
            if (!Ext.isArray(a)) {
                a = [a]
            }
            b.add(a)
        }
    },
    afterRender: function() {
        this.getLayout();
        this.callParent()
    },
    renderChildren: function() {
        var b = this,
        a = b.getLayout();
        b.callParent();
        if (a) {
            b.suspendLayout = true;
            a.renderChildren();
            delete b.suspendLayout
        }
    },
    setLayout: function(b) {
        var a = this.layout;
        if (a && a.isLayout && a != b) {
            a.setOwner(null)
        }
        this.layout = b;
        b.setOwner(this)
    },
    getLayout: function() {
        var a = this;
        if (!a.layout || !a.layout.isLayout) {
            a.setLayout(Ext.layout.Layout.create(a.layout, "autocontainer"))
        }
        return a.layout
    },
    doLayout: function() {
        var b = this,
        a = b.getLayout();
        if (b.rendered && a && !b.suspendLayout) {
            if (!b.isFixedWidth() || !b.isFixedHeight()) {
                if (b.componentLayout.layoutBusy !== true) {
                    b.doComponentLayout();
                    if (b.componentLayout.layoutCancelled === true) {
                        a.layout()
                    }
                }
            } else {
                if (a.layoutBusy !== true) {
                    a.layout()
                }
            }
        }
        return b
    },
    afterLayout: function(a) {++this.layoutCounter;
        this.fireEvent("afterlayout", this, a)
    },
    prepareItems: function(b, d) {
        if (!Ext.isArray(b)) {
            b = [b]
        }
        var c = 0,
        a = b.length,
        e;
        for (; c < a; c++) {
            e = b[c];
            if (d) {
                e = this.applyDefaults(e)
            }
            b[c] = this.lookupComponent(e)
        }
        return b
    },
    applyDefaults: function(a) {
        var b = this.defaults;
        if (b) {
            if (Ext.isFunction(b)) {
                b = b.call(this, a)
            }
            if (Ext.isString(a)) {
                a = Ext.ComponentManager.get(a)
            }
            Ext.applyIf(a, b)
        }
        return a
    },
    lookupComponent: function(a) {
        return Ext.isString(a) ? Ext.ComponentManager.get(a) : this.createComponent(a)
    },
    createComponent: function(a, b) {
        return Ext.ComponentManager.create(a, b || this.defaultType)
    },
    getComponentId: function(a) {
        return a.getItemId()
    },
    add: function() {
        var h = this,
        f = Array.prototype.slice.call(arguments),
        a,
        g,
        b = [],
        c,
        e,
        k,
        d = -1,
        j;
        if (typeof f[0] == "number") {
            d = f.shift()
        }
        a = f.length > 1;
        if (a || Ext.isArray(f[0])) {
            g = a ? f: f[0];
            h.suspendLayout = true;
            for (c = 0, e = g.length; c < e; c++) {
                k = g[c];
                if (!k) {
                    Ext.Error.raise("Trying to add a null item as a child of Container with itemId/id: " + h.getItemId())
                }
                if (d != -1) {
                    k = h.add(d + c, k)
                } else {
                    k = h.add(k)
                }
                b.push(k)
            }
            h.suspendLayout = false;
            h.doLayout();
            return b
        }
        j = h.prepareItems(f[0], true)[0];
        if (j.floating) {
            j.onAdded(h, d)
        } else {
            d = (d !== -1) ? d: h.items.length;
            if (h.fireEvent("beforeadd", h, j, d) !== false && h.onBeforeAdd(j) !== false) {
                h.items.insert(d, j);
                j.onAdded(h, d);
                h.onAdd(j, d);
                h.fireEvent("add", h, j, d)
            }
            h.doLayout()
        }
        return j
    },
    onAdd: Ext.emptyFn,
    onRemove: Ext.emptyFn,
    insert: function(b, a) {
        return this.add(b, a)
    },
    move: function(b, d) {
        var a = this.items,
        c;
        c = a.removeAt(b);
        if (c === false) {
            return false
        }
        a.insert(d, c);
        this.doLayout();
        return c
    },
    onBeforeAdd: function(b) {
        var a = this;
        if (b.ownerCt) {
            b.ownerCt.remove(b, false)
        }
        if (a.border === false || a.border === 0) {
            b.border = (b.border === true)
        }
    },
    remove: function(a, b) {
        var d = this,
        e = d.getComponent(a);
        if (Ext.isDefined(Ext.global.console) && !e) {
            console.warn("Attempted to remove a component that does not exist. Ext.container.Container: remove takes an argument of the component to remove. cmp.remove() is incorrect usage.")
        }
        if (e && d.fireEvent("beforeremove", d, e) !== false) {
            d.doRemove(e, b);
            d.fireEvent("remove", d, e)
        }
        return e
    },
    doRemove: function(c, b) {
        var e = this,
        d = e.layout,
        a = d && e.rendered;
        e.items.remove(c);
        c.onRemoved();
        if (a) {
            d.onRemove(c)
        }
        e.onRemove(c, b);
        if (b === true || (b !== false && e.autoDestroy)) {
            c.destroy()
        }
        if (a && !b) {
            d.afterRemove(c)
        }
        if (!e.destroying) {
            e.doLayout()
        }
    },
    removeAll: function(c) {
        var g = this,
        e = g.items.items.slice(),
        b = [],
        d = 0,
        a = e.length,
        f;
        g.suspendLayout = true;
        for (; d < a; d++) {
            f = e[d];
            g.remove(f, c);
            if (f.ownerCt !== g) {
                b.push(f)
            }
        }
        g.suspendLayout = false;
        if (a) {
            g.doLayout()
        }
        return b
    },
    getRefItems: function(c) {
        var g = this,
        d = g.items.items,
        b = d.length,
        e = 0,
        f, a = [];
        for (; e < b; e++) {
            f = d[e];
            a.push(f);
            if (c && f.getRefItems) {
                a.push.apply(a, f.getRefItems(true))
            }
        }
        if (g.floatingItems && g.floatingItems.accessList) {
            a.push.apply(a, g.floatingItems.accessList)
        }
        return a
    },
    cascade: function(k, l, a) {
        var j = this,
        e = j.items ? j.items.items: [],
        f = e.length,
        d = 0,
        h,
        g = a ? a.concat(j) : [j],
        b = g.length - 1;
        if (k.apply(l || j, g) !== false) {
            for (; d < f; d++) {
                h = e[d];
                if (h.cascade) {
                    h.cascade(k, l, a)
                } else {
                    g[b] = h;
                    k.apply(l || e, g)
                }
            }
        }
        return this
    },
    getComponent: function(a) {
        if (Ext.isObject(a)) {
            a = a.getItemId()
        }
        return this.items.get(a)
    },
    query: function(a) {
        a = a || "*";
        return Ext.ComponentQuery.query(a, this)
    },
    child: function(a) {
        a = a || "";
        return this.query("> " + a)[0] || null
    },
    down: function(a) {
        return this.query(a)[0] || null
    },
    show: function() {
        this.callParent(arguments);
        this.performDeferredLayouts();
        return this
    },
    performDeferredLayouts: function() {
        var e = this.layoutOnShow,
        d = e.getCount(),
        b = 0,
        a,
        c;
        for (; b < d; b++) {
            c = e.get(b);
            a = c.needsLayout;
            if (Ext.isObject(a)) {
                c.doComponentLayout(a.width, a.height, a.isSetSize, a.ownerCt)
            }
        }
        e.clear()
    },
    onEnable: function() {
        Ext.Array.each(this.query("[isFormField]"),
        function(a) {
            if (a.resetDisable) {
                a.enable();
                delete a.resetDisable
            }
        });
        this.callParent()
    },
    onDisable: function() {
        Ext.Array.each(this.query("[isFormField]"),
        function(a) {
            if (a.resetDisable !== false && !a.disabled) {
                a.disable();
                a.resetDisable = true
            }
        });
        this.callParent()
    },
    beforeLayout: function() {
        return true
    },
    beforeDestroy: function() {
        var b = this,
        a = b.items,
        d;
        if (a) {
            while ((d = a.first())) {
                b.doRemove(d, true)
            }
        }
        Ext.destroy(b.layout);
        b.callParent()
    }
});
Ext.define("Ext.container.Container", {
    extend: "Ext.container.AbstractContainer",
    alias: "widget.container",
    alternateClassName: "Ext.Container",
    getChildByElement: function(d) {
        var f, b, a = 0,
        c = this.items.items,
        e = c.length;
        d = Ext.getDom(d);
        for (; a < e; a++) {
            f = c[a];
            b = f.getEl();
            if ((b.dom === d) || b.contains(d)) {
                return f
            }
        }
        return null
    }
});
Ext.define("Ext.panel.Header", {
    extend: "Ext.container.Container",
    uses: ["Ext.panel.Tool", "Ext.draw.Component", "Ext.util.CSS"],
    alias: "widget.header",
    isHeader: true,
    defaultType: "tool",
    indicateDrag: false,
    weight: -1,
    renderTpl: ['<div id="{id}-body" class="{baseCls}-body<tpl if="bodyCls"> {bodyCls}</tpl>', '<tpl if="uiCls">', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>', '</tpl>"', '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>></div>'],
    initComponent: function() {
        var c = this,
        f, e, b, a, d;
        c.indicateDragCls = c.baseCls + "-draggable";
        c.title = c.title || "&#160;";
        c.tools = c.tools || [];
        c.items = c.items || [];
        c.orientation = c.orientation || "horizontal";
        c.dock = (c.dock) ? c.dock: (c.orientation == "horizontal") ? "top": "left";
        c.addClsWithUI(c.orientation);
        c.addClsWithUI(c.dock);
        c.addChildEls("body");
        if (!Ext.isEmpty(c.iconCls)) {
            c.initIconCmp();
            c.items.push(c.iconCmp)
        }
        if (c.orientation == "vertical") {
            if (Ext.isIE6 || Ext.isIE7) {
                c.width = this.width || 24
            } else {
                if (Ext.isIEQuirks) {
                    c.width = this.width || 25
                }
            }
            c.layout = {
                type: "vbox",
                align: "center",
                clearInnerCtOnLayout: true,
                bindToOwnerCtContainer: false
            };
            c.textConfig = {
                cls: c.baseCls + "-text",
                type: "text",
                text: c.title,
                rotate: {
                    degrees: 90
                }
            };
            d = c.ui;
            if (Ext.isArray(d)) {
                d = d[0]
            }
            f = "." + c.baseCls + "-text-" + d;
            if (Ext.scopeResetCSS) {
                f = "." + Ext.baseCSSPrefix + "reset " + f
            }
            e = Ext.util.CSS.getRule(f);
            if (e) {
                b = e.style
            }
            if (b) {
                Ext.apply(c.textConfig, {
                    "font-family": b.fontFamily,
                    "font-weight": b.fontWeight,
                    "font-size": b.fontSize,
                    fill: b.color
                })
            }
            c.titleCmp = Ext.create("Ext.draw.Component", {
                ariaRole: "heading",
                focusable: false,
                viewBox: false,
                flex: 1,
                autoSize: true,
                margins: "5 0 0 0",
                items: [c.textConfig],
                renderSelectors: {
                    textEl: "." + c.baseCls + "-text"
                }
            })
        } else {
            c.layout = {
                type: "hbox",
                align: "middle",
                clearInnerCtOnLayout: true,
                bindToOwnerCtContainer: false
            };
            c.titleCmp = Ext.create("Ext.Component", {
                xtype: "component",
                ariaRole: "heading",
                focusable: false,
                flex: 1,
                cls: c.baseCls + "-text-container",
                renderTpl: ['<span id="{id}-textEl" class="{cls}-text {cls}-text-{ui}">{title}</span>'],
                renderData: {
                    title: c.title,
                    cls: c.baseCls,
                    ui: c.ui
                },
                childEls: ["textEl"]
            })
        }
        c.items.push(c.titleCmp);
        c.items = c.items.concat(c.tools);
        this.callParent()
    },
    initIconCmp: function() {
        this.iconCmp = Ext.create("Ext.Component", {
            focusable: false,
            renderTpl: ['<img id="{id}-iconEl" alt="" src="{blank}" class="{cls}-icon {iconCls}"/>'],
            renderData: {
                blank: Ext.BLANK_IMAGE_URL,
                cls: this.baseCls,
                iconCls: this.iconCls,
                orientation: this.orientation
            },
            childEls: ["iconEl"],
            iconCls: this.iconCls
        })
    },
    afterRender: function() {
        var a = this;
        a.el.unselectable();
        if (a.indicateDrag) {
            a.el.addCls(a.indicateDragCls)
        }
        a.mon(a.el, {
            click: a.onClick,
            scope: a
        });
        a.callParent()
    },
    afterLayout: function() {
        var a = this;
        a.callParent(arguments);
        if (Ext.isIE7) {
            a.el.repaint()
        }
    },
    addUIClsToElement: function(b, f) {
        var e = this,
        a = e.callParent(arguments),
        d = [e.baseCls + "-body-" + b, e.baseCls + "-body-" + e.ui + "-" + b],
        g,
        c;
        if (!f && e.rendered) {
            if (e.bodyCls) {
                e.body.addCls(e.bodyCls)
            } else {
                e.body.addCls(d)
            }
        } else {
            if (e.bodyCls) {
                g = e.bodyCls.split(" ");
                for (c = 0; c < d.length; c++) {
                    if (!Ext.Array.contains(g, d[c])) {
                        g.push(d[c])
                    }
                }
                e.bodyCls = g.join(" ")
            } else {
                e.bodyCls = d.join(" ")
            }
        }
        return a
    },
    removeUIClsFromElement: function(b, f) {
        var e = this,
        a = e.callParent(arguments),
        d = [e.baseCls + "-body-" + b, e.baseCls + "-body-" + e.ui + "-" + b],
        g,
        c;
        if (!f && e.rendered) {
            if (e.bodyCls) {
                e.body.removeCls(e.bodyCls)
            } else {
                e.body.removeCls(d)
            }
        } else {
            if (e.bodyCls) {
                g = e.bodyCls.split(" ");
                for (c = 0; c < d.length; c++) {
                    Ext.Array.remove(g, d[c])
                }
                e.bodyCls = g.join(" ")
            }
        }
        return a
    },
    addUIToElement: function(c) {
        var b = this,
        d, a;
        b.callParent(arguments);
        a = b.baseCls + "-body-" + b.ui;
        if (!c && b.rendered) {
            if (b.bodyCls) {
                b.body.addCls(b.bodyCls)
            } else {
                b.body.addCls(a)
            }
        } else {
            if (b.bodyCls) {
                d = b.bodyCls.split(" ");
                if (!Ext.Array.contains(d, a)) {
                    d.push(a)
                }
                b.bodyCls = d.join(" ")
            } else {
                b.bodyCls = a
            }
        }
        if (!c && b.titleCmp && b.titleCmp.rendered && b.titleCmp.textEl) {
            b.titleCmp.textEl.addCls(b.baseCls + "-text-" + b.ui)
        }
    },
    removeUIFromElement: function() {
        var b = this,
        c, a;
        b.callParent(arguments);
        a = b.baseCls + "-body-" + b.ui;
        if (b.rendered) {
            if (b.bodyCls) {
                b.body.removeCls(b.bodyCls)
            } else {
                b.body.removeCls(a)
            }
        } else {
            if (b.bodyCls) {
                c = b.bodyCls.split(" ");
                Ext.Array.remove(c, a);
                b.bodyCls = c.join(" ")
            } else {
                b.bodyCls = a
            }
        }
        if (b.titleCmp && b.titleCmp.rendered && b.titleCmp.textEl) {
            b.titleCmp.textEl.removeCls(b.baseCls + "-text-" + b.ui)
        }
    },
    onClick: function(a) {
        if (!a.getTarget(Ext.baseCSSPrefix + "tool")) {
            this.fireEvent("click", a)
        }
    },
    getTargetEl: function() {
        return this.body || this.frameBody || this.el
    },
    setTitle: function(d) {
        var c = this;
        if (c.rendered) {
            if (c.titleCmp.rendered) {
                if (c.titleCmp.surface) {
                    c.title = d || "";
                    var b = c.titleCmp.surface.items.items[0],
                    a = c.titleCmp.surface;
                    a.remove(b);
                    c.textConfig.type = "text";
                    c.textConfig.text = d;
                    b = a.add(c.textConfig);
                    b.setAttributes({
                        rotate: {
                            degrees: 90
                        }
                    },
                    true);
                    c.titleCmp.autoSizeSurface()
                } else {
                    c.title = d || "&#160;";
                    c.titleCmp.textEl.update(c.title)
                }
            } else {
                c.titleCmp.on({
                    render: function() {
                        c.setTitle(d)
                    },
                    single: true
                })
            }
        } else {
            c.on({
                render: function() {
                    c.layout.layout();
                    c.setTitle(d)
                },
                single: true
            })
        }
    },
    setIconCls: function(a) {
        var c = this,
        e = !a || !a.length,
        d = c.iconCmp,
        b;
        c.iconCls = a;
        if (!c.iconCmp && !e) {
            c.initIconCmp();
            c.insert(0, c.iconCmp)
        } else {
            if (d) {
                if (e) {
                    c.iconCmp.destroy()
                } else {
                    b = d.iconEl;
                    b.removeCls(d.iconCls);
                    b.addCls(a);
                    d.iconCls = a
                }
            }
        }
    },
    addTool: function(a) {
        this.tools.push(this.add(a))
    },
    onAdd: function(b, a) {
        this.callParent([arguments]);
        if (b instanceof Ext.panel.Tool) {
            b.bindTo(this.ownerCt);
            this.tools[b.type] = b
        }
    }
});
Ext.define("Ext.toolbar.Item", {
    extend: "Ext.Component",
    alias: "widget.tbitem",
    alternateClassName: "Ext.Toolbar.Item",
    enable: Ext.emptyFn,
    disable: Ext.emptyFn,
    focus: Ext.emptyFn
});
Ext.define("Ext.toolbar.Separator", {
    extend: "Ext.toolbar.Item",
    alias: "widget.tbseparator",
    alternateClassName: "Ext.Toolbar.Separator",
    baseCls: Ext.baseCSSPrefix + "toolbar-separator",
    focusable: false
});
Ext.define("Ext.layout.container.boxOverflow.Menu", {
    extend: "Ext.layout.container.boxOverflow.None",
    requires: ["Ext.toolbar.Separator", "Ext.button.Button"],
    alternateClassName: "Ext.layout.boxOverflow.Menu",
    noItemsMenuText: '<div class="' + Ext.baseCSSPrefix + 'toolbar-no-items">(None)</div>',
    constructor: function(b) {
        var a = this;
        a.callParent(arguments);
        b.beforeLayout = Ext.Function.createInterceptor(b.beforeLayout, this.clearOverflow, this);
        a.afterCtCls = a.afterCtCls || Ext.baseCSSPrefix + "box-menu-" + b.parallelAfter;
        a.menuItems = []
    },
    onRemove: function(a) {
        Ext.Array.remove(this.menuItems, a)
    },
    handleOverflow: function(a, g) {
        var f = this,
        e = f.layout,
        c = "get" + e.parallelPrefixCap,
        b = {},
        d = [null, null];
        f.callParent(arguments);
        this.createMenu(a, g);
        b[e.perpendicularPrefix] = g[e.perpendicularPrefix];
        b[e.parallelPrefix] = g[e.parallelPrefix] - f.afterCt[c]();
        d[e.perpendicularSizeIndex] = (a.meta.maxSize - f.menuTrigger["get" + e.perpendicularPrefixCap]()) / 2;
        f.menuTrigger.setPosition.apply(f.menuTrigger, d);
        return {
            targetSize: b
        }
    },
    clearOverflow: function(a, h) {
        var g = this,
        f = h ? h.width + (g.afterCt ? g.afterCt.getWidth() : 0) : 0,
        b = g.menuItems,
        c = 0,
        e = b.length,
        d;
        g.hideTrigger();
        for (; c < e; c++) {
            b[c].show()
        }
        b.length = 0;
        return h ? {
            targetSize: {
                height: h.height,
                width: f
            }
        }: null
    },
    showTrigger: function() {
        this.menuTrigger.show()
    },
    hideTrigger: function() {
        if (this.menuTrigger !== undefined) {
            this.menuTrigger.hide()
        }
    },
    beforeMenuShow: function(h) {
        var g = this,
        b = g.menuItems,
        d = 0,
        a = b.length,
        f, e;
        var c = function(k, j) {
            return k.isXType("buttongroup") && !(j instanceof Ext.toolbar.Separator)
        };
        g.clearMenu();
        h.removeAll();
        for (; d < a; d++) {
            f = b[d];
            if (!d && (f instanceof Ext.toolbar.Separator)) {
                continue
            }
            if (e && (c(f, e) || c(e, f))) {
                h.add("-")
            }
            g.addComponentToMenu(h, f);
            e = f
        }
        if (h.items.length < 1) {
            h.add(g.noItemsMenuText)
        }
    },
    createMenuConfig: function(c, a) {
        var b = Ext.apply({},
        c.initialConfig),
        d = c.toggleGroup;
        Ext.copyTo(b, c, ["iconCls", "icon", "itemId", "disabled", "handler", "scope", "menu"]);
        Ext.apply(b, {
            text: c.overflowText || c.text,
            hideOnClick: a,
            destroyMenu: false
        });
        if (d || c.enableToggle) {
            Ext.apply(b, {
                group: d,
                checked: c.pressed,
                listeners: {
                    checkchange: function(f, e) {
                        c.toggle(e)
                    }
                }
            })
        }
        delete b.ownerCt;
        delete b.xtype;
        delete b.id;
        return b
    },
    addComponentToMenu: function(c, a) {
        var b = this;
        if (a instanceof Ext.toolbar.Separator) {
            c.add("-")
        } else {
            if (a.isComponent) {
                if (a.isXType("splitbutton")) {
                    c.add(b.createMenuConfig(a, true))
                } else {
                    if (a.isXType("button")) {
                        c.add(b.createMenuConfig(a, !a.menu))
                    } else {
                        if (a.isXType("buttongroup")) {
                            a.items.each(function(d) {
                                b.addComponentToMenu(c, d)
                            })
                        } else {
                            c.add(Ext.create(Ext.getClassName(a), b.createMenuConfig(a)))
                        }
                    }
                }
            }
        }
    },
    clearMenu: function() {
        var a = this.moreMenu;
        if (a && a.items) {
            a.items.each(function(b) {
                if (b.menu) {
                    delete b.menu
                }
            })
        }
    },
    createMenu: function(a, c) {
        var k = this,
        h = k.layout,
        l = h.parallelBefore,
        e = h.parallelPrefix,
        b = c[e],
        g = a.boxes,
        d = 0,
        j = g.length,
        f;
        if (!k.menuTrigger) {
            k.createInnerElements();
            k.menu = Ext.create("Ext.menu.Menu", {
                listeners: {
                    scope: k,
                    beforeshow: k.beforeMenuShow
                }
            });
            k.menuTrigger = Ext.create("Ext.button.Button", {
                ownerCt: k.layout.owner,
                iconCls: k.layout.owner.menuTriggerCls,
                ui: h.owner instanceof Ext.toolbar.Toolbar ? "default-toolbar": "default",
                menu: k.menu,
                getSplitCls: function() {
                    return ""
                },
                renderTo: k.afterCt
            })
        }
        k.showTrigger();
        b -= k.afterCt.getWidth();
        k.menuItems.length = 0;
        for (; d < j; d++) {
            f = g[d];
            if (f[l] + f[e] > b) {
                k.menuItems.push(f.component);
                f.component.hide()
            }
        }
    },
    createInnerElements: function() {
        var a = this,
        b = a.layout.getRenderTarget();
        if (!this.afterCt) {
            b.addCls(Ext.baseCSSPrefix + a.layout.direction + "-box-overflow-body");
            this.afterCt = b.insertSibling({
                cls: Ext.layout.container.Box.prototype.innerCls + " " + this.afterCtCls
            },
            "before")
        }
    },
    destroy: function() {
        Ext.destroy(this.menu, this.menuTrigger)
    }
});
Ext.define("Ext.layout.container.Box", {
    alias: ["layout.box"],
    extend: "Ext.layout.container.Container",
    alternateClassName: "Ext.layout.BoxLayout",
    requires: ["Ext.layout.container.boxOverflow.None", "Ext.layout.container.boxOverflow.Menu", "Ext.layout.container.boxOverflow.Scroller", "Ext.util.Format", "Ext.dd.DragDropManager"],
    defaultMargins: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    },
    padding: "0",
    pack: "start",
    type: "box",
    scrollOffset: 0,
    itemCls: Ext.baseCSSPrefix + "box-item",
    targetCls: Ext.baseCSSPrefix + "box-layout-ct",
    innerCls: Ext.baseCSSPrefix + "box-inner",
    bindToOwnerCtContainer: true,
    availableSpaceOffset: 0,
    reserveOffset: true,
    shrinkToFit: true,
    clearInnerCtOnLayout: false,
    flexSortFn: function(d, c) {
        var e = "max" + this.parallelPrefixCap,
        f = Infinity;
        d = d.component[e] || f;
        c = c.component[e] || f;
        if (!isFinite(d) && !isFinite(c)) {
            return false
        }
        return d - c
    },
    minSizeSortFn: function(d, c) {
        return c.available - d.available
    },
    constructor: function(a) {
        var b = this;
        b.callParent(arguments);
        b.flexSortFn = Ext.Function.bind(b.flexSortFn, b);
        b.initOverflowHandler()
    },
    getChildBox: function(b) {
        b = b.el || this.owner.getComponent(b).el;
        var a = b.getBox(false, true);
        return {
            left: a.left,
            top: a.top,
            width: a.width,
            height: a.height
        }
    },
    calculateChildBox: function(e) {
        var d = this,
        b = d.calculateChildBoxes(d.getVisibleItems(), d.getLayoutTargetSize()).boxes,
        c = b.length,
        a = 0;
        e = d.owner.getComponent(e);
        for (; a < c; a++) {
            if (b[a].component === e) {
                return b[a]
            }
        }
    },
    calculateChildBoxes: function(p, b) {
        var x = this,
        J = Math,
        l = J.max,
        o = Infinity,
        v, s = x.parallelPrefix,
        n = x.parallelPrefixCap,
        M = x.perpendicularPrefix,
        t = x.perpendicularPrefixCap,
        C = "min" + n,
        F = "min" + t,
        ak = "max" + t,
        c = b[s] - x.scrollOffset,
        Z = b[M],
        ae = x.padding,
        r = ae[x.parallelBefore],
        u = r + ae[x.parallelAfter],
        P = ae[x.perpendicularLeftTop],
        K = P + ae[x.perpendicularRightBottom],
        ah = l(0, Z - K),
        aj = x.innerCt.getBorderWidth(x.perpendicularLT + x.perpendicularRB),
        ab = x.pack == "start",
        an = x.pack == "center",
        E = x.pack == "end",
        ad = Ext.Number.constrain,
        N = p.length,
        d = 0,
        ai = 0,
        al = 0,
        w = 0,
        G = 0,
        Q = [],
        L = [],
        ag,
        af,
        h,
        aa,
        A,
        B,
        am,
        Y,
        W,
        X,
        m,
        e,
        z,
        I,
        y,
        O,
        j,
        R,
        ac,
        f,
        D,
        T,
        a,
        q,
        k,
        H,
        S,
        V,
        g,
        U;
        for (af = 0; af < N; af++) {
            h = p[af];
            A = h[M];
            if (!h.flex || !(x.align == "stretch" || x.align == "stretchmax")) {
                if (h.componentLayout.initialized !== true) {
                    x.layoutItem(h)
                }
            }
            B = h.margins;
            H = B[x.parallelBefore] + B[x.parallelAfter];
            W = {
                component: h,
                margins: B
            };
            if (h.flex) {
                ai += h.flex;
                aa = v
            } else {
                if (! (h[s] && A)) {
                    am = h.getSize()
                }
                aa = h[s] || am[s];
                A = A || am[M]
            }
            d += H + (aa || 0);
            al += H + (h.flex ? h[C] || 0 : aa);
            w += H + (h[C] || aa || 0);
            if (typeof A != "number") {
                A = h["get" + t]()
            }
            G = l(G, l(A, h[F] || 0) + B[x.perpendicularLeftTop] + B[x.perpendicularRightBottom]);
            W[s] = aa || v;
            W.dirtySize = h.componentLayout.lastComponentSize ? (W[s] !== h.componentLayout.lastComponentSize[s]) : false;
            W[M] = A || v;
            Q.push(W)
        }
        if (!x.autoSize) {
            X = al - c;
            m = w > c
        }
        e = l(0, c - d - u - (x.reserveOffset ? x.availableSpaceOffset: 0));
        if (m) {
            for (af = 0; af < N; af++) {
                j = Q[af];
                z = p[af][C] || p[af][s] || j[s];
                j.dirtySize = j.dirtySize || j[s] != z;
                j[s] = z
            }
        } else {
            if (X > 0) {
                for (af = 0; af < N; af++) {
                    I = p[af];
                    z = I[C] || 0;
                    if (I.flex) {
                        j = Q[af];
                        j.dirtySize = j.dirtySize || j[s] != z;
                        j[s] = z
                    } else {
                        if (x.shrinkToFit) {
                            L.push({
                                minSize: z,
                                available: Q[af][s] - z,
                                index: af
                            })
                        }
                    }
                }
                Ext.Array.sort(L, x.minSizeSortFn);
                for (af = 0, y = L.length; af < y; af++) {
                    O = L[af].index;
                    if (O == v) {
                        continue
                    }
                    I = p[O];
                    z = L[af].minSize;
                    j = Q[O];
                    R = j[s];
                    ac = l(z, R - J.ceil(X / (y - af)));
                    f = R - ac;
                    j.dirtySize = j.dirtySize || j[s] != ac;
                    j[s] = ac;
                    X -= f
                }
                m = (X > 0)
            } else {
                a = e;
                q = ai;
                T = [];
                for (af = 0; af < N; af++) {
                    h = p[af];
                    if (ab && h.flex) {
                        T.push(Q[Ext.Array.indexOf(p, h)])
                    }
                }
                Ext.Array.sort(T, x.flexSortFn);
                for (af = 0; af < T.length; af++) {
                    S = T[af];
                    h = S.component;
                    B = S.margins;
                    k = J.ceil((h.flex / q) * a);
                    k = Math.max(h["min" + n] || 0, J.min(h["max" + n] || o, k));
                    a -= k;
                    q -= h.flex;
                    S.dirtySize = S.dirtySize || S[s] != k;
                    S[s] = k
                }
            }
        }
        if (an) {
            r += e / 2
        } else {
            if (E) {
                r += e
            }
        }
        if (x.owner.dock && (Ext.isIE6 || Ext.isIE7 || Ext.isIEQuirks) && !x.owner.width && x.direction == "vertical") {
            ag = G + x.owner.el.getPadding("lr") + x.owner.el.getBorderWidth("lr");
            if (x.owner.frameSize) {
                ag += x.owner.frameSize.left + x.owner.frameSize.right
            }
            ah = Math.min(ah, b.width = G + ae.left + ae.right)
        }
        for (af = 0; af < N; af++) {
            h = p[af];
            S = Q[af];
            B = S.margins;
            g = B[x.perpendicularLeftTop] + B[x.perpendicularRightBottom];
            r += B[x.parallelBefore];
            S[x.parallelBefore] = r;
            S[x.perpendicularLeftTop] = P + B[x.perpendicularLeftTop];
            if (x.align == "stretch") {
                U = ad(ah - g, h[F] || 0, h[ak] || o);
                S.dirtySize = S.dirtySize || S[M] != U;
                S[M] = U
            } else {
                if (x.align == "stretchmax") {
                    U = ad(G - g, h[F] || 0, h[ak] || o);
                    S.dirtySize = S.dirtySize || S[M] != U;
                    S[M] = U
                } else {
                    if (x.align == x.alignCenteringString) {
                        D = l(ah, G) - aj - S[M];
                        if (D > 0) {
                            S[x.perpendicularLeftTop] = P + Math.round(D / 2)
                        }
                    }
                }
            }
            r += (S[s] || 0) + B[x.parallelAfter]
        }
        return {
            boxes: Q,
            meta: {
                calculatedWidth: ag,
                maxSize: G,
                nonFlexSize: d,
                desiredSize: al,
                minimumSize: w,
                shortfall: X,
                tooNarrow: m
            }
        }
    },
    onRemove: function(a) {
        this.callParent(arguments);
        if (this.overflowHandler) {
            this.overflowHandler.onRemove(a)
        }
    },
    initOverflowHandler: function() {
        var c = this.overflowHandler;
        if (typeof c == "string") {
            c = {
                type: c
            }
        }
        var b = "None";
        if (c && c.type !== undefined) {
            b = c.type
        }
        var a = Ext.layout.container.boxOverflow[b];
        if (a[this.type]) {
            a = a[this.type]
        }
        this.overflowHandler = Ext.create("Ext.layout.container.boxOverflow." + b, this, c)
    },
    onLayout: function() {
        this.callParent();
        if (this.clearInnerCtOnLayout === true && this.adjustmentPass !== true) {
            this.innerCt.setSize(null, null)
        }
        var g = this,
        c = g.getLayoutTargetSize(),
        f = g.getVisibleItems(),
        b = g.calculateChildBoxes(f, c),
        e = b.boxes,
        h = b.meta,
        j,
        a,
        d;
        if (g.autoSize && b.meta.desiredSize) {
            c[g.parallelPrefix] = b.meta.desiredSize
        }
        if (h.shortfall > 0) {
            j = g.overflowHandler;
            a = h.tooNarrow ? "handleOverflow": "clearOverflow";
            d = j[a](b, c);
            if (d) {
                if (d.targetSize) {
                    c = d.targetSize
                }
                if (d.recalculate) {
                    f = g.getVisibleItems();
                    b = g.calculateChildBoxes(f, c);
                    e = b.boxes
                }
            }
        } else {
            g.overflowHandler.clearOverflow()
        }
        g.layoutTargetLastSize = c;
        g.childBoxCache = b;
        g.updateInnerCtSize(c, b);
        g.updateChildBoxes(e);
        g.handleTargetOverflow(c)
    },
    animCallback: Ext.emptyFn,
    updateChildBoxes: function(g) {
        var l = this,
        e = 0,
        c = g.length,
        o = [],
        n = Ext.dd.DDM.getDDById(l.innerCt.id),
        a,
        f,
        d,
        h,
        j,
        b;
        for (; e < c; e++) {
            f = g[e];
            h = f.component;
            if (n && (n.getDragEl() === h.el.dom)) {
                continue
            }
            d = false;
            a = l.getChildBox(h);
            if (l.animate) {
                b = l.animate.callback || l.animate;
                j = {
                    layoutAnimation: true,
                    target: h,
                    from: {},
                    to: {},
                    listeners: {}
                };
                if (!isNaN(f.width) && (f.width != a.width)) {
                    d = true;
                    j.to.width = f.width
                }
                if (!isNaN(f.height) && (f.height != a.height)) {
                    d = true;
                    j.to.height = f.height
                }
                if (!isNaN(f.left) && (f.left != a.left)) {
                    d = true;
                    j.to.left = f.left
                }
                if (!isNaN(f.top) && (f.top != a.top)) {
                    d = true;
                    j.to.top = f.top
                }
                if (d) {
                    o.push(j)
                }
            } else {
                if (f.dirtySize) {
                    if (f.width !== a.width || f.height !== a.height) {
                        l.setItemSize(h, f.width, f.height)
                    }
                }
                if (isNaN(f.left) || isNaN(f.top)) {
                    continue
                }
                h.setPosition(f.left, f.top)
            }
        }
        c = o.length;
        if (c) {
            var m = function(p) {
                c -= 1;
                if (!c) {
                    l.animCallback(p);
                    l.layoutBusy = false;
                    if (Ext.isFunction(b)) {
                        b()
                    }
                }
            };
            var k = function() {
                l.layoutBusy = true
            };
            for (e = 0, c = o.length; e < c; e++) {
                j = o[e];
                j.listeners.afteranimate = m;
                if (!e) {
                    j.listeners.beforeanimate = k
                }
                if (l.animate.duration) {
                    j.duration = l.animate.duration
                }
                h = j.target;
                delete j.target;
                h.stopAnimation();
                h.animate(j)
            }
        }
    },
    updateInnerCtSize: function(c, a) {
        var g = this,
        e = Math.max,
        f = g.align,
        h = g.padding,
        b = c.width,
        k = c.height,
        l = a.meta,
        d, j;
        if (g.direction == "horizontal") {
            d = b;
            j = l.maxSize + h.top + h.bottom + g.innerCt.getBorderWidth("tb");
            if (f == "stretch") {
                j = k
            } else {
                if (f == "middle") {
                    j = e(k, j)
                }
            }
        } else {
            j = k;
            d = l.maxSize + h.left + h.right + g.innerCt.getBorderWidth("lr");
            if (f == "stretch") {
                d = b
            } else {
                if (f == "center") {
                    d = e(b, d)
                }
            }
        }
        g.getRenderTarget().setSize(d || undefined, j || undefined);
        if (l.calculatedWidth && g.owner.el.getWidth() > l.calculatedWidth) {
            g.owner.el.setWidth(l.calculatedWidth)
        }
        if (g.innerCt.dom.scrollTop) {
            g.innerCt.dom.scrollTop = 0
        }
    },
    handleTargetOverflow: function(c) {
        var b = this.getTarget(),
        d = b.getStyle("overflow"),
        a;
        if (d && d != "hidden" && !this.adjustmentPass) {
            a = this.getLayoutTargetSize();
            if (a.width != c.width || a.height != c.height) {
                this.adjustmentPass = true;
                this.onLayout();
                return true
            }
        }
        delete this.adjustmentPass
    },
    isValidParent: function(c, d, a) {
        var b = c.el ? c.el.dom: Ext.getDom(c);
        return (b && this.innerCt && b.parentNode === this.innerCt.dom) || false
    },
    getRenderTarget: function() {
        if (!this.innerCt) {
            this.innerCt = this.getTarget().createChild({
                cls: this.innerCls,
                role: "presentation"
            });
            this.padding = Ext.util.Format.parseBox(this.padding)
        }
        return this.innerCt
    },
    renderItem: function(d, f) {
        this.callParent(arguments);
        var c = this,
        a = d.getEl(),
        b = a.dom.style,
        e = d.margins || d.margin;
        if (e) {
            if (Ext.isString(e) || Ext.isNumber(e)) {
                e = Ext.util.Format.parseBox(e)
            } else {
                Ext.applyIf(e, {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                })
            }
        } else {
            e = Ext.apply({},
            c.defaultMargins)
        }
        e.top += a.getMargin("t");
        e.right += a.getMargin("r");
        e.bottom += a.getMargin("b");
        e.left += a.getMargin("l");
        e.height = e.top + e.bottom;
        e.width = e.left + e.right;
        b.marginTop = b.marginRight = b.marginBottom = b.marginLeft = "0";
        d.margins = e
    },
    destroy: function() {
        Ext.destroy(this.innerCt, this.overflowHandler);
        this.callParent(arguments)
    }
});
Ext.define("Ext.layout.container.HBox", {
    alias: ["layout.hbox"],
    extend: "Ext.layout.container.Box",
    alternateClassName: "Ext.layout.HBoxLayout",
    align: "top",
    alignCenteringString: "middle",
    type: "hbox",
    direction: "horizontal",
    parallelSizeIndex: 0,
    perpendicularSizeIndex: 1,
    parallelPrefix: "width",
    parallelPrefixCap: "Width",
    parallelLT: "l",
    parallelRB: "r",
    parallelBefore: "left",
    parallelBeforeCap: "Left",
    parallelAfter: "right",
    parallelPosition: "x",
    perpendicularPrefix: "height",
    perpendicularPrefixCap: "Height",
    perpendicularLT: "t",
    perpendicularRB: "b",
    perpendicularLeftTop: "top",
    perpendicularRightBottom: "bottom",
    perpendicularPosition: "y",
    configureItem: function(a) {
        if (a.flex) {
            a.layoutManagedWidth = 1
        } else {
            a.layoutManagedWidth = 2
        }
        if (this.align === "stretch" || this.align === "stretchmax") {
            a.layoutManagedHeight = 1
        } else {
            a.layoutManagedHeight = 2
        }
        this.callParent(arguments)
    }
});
Ext.define("Ext.layout.container.VBox", {
    alias: ["layout.vbox"],
    extend: "Ext.layout.container.Box",
    alternateClassName: "Ext.layout.VBoxLayout",
    align: "left",
    alignCenteringString: "center",
    type: "vbox",
    direction: "vertical",
    parallelSizeIndex: 1,
    perpendicularSizeIndex: 0,
    parallelPrefix: "height",
    parallelPrefixCap: "Height",
    parallelLT: "t",
    parallelRB: "b",
    parallelBefore: "top",
    parallelBeforeCap: "Top",
    parallelAfter: "bottom",
    parallelPosition: "y",
    perpendicularPrefix: "width",
    perpendicularPrefixCap: "Width",
    perpendicularLT: "l",
    perpendicularRB: "r",
    perpendicularLeftTop: "left",
    perpendicularRightBottom: "right",
    perpendicularPosition: "x",
    configureItem: function(a) {
        if (a.flex) {
            a.layoutManagedHeight = 1
        } else {
            a.layoutManagedHeight = 2
        }
        if (this.align === "stretch" || this.align === "stretchmax") {
            a.layoutManagedWidth = 1
        } else {
            a.layoutManagedWidth = 2
        }
        this.callParent(arguments)
    }
});
Ext.define("Ext.toolbar.Toolbar", {
    extend: "Ext.container.Container",
    requires: ["Ext.toolbar.Fill", "Ext.layout.container.HBox", "Ext.layout.container.VBox", "Ext.FocusManager"],
    uses: ["Ext.toolbar.Separator"],
    alias: "widget.toolbar",
    alternateClassName: "Ext.Toolbar",
    isToolbar: true,
    baseCls: Ext.baseCSSPrefix + "toolbar",
    ariaRole: "toolbar",
    defaultType: "button",
    vertical: false,
    enableOverflow: false,
    menuTriggerCls: Ext.baseCSSPrefix + "toolbar-more-icon",
    trackMenus: true,
    itemCls: Ext.baseCSSPrefix + "toolbar-item",
    initComponent: function() {
        var b = this,
        a;
        if (!b.layout && b.enableOverflow) {
            b.layout = {
                overflowHandler: "Menu"
            }
        }
        if (b.dock === "right" || b.dock === "left") {
            b.vertical = true
        }
        b.layout = Ext.applyIf(Ext.isString(b.layout) ? {
            type: b.layout
        }: b.layout || {},
        {
            type: b.vertical ? "vbox": "hbox",
            align: b.vertical ? "stretchmax": "middle",
            clearInnerCtOnLayout: true
        });
        if (b.vertical) {
            b.addClsWithUI("vertical")
        }
        if (b.ui === "footer") {
            b.ignoreBorderManagement = true
        }
        b.callParent();
        b.addEvents("overflowchange");
        a = b.vertical ? ["up", "down"] : ["left", "right"];
        Ext.FocusManager.subscribe(b, {
            keys: a
        })
    },
    getRefItems: function(a) {
        var e = this,
        b = e.callParent(arguments),
        d = e.layout,
        c;
        if (a && e.enableOverflow) {
            c = d.overflowHandler;
            if (c && c.menu) {
                b = b.concat(c.menu.getRefItems(a))
            }
        }
        return b
    },
    lookupComponent: function(b) {
        if (Ext.isString(b)) {
            var a = Ext.toolbar.Toolbar.shortcuts[b];
            if (a) {
                b = {
                    xtype: a
                }
            } else {
                b = {
                    xtype: "tbtext",
                    text: b
                }
            }
            this.applyDefaults(b)
        }
        return this.callParent(arguments)
    },
    applyDefaults: function(b) {
        if (!Ext.isString(b)) {
            b = this.callParent(arguments);
            var a = this.internalDefaults;
            if (b.events) {
                Ext.applyIf(b.initialConfig, a);
                Ext.apply(b, a)
            } else {
                Ext.applyIf(b, a)
            }
        }
        return b
    },
    trackMenu: function(c, a) {
        if (this.trackMenus && c.menu) {
            var d = a ? "mun": "mon",
            b = this;
            b[d](c, "mouseover", b.onButtonOver, b);
            b[d](c, "menushow", b.onButtonMenuShow, b);
            b[d](c, "menuhide", b.onButtonMenuHide, b)
        }
    },
    constructButton: function(a) {
        return a.events ? a: this.createComponent(a, a.split ? "splitbutton": this.defaultType)
    },
    onBeforeAdd: function(a) {
        if (a.is("field") || (a.is("button") && this.ui != "footer")) {
            a.ui = a.ui + "-toolbar"
        }
        if (a instanceof Ext.toolbar.Separator) {
            a.setUI((this.vertical) ? "vertical": "horizontal")
        }
        this.callParent(arguments)
    },
    onAdd: function(a) {
        this.callParent(arguments);
        this.trackMenu(a);
        if (this.disabled) {
            a.disable()
        }
    },
    onRemove: function(a) {
        this.callParent(arguments);
        this.trackMenu(a, true)
    },
    onButtonOver: function(a) {
        if (this.activeMenuBtn && this.activeMenuBtn != a) {
            this.activeMenuBtn.hideMenu();
            a.showMenu();
            this.activeMenuBtn = a
        }
    },
    onButtonMenuShow: function(a) {
        this.activeMenuBtn = a
    },
    onButtonMenuHide: function(a) {
        delete this.activeMenuBtn
    }
},
function() {
    this.shortcuts = {
        "-": "tbseparator",
        " ": "tbspacer",
        "->": "tbfill"
    }
});
Ext.define("Ext.panel.AbstractPanel", {
    extend: "Ext.container.Container",
    requires: ["Ext.util.MixedCollection", "Ext.Element", "Ext.toolbar.Toolbar"],
    baseCls: Ext.baseCSSPrefix + "panel",
    isPanel: true,
    componentLayout: "dock",
    defaultDockWeights: {
        top: 1,
        left: 3,
        right: 5,
        bottom: 7
    },
    renderTpl: ['<div id="{id}-body" class="{baseCls}-body<tpl if="bodyCls"> {bodyCls}</tpl>', ' {baseCls}-body-{ui}<tpl if="uiCls">', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>', '</tpl>"<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "</div>"],
    border: true,
    initComponent: function() {
        var a = this;
        a.addEvents("bodyresize");
        a.addChildEls("body");
        if (a.frame && a.border && a.bodyBorder === undefined) {
            a.bodyBorder = false
        }
        if (a.frame && a.border && (a.bodyBorder === false || a.bodyBorder === 0)) {
            a.manageBodyBorders = true
        }
        a.callParent()
    },
    initItems: function() {
        var b = this,
        a = b.dockedItems;
        b.callParent();
        b.dockedItems = Ext.create("Ext.util.MixedCollection", false, b.getComponentId);
        if (a) {
            b.addDocked(a)
        }
    },
    getDockedComponent: function(a) {
        if (Ext.isObject(a)) {
            a = a.getItemId()
        }
        return this.dockedItems.get(a)
    },
    getComponent: function(a) {
        var b = this.callParent(arguments);
        if (b === undefined && !Ext.isNumber(a)) {
            b = this.getDockedComponent(a)
        }
        return b
    },
    initBodyStyles: function() {
        var d = this,
        a = d.bodyStyle,
        c = [],
        b = Ext.Element,
        e;
        if (Ext.isFunction(a)) {
            a = a()
        }
        if (Ext.isString(a)) {
            c = a.split(";")
        } else {
            for (e in a) {
                if (a.hasOwnProperty(e)) {
                    c.push(e + ":" + a[e])
                }
            }
        }
        if (d.bodyPadding !== undefined) {
            c.push("padding: " + b.unitizeBox((d.bodyPadding === true) ? 5 : d.bodyPadding))
        }
        if (d.frame && d.bodyBorder) {
            if (!Ext.isNumber(d.bodyBorder)) {
                d.bodyBorder = 1
            }
            c.push("border-width: " + b.unitizeBox(d.bodyBorder))
        }
        delete d.bodyStyle;
        return c.length ? c.join(";") : undefined
    },
    initBodyCls: function() {
        var b = this,
        a = "",
        c = b.bodyCls;
        if (c) {
            Ext.each(c,
            function(d) {
                a += " " + d
            });
            delete b.bodyCls
        }
        return a.length > 0 ? a: undefined
    },
    initRenderData: function() {
        return Ext.applyIf(this.callParent(), {
            bodyStyle: this.initBodyStyles(),
            bodyCls: this.initBodyCls()
        })
    },
    addDocked: function(a, f) {
        var e = this,
        b = 0,
        d, c;
        a = e.prepareItems(a);
        c = a.length;
        for (; b < c; b++) {
            d = a[b];
            d.dock = d.dock || "top";
            if (e.border === false) {}
            if (f !== undefined) {
                e.dockedItems.insert(f + b, d)
            } else {
                e.dockedItems.add(d)
            }
            d.onAdded(e, b);
            e.onDockedAdd(d)
        }
        e.componentLayout.childrenChanged = true;
        if (e.rendered && !e.suspendLayout) {
            e.doComponentLayout()
        }
        return a
    },
    onDockedAdd: Ext.emptyFn,
    onDockedRemove: Ext.emptyFn,
    insertDocked: function(b, a) {
        this.addDocked(a, b)
    },
    removeDocked: function(e, b) {
        var d = this,
        c, a;
        if (!d.dockedItems.contains(e)) {
            return e
        }
        c = d.componentLayout;
        a = c && d.rendered;
        if (a) {
            c.onRemove(e)
        }
        d.dockedItems.remove(e);
        e.onRemoved();
        d.onDockedRemove(e);
        if (b === true || (b !== false && d.autoDestroy)) {
            e.destroy()
        } else {
            if (a) {
                c.afterRemove(e)
            }
        }
        d.componentLayout.childrenChanged = true;
        if (!d.destroying && !d.suspendLayout) {
            d.doComponentLayout()
        }
        return e
    },
    getDockedItems: function(c) {
        var d = this,
        b = d.defaultDockWeights,
        a;
        if (d.dockedItems && d.dockedItems.items.length) {
            if (c) {
                a = Ext.ComponentQuery.query(c, d.dockedItems.items)
            } else {
                a = d.dockedItems.items.slice()
            }
            Ext.Array.sort(a,
            function(f, e) {
                var g = f.weight || b[f.dock],
                h = e.weight || b[e.dock];
                if (Ext.isNumber(g) && Ext.isNumber(h)) {
                    return g - h
                }
                return 0
            });
            return a
        }
        return []
    },
    addUIClsToElement: function(b, f) {
        var e = this,
        a = e.callParent(arguments),
        d = [Ext.baseCSSPrefix + b, e.baseCls + "-body-" + b, e.baseCls + "-body-" + e.ui + "-" + b],
        g,
        c;
        if (!f && e.rendered) {
            if (e.bodyCls) {
                e.body.addCls(e.bodyCls)
            } else {
                e.body.addCls(d)
            }
        } else {
            if (e.bodyCls) {
                g = e.bodyCls.split(" ");
                for (c = 0; c < d.length; c++) {
                    if (!Ext.Array.contains(g, d[c])) {
                        g.push(d[c])
                    }
                }
                e.bodyCls = g.join(" ")
            } else {
                e.bodyCls = d.join(" ")
            }
        }
        return a
    },
    removeUIClsFromElement: function(b, f) {
        var e = this,
        a = e.callParent(arguments),
        d = [Ext.baseCSSPrefix + b, e.baseCls + "-body-" + b, e.baseCls + "-body-" + e.ui + "-" + b],
        g,
        c;
        if (!f && e.rendered) {
            if (e.bodyCls) {
                e.body.removeCls(e.bodyCls)
            } else {
                e.body.removeCls(d)
            }
        } else {
            if (e.bodyCls) {
                g = e.bodyCls.split(" ");
                for (c = 0; c < d.length; c++) {
                    Ext.Array.remove(g, d[c])
                }
                e.bodyCls = g.join(" ")
            }
        }
        return a
    },
    addUIToElement: function(c) {
        var b = this,
        a = b.baseCls + "-body-" + b.ui,
        d;
        b.callParent(arguments);
        if (!c && b.rendered) {
            if (b.bodyCls) {
                b.body.addCls(b.bodyCls)
            } else {
                b.body.addCls(a)
            }
        } else {
            if (b.bodyCls) {
                d = b.bodyCls.split(" ");
                if (!Ext.Array.contains(d, a)) {
                    d.push(a)
                }
                b.bodyCls = d.join(" ")
            } else {
                b.bodyCls = a
            }
        }
    },
    removeUIFromElement: function() {
        var b = this,
        a = b.baseCls + "-body-" + b.ui,
        c;
        b.callParent(arguments);
        if (b.rendered) {
            if (b.bodyCls) {
                b.body.removeCls(b.bodyCls)
            } else {
                b.body.removeCls(a)
            }
        } else {
            if (b.bodyCls) {
                c = b.bodyCls.split(" ");
                Ext.Array.remove(c, a);
                b.bodyCls = c.join(" ")
            } else {
                b.bodyCls = a
            }
        }
    },
    getTargetEl: function() {
        return this.body
    },
    getRefItems: function(a) {
        var b = this.callParent(arguments),
        d = this.getDockedItems(a ? "*,* *": undefined),
        f = d.length,
        c = 0,
        e;
        for (; c < f; c++) {
            e = d[c];
            if (e.dock === "right" || e.dock === "bottom") {
                break
            }
        }
        return Ext.Array.splice(d, 0, c).concat(b).concat(d)
    },
    beforeDestroy: function() {
        var b = this.dockedItems,
        a;
        if (b) {
            while ((a = b.first())) {
                this.removeDocked(a, true)
            }
        }
        this.callParent()
    },
    setBorder: function(a) {
        var b = this;
        b.border = (a !== undefined) ? a: true;
        if (b.rendered) {
            b.doComponentLayout()
        }
    }
});
Ext.define("Ext.data.writer.Json", {
    extend: "Ext.data.writer.Writer",
    alternateClassName: "Ext.data.JsonWriter",
    alias: "writer.json",
    root: undefined,
    encode: false,
    allowSingle: true,
    writeRecords: function(b, c) {
        var a = this.root;
        if (this.allowSingle && c.length == 1) {
            c = c[0]
        }
        if (this.encode) {
            if (a) {
                b.params[a] = Ext.encode(c)
            } else {
                Ext.Error.raise("Must specify a root when using encode")
            }
        } else {
            b.jsonData = b.jsonData || {};
            if (a) {
                b.jsonData[a] = c
            } else {
                b.jsonData = c
            }
        }
        return b
    }
});
Ext.define("Ext.data.reader.Reader", {
    requires: ["Ext.data.ResultSet"],
    alternateClassName: ["Ext.data.Reader", "Ext.data.DataReader"],
    totalProperty: "total",
    successProperty: "success",
    root: "",
    implicitIncludes: true,
    isReader: true,
    constructor: function(a) {
        var b = this;
        Ext.apply(b, a || {});
        b.fieldCount = 0;
        b.model = Ext.ModelManager.getModel(a.model);
        if (b.model) {
            b.buildExtractors()
        }
    },
    setModel: function(a, c) {
        var b = this;
        b.model = Ext.ModelManager.getModel(a);
        b.buildExtractors(true);
        if (c && b.proxy) {
            b.proxy.setModel(b.model, true)
        }
    },
    read: function(a) {
        var b = a;
        if (a && a.responseText) {
            b = this.getResponseData(a)
        }
        if (b) {
            return this.readRecords(b)
        } else {
            return this.nullResultSet
        }
    },
    readRecords: function(c) {
        var d = this;
        if (d.fieldCount !== d.getFields().length) {
            d.buildExtractors(true)
        }
        d.rawData = c;
        c = d.getData(c);
        var f = Ext.isArray(c) ? c: d.getRoot(c),
        h = true,
        b = 0,
        e,
        g,
        a,
        j;
        if (f) {
            e = f.length
        }
        if (d.totalProperty) {
            g = parseInt(d.getTotal(c), 10);
            if (!isNaN(g)) {
                e = g
            }
        }
        if (d.successProperty) {
            g = d.getSuccess(c);
            if (g === false || g === "false") {
                h = false
            }
        }
        if (d.messageProperty) {
            j = d.getMessage(c)
        }
        if (f) {
            a = d.extractData(f);
            b = a.length
        } else {
            b = 0;
            a = []
        }
        return Ext.create("Ext.data.ResultSet", {
            total: e || b,
            count: b,
            records: a,
            success: h,
            message: j
        })
    },
    extractData: function(j) {
        var h = this,
        k = [],
        e = [],
        d = h.model,
        f = 0,
        b = j.length,
        l = h.getIdProperty(),
        c,
        a,
        g;
        if (!j.length && Ext.isObject(j)) {
            j = [j];
            b = 1
        }
        for (; f < b; f++) {
            c = j[f];
            k = h.extractValues(c);
            a = h.getId(c);
            g = new d(k, a, c);
            e.push(g);
            if (h.implicitIncludes) {
                h.readAssociated(g, c)
            }
        }
        return e
    },
    readAssociated: function(g, e) {
        var d = g.associations.items,
        f = 0,
        a = d.length,
        c, b, j, h;
        for (; f < a; f++) {
            c = d[f];
            b = this.getAssociatedDataRoot(e, c.associationKey || c.name);
            if (b) {
                h = c.getReader();
                if (!h) {
                    j = c.associatedModel.proxy;
                    if (j) {
                        h = j.getReader()
                    } else {
                        h = new this.constructor({
                            model: c.associatedName
                        })
                    }
                }
                c.read(g, h, b)
            }
        }
    },
    getAssociatedDataRoot: function(b, a) {
        return b[a]
    },
    getFields: function() {
        return this.model.prototype.fields.items
    },
    extractValues: function(f) {
        var a = this.getFields(),
        c = 0,
        d = a.length,
        b = {},
        g,
        e;
        for (; c < d; c++) {
            g = a[c];
            e = this.extractorFunctions[c](f);
            b[g.name] = e
        }
        return b
    },
    getData: function(a) {
        return a
    },
    getRoot: function(a) {
        return a
    },
    getResponseData: function(a) {
        Ext.Error.raise("getResponseData must be implemented in the Ext.data.reader.Reader subclass")
    },
    onMetaChange: function(c) {
        var a = c.fields,
        b;
        Ext.apply(this, c);
        if (a) {
            b = Ext.define("Ext.data.reader.Json-Model" + Ext.id(), {
                extend: "Ext.data.Model",
                fields: a
            });
            this.setModel(b, true)
        } else {
            this.buildExtractors(true)
        }
    },
    getIdProperty: function() {
        var a = this.idProperty;
        if (Ext.isEmpty(a)) {
            a = this.model.prototype.idProperty
        }
        return a
    },
    buildExtractors: function(e) {
        var c = this,
        g = c.getIdProperty(),
        d = c.totalProperty,
        b = c.successProperty,
        f = c.messageProperty,
        a;
        if (e === true) {
            delete c.extractorFunctions
        }
        if (c.extractorFunctions) {
            return
        }
        if (d) {
            c.getTotal = c.createAccessor(d)
        }
        if (b) {
            c.getSuccess = c.createAccessor(b)
        }
        if (f) {
            c.getMessage = c.createAccessor(f)
        }
        if (g) {
            a = c.createAccessor(g);
            c.getId = function(h) {
                var j = a.call(c, h);
                return (j === undefined || j === "") ? null: j
            }
        } else {
            c.getId = function() {
                return null
            }
        }
        c.buildFieldExtractors()
    },
    buildFieldExtractors: function() {
        var d = this,
        a = d.getFields(),
        c = a.length,
        b = 0,
        g = [],
        f,
        e;
        for (; b < c; b++) {
            f = a[b];
            e = (f.mapping !== undefined && f.mapping !== null) ? f.mapping: f.name;
            g.push(d.createAccessor(e))
        }
        d.fieldCount = c;
        d.extractorFunctions = g
    }
},
function() {
    Ext.apply(this, {
        nullResultSet: Ext.create("Ext.data.ResultSet", {
            total: 0,
            count: 0,
            records: [],
            success: true
        })
    })
});
Ext.define("Ext.data.reader.Json", {
    extend: "Ext.data.reader.Reader",
    alternateClassName: "Ext.data.JsonReader",
    alias: "reader.json",
    root: "",
    useSimpleAccessors: false,
    readRecords: function(a) {
        if (a.metaData) {
            this.onMetaChange(a.metaData)
        }
        this.jsonData = a;
        return this.callParent([a])
    },
    getResponseData: function(a) {
        var c;
        try {
            c = Ext.decode(a.responseText)
        } catch(b) {
            Ext.Error.raise({
                response: a,
                json: a.responseText,
                parseError: b,
                msg: "Unable to parse the JSON returned by the server: " + b.toString()
            })
        }
        if (!c) {
            Ext.Error.raise("JSON object not found")
        }
        return c
    },
    buildExtractors: function() {
        var a = this;
        a.callParent(arguments);
        if (a.root) {
            a.getRoot = a.createAccessor(a.root)
        } else {
            a.getRoot = function(b) {
                return b
            }
        }
    },
    extractData: function(a) {
        var e = this.record,
        d = [],
        c,
        b;
        if (e) {
            c = a.length;
            if (!c && Ext.isObject(a)) {
                c = 1;
                a = [a]
            }
            for (b = 0; b < c; b++) {
                d[b] = a[b][e]
            }
        } else {
            d = a
        }
        return this.callParent([d])
    },
    createAccessor: function() {
        var a = /[\[\.]/;
        return function(c) {
            if (Ext.isEmpty(c)) {
                return Ext.emptyFn
            }
            if (Ext.isFunction(c)) {
                return c
            }
            if (this.useSimpleAccessors !== true) {
                var b = String(c).search(a);
                if (b >= 0) {
                    return Ext.functionFactory("obj", "return obj" + (b > 0 ? ".": "") + c)
                }
            }
            return function(d) {
                return d[c]
            }
        }
    } ()
});
Ext.define("Ext.data.proxy.Proxy", {
    alias: "proxy.proxy",
    alternateClassName: ["Ext.data.DataProxy", "Ext.data.Proxy"],
    requires: ["Ext.data.reader.Json", "Ext.data.writer.Json"],
    uses: ["Ext.data.Batch", "Ext.data.Operation", "Ext.data.Model"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    batchOrder: "create,update,destroy",
    batchActions: true,
    defaultReaderType: "json",
    defaultWriterType: "json",
    isProxy: true,
    constructor: function(a) {
        a = a || {};
        if (a.model === undefined) {
            delete a.model
        }
        this.mixins.observable.constructor.call(this, a);
        if (this.model !== undefined && !(this.model instanceof Ext.data.Model)) {
            this.setModel(this.model)
        }
    },
    setModel: function(b, c) {
        this.model = Ext.ModelManager.getModel(b);
        var a = this.reader,
        d = this.writer;
        this.setReader(a);
        this.setWriter(d);
        if (c && this.store) {
            this.store.setModel(this.model)
        }
    },
    getModel: function() {
        return this.model
    },
    setReader: function(a) {
        var b = this;
        if (a === undefined || typeof a == "string") {
            a = {
                type: a
            }
        }
        if (a.isReader) {
            a.setModel(b.model)
        } else {
            Ext.applyIf(a, {
                proxy: b,
                model: b.model,
                type: b.defaultReaderType
            });
            a = Ext.createByAlias("reader." + a.type, a)
        }
        b.reader = a;
        return b.reader
    },
    getReader: function() {
        return this.reader
    },
    setWriter: function(a) {
        if (a === undefined || typeof a == "string") {
            a = {
                type: a
            }
        }
        if (! (a instanceof Ext.data.writer.Writer)) {
            Ext.applyIf(a, {
                model: this.model,
                type: this.defaultWriterType
            });
            a = Ext.createByAlias("writer." + a.type, a)
        }
        this.writer = a;
        return this.writer
    },
    getWriter: function() {
        return this.writer
    },
    create: Ext.emptyFn,
    read: Ext.emptyFn,
    update: Ext.emptyFn,
    destroy: Ext.emptyFn,
    batch: function(d, e) {
        var f = this,
        c = Ext.create("Ext.data.Batch", {
            proxy: f,
            listeners: e || {}
        }),
        b = f.batchActions,
        a;
        Ext.each(f.batchOrder.split(","),
        function(g) {
            a = d[g];
            if (a) {
                if (b) {
                    c.add(Ext.create("Ext.data.Operation", {
                        action: g,
                        records: a
                    }))
                } else {
                    Ext.each(a,
                    function(h) {
                        c.add(Ext.create("Ext.data.Operation", {
                            action: g,
                            records: [h]
                        }))
                    })
                }
            }
        },
        f);
        c.start();
        return c
    }
},
function() {
    Ext.data.DataProxy = this
});
Ext.define("Ext.data.proxy.Server", {
    extend: "Ext.data.proxy.Proxy",
    alias: "proxy.server",
    alternateClassName: "Ext.data.ServerProxy",
    uses: ["Ext.data.Request"],
    pageParam: "page",
    startParam: "start",
    limitParam: "limit",
    groupParam: "group",
    sortParam: "sort",
    filterParam: "filter",
    directionParam: "dir",
    simpleSortMode: false,
    noCache: true,
    cacheString: "_dc",
    timeout: 30000,
    constructor: function(a) {
        var b = this;
        a = a || {};
        this.addEvents("exception");
        b.callParent([a]);
        b.extraParams = a.extraParams || {};
        b.api = a.api || {};
        b.nocache = b.noCache
    },
    create: function() {
        return this.doRequest.apply(this, arguments)
    },
    read: function() {
        return this.doRequest.apply(this, arguments)
    },
    update: function() {
        return this.doRequest.apply(this, arguments)
    },
    destroy: function() {
        return this.doRequest.apply(this, arguments)
    },
    buildRequest: function(a) {
        var c = Ext.applyIf(a.params || {},
        this.extraParams || {}),
        b;
        c = Ext.applyIf(c, this.getParams(a));
        if (a.id && !c.id) {
            c.id = a.id
        }
        b = Ext.create("Ext.data.Request", {
            params: c,
            action: a.action,
            records: a.records,
            operation: a,
            url: a.url
        });
        b.url = this.buildUrl(b);
        a.request = b;
        return b
    },
    processResponse: function(g, a, c, b, f, h) {
        var e = this,
        d, j;
        if (g === true) {
            d = e.getReader();
            j = d.read(e.extractResponseData(b));
            if (j.success !== false) {
                Ext.apply(a, {
                    response: b,
                    resultSet: j
                });
                a.commitRecords(j.records);
                a.setCompleted();
                a.setSuccessful()
            } else {
                a.setException(j.message);
                e.fireEvent("exception", this, b, a)
            }
        } else {
            e.setException(a, b);
            e.fireEvent("exception", this, b, a)
        }
        if (typeof f == "function") {
            f.call(h || e, a)
        }
        e.afterRequest(c, g)
    },
    setException: function(b, a) {
        b.setException({
            status: a.status,
            statusText: a.statusText
        })
    },
    extractResponseData: function(a) {
        return a
    },
    applyEncoding: function(a) {
        return Ext.encode(a)
    },
    encodeSorters: function(d) {
        var b = [],
        c = d.length,
        a = 0;
        for (; a < c; a++) {
            b[a] = {
                property: d[a].property,
                direction: d[a].direction
            }
        }
        return this.applyEncoding(b)
    },
    encodeFilters: function(d) {
        var b = [],
        c = d.length,
        a = 0;
        for (; a < c; a++) {
            b[a] = {
                property: d[a].property,
                value: d[a].value
            }
        }
        return this.applyEncoding(b)
    },
    getParams: function(l) {
        var s = this,
        r = {},
        o = Ext.isDefined,
        p = l.groupers,
        a = l.sorters,
        j = l.filters,
        g = l.page,
        f = l.start,
        q = l.limit,
        h = s.simpleSortMode,
        n = s.pageParam,
        d = s.startParam,
        b = s.limitParam,
        c = s.groupParam,
        e = s.sortParam,
        m = s.filterParam,
        k = s.directionParam;
        if (n && o(g)) {
            r[n] = g
        }
        if (d && o(f)) {
            r[d] = f
        }
        if (b && o(q)) {
            r[b] = q
        }
        if (c && p && p.length > 0) {
            r[c] = s.encodeSorters(p)
        }
        if (e && a && a.length > 0) {
            if (h) {
                r[e] = a[0].property;
                r[k] = a[0].direction
            } else {
                r[e] = s.encodeSorters(a)
            }
        }
        if (m && j && j.length > 0) {
            r[m] = s.encodeFilters(j)
        }
        return r
    },
    buildUrl: function(c) {
        var b = this,
        a = b.getUrl(c);
        if (!a) {
            Ext.Error.raise("You are using a ServerProxy but have not supplied it with a url.")
        }
        if (b.noCache) {
            a = Ext.urlAppend(a, Ext.String.format("{0}={1}", b.cacheString, Ext.Date.now()))
        }
        return a
    },
    getUrl: function(a) {
        return a.url || this.api[a.action] || this.url
    },
    doRequest: function(a, c, b) {
        Ext.Error.raise("The doRequest function has not been implemented on your Ext.data.proxy.Server subclass. See src/data/ServerProxy.js for details")
    },
    afterRequest: Ext.emptyFn,
    onDestroy: function() {
        Ext.destroy(this.reader, this.writer)
    }
});
Ext.define("Ext.data.proxy.Ajax", {
    requires: ["Ext.util.MixedCollection", "Ext.Ajax"],
    extend: "Ext.data.proxy.Server",
    alias: "proxy.ajax",
    alternateClassName: ["Ext.data.HttpProxy", "Ext.data.AjaxProxy"],
    actionMethods: {
        create: "POST",
        read: "GET",
        update: "POST",
        destroy: "POST"
    },
    doRequest: function(a, e, b) {
        var d = this.getWriter(),
        c = this.buildRequest(a, e, b);
        if (a.allowWrite()) {
            c = d.write(c)
        }
        Ext.apply(c, {
            headers: this.headers,
            timeout: this.timeout,
            scope: this,
            callback: this.createRequestCallback(c, a, e, b),
            method: this.getMethod(c),
            disableCaching: false
        });
        Ext.Ajax.request(c);
        return c
    },
    getMethod: function(a) {
        return this.actionMethods[a.action]
    },
    createRequestCallback: function(d, a, e, b) {
        var c = this;
        return function(g, h, f) {
            c.processResponse(h, a, d, f, e, b)
        }
    }
},
function() {
    Ext.data.HttpProxy = this
});
Ext.define("Ext.data.Model", {
    alternateClassName: "Ext.data.Record",
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.ModelManager", "Ext.data.IdGenerator", "Ext.data.Field", "Ext.data.Errors", "Ext.data.Operation", "Ext.data.validations", "Ext.data.proxy.Ajax", "Ext.util.MixedCollection"],
    onClassExtended: function(a, b) {
        var c = b.onBeforeClassCreated;
        b.onBeforeClassCreated = function(d, x) {
            var w = this,
            y = Ext.getClassName(d),
            l = d.prototype,
            q = d.prototype.superclass,
            e = x.validations || [],
            n = x.fields || [],
            s = x.associations || [],
            r = x.belongsTo,
            m = x.hasMany,
            o = x.idgen,
            u = new Ext.util.MixedCollection(false,
            function(z) {
                return z.name
            }),
            t = new Ext.util.MixedCollection(false,
            function(z) {
                return z.name
            }),
            k = q.validations,
            v = q.fields,
            g = q.associations,
            f,
            p,
            h,
            j = [];
            d.modelName = y;
            l.modelName = y;
            if (k) {
                e = k.concat(e)
            }
            x.validations = e;
            if (v) {
                n = v.items.concat(n)
            }
            for (p = 0, h = n.length; p < h; ++p) {
                u.add(new Ext.data.Field(n[p]))
            }
            x.fields = u;
            if (o) {
                x.idgen = Ext.data.IdGenerator.get(o)
            }
            if (r) {
                r = Ext.Array.from(r);
                for (p = 0, h = r.length; p < h; ++p) {
                    f = r[p];
                    if (!Ext.isObject(f)) {
                        f = {
                            model: f
                        }
                    }
                    f.type = "belongsTo";
                    s.push(f)
                }
                delete x.belongsTo
            }
            if (m) {
                m = Ext.Array.from(m);
                for (p = 0, h = m.length; p < h; ++p) {
                    f = m[p];
                    if (!Ext.isObject(f)) {
                        f = {
                            model: f
                        }
                    }
                    f.type = "hasMany";
                    s.push(f)
                }
                delete x.hasMany
            }
            if (g) {
                s = g.items.concat(s)
            }
            for (p = 0, h = s.length; p < h; ++p) {
                j.push("association." + s[p].type.toLowerCase())
            }
            if (x.proxy) {
                if (typeof x.proxy === "string") {
                    j.push("proxy." + x.proxy)
                } else {
                    if (typeof x.proxy.type === "string") {
                        j.push("proxy." + x.proxy.type)
                    }
                }
            }
            Ext.require(j,
            function() {
                Ext.ModelManager.registerType(y, d);
                for (p = 0, h = s.length; p < h; ++p) {
                    f = s[p];
                    Ext.apply(f, {
                        ownerModel: y,
                        associatedModel: f.model
                    });
                    if (Ext.ModelManager.getModel(f.model) === undefined) {
                        Ext.ModelManager.registerDeferredAssociation(f)
                    } else {
                        t.add(Ext.data.Association.create(f))
                    }
                }
                x.associations = t;
                c.call(w, d, x);
                d.setProxy(d.prototype.proxy || d.prototype.defaultProxyType);
                Ext.ModelManager.onModelDefined(d)
            })
        }
    },
    inheritableStatics: {
        setProxy: function(a) {
            if (!a.isProxy) {
                if (typeof a == "string") {
                    a = {
                        type: a
                    }
                }
                a = Ext.createByAlias("proxy." + a.type, a)
            }
            a.setModel(this);
            this.proxy = this.prototype.proxy = a;
            return a
        },
        getProxy: function() {
            return this.proxy
        },
        load: function(f, c) {
            c = Ext.apply({},
            c);
            c = Ext.applyIf(c, {
                action: "read",
                id: f
            });
            var b = Ext.create("Ext.data.Operation", c),
            d = c.scope || this,
            a = null,
            e;
            e = function(g) {
                if (g.wasSuccessful()) {
                    a = g.getRecords()[0];
                    Ext.callback(c.success, d, [a, g])
                } else {
                    Ext.callback(c.failure, d, [a, g])
                }
                Ext.callback(c.callback, d, [a, g])
            };
            this.proxy.read(b, e, this)
        }
    },
    statics: {
        PREFIX: "ext-record",
        AUTO_ID: 1,
        EDIT: "edit",
        REJECT: "reject",
        COMMIT: "commit",
        id: function(a) {
            var b = [this.PREFIX, "-", this.AUTO_ID++].join("");
            a.phantom = true;
            a.internalId = b;
            return b
        }
    },
    idgen: {
        isGenerator: true,
        type: "default",
        generate: function() {
            return null
        },
        getRecId: function(a) {
            return a.modelName + "-" + a.internalId
        }
    },
    editing: false,
    dirty: false,
    persistenceProperty: "data",
    evented: false,
    isModel: true,
    phantom: false,
    idProperty: "id",
    defaultProxyType: "ajax",
    constructor: function(f, b, l) {
        f = f || {};
        var j = this,
        h, c, k, a, e, d, g = Ext.isArray(f),
        m = g ? {}: null;
        j.internalId = (b || b === 0) ? b: Ext.data.Model.id(j);
        j.raw = l;
        Ext.applyIf(j, {
            data: {}
        });
        j.modified = {};
        if (j.persistanceProperty) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Ext.data.Model: persistanceProperty has been deprecated. Use persistenceProperty instead.")
            }
            j.persistenceProperty = j.persistanceProperty
        }
        j[j.persistenceProperty] = {};
        j.mixins.observable.constructor.call(j);
        h = j.fields.items;
        c = h.length;
        for (e = 0; e < c; e++) {
            k = h[e];
            a = k.name;
            if (g) {
                m[a] = f[e]
            } else {
                if (f[a] === undefined) {
                    f[a] = k.defaultValue
                }
            }
        }
        j.set(m || f);
        if (j.getId()) {
            j.phantom = false
        } else {
            if (j.phantom) {
                d = j.idgen.generate();
                if (d !== null) {
                    j.setId(d)
                }
            }
        }
        j.dirty = false;
        j.modified = {};
        if (typeof j.init == "function") {
            j.init()
        }
        j.id = j.idgen.getRecId(j)
    },
    get: function(a) {
        return this[this.persistenceProperty][a]
    },
    set: function(n, j) {
        var g = this,
        e = g.fields,
        m = g.modified,
        d = [],
        h,
        l,
        c,
        k,
        b,
        f,
        a;
        if (arguments.length == 1 && Ext.isObject(n)) {
            b = !g.editing;
            f = 0;
            for (l in n) {
                if (n.hasOwnProperty(l)) {
                    h = e.get(l);
                    if (h && h.convert !== h.type.convert) {
                        d.push(l);
                        continue
                    }
                    if (!f && b) {
                        g.beginEdit()
                    }++f;
                    g.set(l, n[l])
                }
            }
            a = d.length;
            if (a) {
                if (!f && b) {
                    g.beginEdit()
                }
                f += a;
                for (c = 0; c < a; c++) {
                    h = d[c];
                    g.set(h, n[h])
                }
            }
            if (b && f) {
                g.endEdit()
            }
        } else {
            if (e) {
                h = e.get(n);
                if (h && h.convert) {
                    j = h.convert(j, g)
                }
            }
            k = g.get(n);
            g[g.persistenceProperty][n] = j;
            if (h && h.persist && !g.isEqual(k, j)) {
                if (g.isModified(n)) {
                    if (g.isEqual(m[n], j)) {
                        delete m[n];
                        g.dirty = false;
                        for (l in m) {
                            if (m.hasOwnProperty(l)) {
                                g.dirty = true;
                                break
                            }
                        }
                    }
                } else {
                    g.dirty = true;
                    m[n] = k
                }
            }
            if (!g.editing) {
                g.afterEdit()
            }
        }
    },
    isEqual: function(d, c) {
        if (Ext.isDate(d) && Ext.isDate(c)) {
            return d.getTime() === c.getTime()
        }
        return d === c
    },
    beginEdit: function() {
        var a = this;
        if (!a.editing) {
            a.editing = true;
            a.dirtySave = a.dirty;
            a.dataSave = Ext.apply({},
            a[a.persistenceProperty]);
            a.modifiedSave = Ext.apply({},
            a.modified)
        }
    },
    cancelEdit: function() {
        var a = this;
        if (a.editing) {
            a.editing = false;
            a.modified = a.modifiedSave;
            a[a.persistenceProperty] = a.dataSave;
            a.dirty = a.dirtySave;
            delete a.modifiedSave;
            delete a.dataSave;
            delete a.dirtySave
        }
    },
    endEdit: function(a) {
        var b = this,
        c;
        if (b.editing) {
            b.editing = false;
            c = b.dirty || b.changedWhileEditing();
            delete b.modifiedSave;
            delete b.dataSave;
            delete b.dirtySave;
            if (a !== true && c) {
                b.afterEdit()
            }
        }
    },
    changedWhileEditing: function() {
        var c = this,
        b = c.dataSave,
        d = c[c.persistenceProperty],
        a;
        for (a in d) {
            if (d.hasOwnProperty(a)) {
                if (!c.isEqual(d[a], b[a])) {
                    return true
                }
            }
        }
        return false
    },
    getChanges: function() {
        var a = this.modified,
        b = {},
        c;
        for (c in a) {
            if (a.hasOwnProperty(c)) {
                b[c] = this.get(c)
            }
        }
        return b
    },
    isModified: function(a) {
        return this.modified.hasOwnProperty(a)
    },
    setDirty: function() {
        var b = this,
        a;
        b.dirty = true;
        b.fields.each(function(c) {
            if (c.persist) {
                a = c.name;
                b.modified[a] = b.get(a)
            }
        },
        b)
    },
    markDirty: function() {
        if (Ext.isDefined(Ext.global.console)) {
            Ext.global.console.warn("Ext.data.Model: markDirty has been deprecated. Use setDirty instead.")
        }
        return this.setDirty.apply(this, arguments)
    },
    reject: function(a) {
        var c = this,
        b = c.modified,
        d;
        for (d in b) {
            if (b.hasOwnProperty(d)) {
                if (typeof b[d] != "function") {
                    c[c.persistenceProperty][d] = b[d]
                }
            }
        }
        c.dirty = false;
        c.editing = false;
        c.modified = {};
        if (a !== true) {
            c.afterReject()
        }
    },
    commit: function(a) {
        var b = this;
        b.phantom = b.dirty = b.editing = false;
        b.modified = {};
        if (a !== true) {
            b.afterCommit()
        }
    },
    copy: function(a) {
        var b = this;
        return new b.self(Ext.apply({},
        b[b.persistenceProperty]), a || b.internalId)
    },
    setProxy: function(a) {
        if (!a.isProxy) {
            if (typeof a === "string") {
                a = {
                    type: a
                }
            }
            a = Ext.createByAlias("proxy." + a.type, a)
        }
        a.setModel(this.self);
        this.proxy = a;
        return a
    },
    getProxy: function() {
        return this.proxy
    },
    validate: function() {
        var j = Ext.create("Ext.data.Errors"),
        c = this.validations,
        e = Ext.data.validations,
        b,
        d,
        h,
        a,
        g,
        f;
        if (c) {
            b = c.length;
            for (f = 0; f < b; f++) {
                d = c[f];
                h = d.field || d.name;
                g = d.type;
                a = e[g](d, this.get(h));
                if (!a) {
                    j.add({
                        field: h,
                        message: d.message || e[g + "Message"]
                    })
                }
            }
        }
        return j
    },
    isValid: function() {
        return this.validate().isValid()
    },
    save: function(c) {
        c = Ext.apply({},
        c);
        var e = this,
        f = e.phantom ? "create": "update",
        a = null,
        d = c.scope || e,
        b,
        g;
        Ext.apply(c, {
            records: [e],
            action: f
        });
        b = Ext.create("Ext.data.Operation", c);
        g = function(h) {
            if (h.wasSuccessful()) {
                a = h.getRecords()[0];
                e.set(a.data);
                a.dirty = false;
                Ext.callback(c.success, d, [a, h])
            } else {
                Ext.callback(c.failure, d, [a, h])
            }
            Ext.callback(c.callback, d, [a, h])
        };
        e.getProxy()[f](b, g, e);
        return e
    },
    destroy: function(c) {
        c = Ext.apply({},
        c);
        var e = this,
        a = null,
        d = c.scope || e,
        b, f;
        Ext.apply(c, {
            records: [e],
            action: "destroy"
        });
        b = Ext.create("Ext.data.Operation", c);
        f = function(g) {
            if (g.wasSuccessful()) {
                Ext.callback(c.success, d, [a, g])
            } else {
                Ext.callback(c.failure, d, [a, g])
            }
            Ext.callback(c.callback, d, [a, g])
        };
        e.getProxy().destroy(b, f, e);
        return e
    },
    getId: function() {
        return this.get(this.idProperty)
    },
    setId: function(a) {
        this.set(this.idProperty, a)
    },
    join: function(a) {
        this.store = a
    },
    unjoin: function(a) {
        delete this.store
    },
    afterEdit: function() {
        this.callStore("afterEdit")
    },
    afterReject: function() {
        this.callStore("afterReject")
    },
    afterCommit: function() {
        this.callStore("afterCommit")
    },
    callStore: function(b) {
        var a = this.store;
        if (a !== undefined && typeof a[b] == "function") {
            a[b](this)
        }
    },
    getAssociatedData: function() {
        return this.prepareAssociatedData(this, [], null)
    },
    prepareAssociatedData: function(p, b, o) {
        var k = p.associations.items,
        m = k.length,
        f = {},
        g, a, h, r, s, e, d, n, l, q, c;
        for (n = 0; n < m; n++) {
            e = k[n];
            q = e.type;
            c = true;
            if (o) {
                c = q == o
            }
            if (c && q == "hasMany") {
                g = p[e.storeName];
                f[e.name] = [];
                if (g && g.data.length > 0) {
                    h = g.data.items;
                    s = h.length;
                    for (l = 0; l < s; l++) {
                        r = h[l];
                        d = r.id;
                        if (Ext.Array.indexOf(b, d) == -1) {
                            b.push(d);
                            f[e.name][l] = r.data;
                            Ext.apply(f[e.name][l], this.prepareAssociatedData(r, b, q))
                        }
                    }
                }
            } else {
                if (c && q == "belongsTo") {
                    r = p[e.instanceName];
                    if (r !== undefined) {
                        d = r.id;
                        if (Ext.Array.indexOf(b, d) == -1) {
                            b.push(d);
                            f[e.name] = r.data;
                            Ext.apply(f[e.name], this.prepareAssociatedData(r, b, q))
                        }
                    }
                }
            }
        }
        return f
    }
});
Ext.define("Ext.dd.DragDrop", {
    requires: ["Ext.dd.DragDropManager"],
    constructor: function(c, a, b) {
        if (c) {
            this.init(c, a, b)
        }
    },
    id: null,
    config: null,
    dragElId: null,
    handleElId: null,
    invalidHandleTypes: null,
    invalidHandleIds: null,
    invalidHandleClasses: null,
    startPageX: 0,
    startPageY: 0,
    groups: null,
    locked: false,
    lock: function() {
        this.locked = true
    },
    moveOnly: false,
    unlock: function() {
        this.locked = false
    },
    isTarget: true,
    padding: null,
    _domRef: null,
    __ygDragDrop: true,
    constrainX: false,
    constrainY: false,
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0,
    maintainOffset: false,
    xTicks: null,
    yTicks: null,
    primaryButtonOnly: true,
    available: false,
    hasOuterHandles: false,
    b4StartDrag: function(a, b) {},
    startDrag: function(a, b) {},
    b4Drag: function(a) {},
    onDrag: function(a) {},
    onDragEnter: function(a, b) {},
    b4DragOver: function(a) {},
    onDragOver: function(a, b) {},
    b4DragOut: function(a) {},
    onDragOut: function(a, b) {},
    b4DragDrop: function(a) {},
    onDragDrop: function(a, b) {},
    onInvalidDrop: function(a) {},
    b4EndDrag: function(a) {},
    endDrag: function(a) {},
    b4MouseDown: function(a) {},
    onMouseDown: function(a) {},
    onMouseUp: function(a) {},
    onAvailable: function() {},
    defaultPadding: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    },
    constrainTo: function(h, f, n) {
        if (Ext.isNumber(f)) {
            f = {
                left: f,
                right: f,
                top: f,
                bottom: f
            }
        }
        f = f || this.defaultPadding;
        var k = Ext.get(this.getEl()).getBox(),
        a = Ext.get(h),
        m = a.getScroll(),
        j,
        d = a.dom;
        if (d == document.body) {
            j = {
                x: m.left,
                y: m.top,
                width: Ext.Element.getViewWidth(),
                height: Ext.Element.getViewHeight()
            }
        } else {
            var l = a.getXY();
            j = {
                x: l[0],
                y: l[1],
                width: d.clientWidth,
                height: d.clientHeight
            }
        }
        var g = k.y - j.y,
        e = k.x - j.x;
        this.resetConstraints();
        this.setXConstraint(e - (f.left || 0), j.width - e - k.width - (f.right || 0), this.xTickSize);
        this.setYConstraint(g - (f.top || 0), j.height - g - k.height - (f.bottom || 0), this.yTickSize)
    },
    getEl: function() {
        if (!this._domRef) {
            this._domRef = Ext.getDom(this.id)
        }
        return this._domRef
    },
    getDragEl: function() {
        return Ext.getDom(this.dragElId)
    },
    init: function(c, a, b) {
        this.initTarget(c, a, b);
        Ext.EventManager.on(this.id, "mousedown", this.handleMouseDown, this)
    },
    initTarget: function(c, a, b) {
        this.config = b || {};
        this.DDMInstance = Ext.dd.DragDropManager;
        this.groups = {};
        if (typeof c !== "string") {
            c = Ext.id(c)
        }
        this.id = c;
        this.addToGroup((a) ? a: "default");
        this.handleElId = c;
        this.setDragElId(c);
        this.invalidHandleTypes = {
            A: "A"
        };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];
        this.applyConfig();
        this.handleOnAvailable()
    },
    applyConfig: function() {
        this.padding = this.config.padding || [0, 0, 0, 0];
        this.isTarget = (this.config.isTarget !== false);
        this.maintainOffset = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false)
    },
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable()
    },
    setPadding: function(c, a, d, b) {
        if (!a && 0 !== a) {
            this.padding = [c, c, c, c]
        } else {
            if (!d && 0 !== d) {
                this.padding = [c, a, c, a]
            } else {
                this.padding = [c, a, d, b]
            }
        }
    },
    setInitPosition: function(d, c) {
        var e = this.getEl();
        if (!this.DDMInstance.verifyEl(e)) {
            return
        }
        var b = d || 0;
        var a = c || 0;
        var f = Ext.Element.getXY(e);
        this.initPageX = f[0] - b;
        this.initPageY = f[1] - a;
        this.lastPageX = f[0];
        this.lastPageY = f[1];
        this.setStartPosition(f)
    },
    setStartPosition: function(b) {
        var a = b || Ext.Element.getXY(this.getEl());
        this.deltaSetXY = null;
        this.startPageX = a[0];
        this.startPageY = a[1]
    },
    addToGroup: function(a) {
        this.groups[a] = true;
        this.DDMInstance.regDragDrop(this, a)
    },
    removeFromGroup: function(a) {
        if (this.groups[a]) {
            delete this.groups[a]
        }
        this.DDMInstance.removeDDFromGroup(this, a)
    },
    setDragElId: function(a) {
        this.dragElId = a
    },
    setHandleElId: function(a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        this.handleElId = a;
        this.DDMInstance.regHandle(this.id, a)
    },
    setOuterHandleElId: function(a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        Ext.EventManager.on(a, "mousedown", this.handleMouseDown, this);
        this.setHandleElId(a);
        this.hasOuterHandles = true
    },
    unreg: function() {
        Ext.EventManager.un(this.id, "mousedown", this.handleMouseDown, this);
        this._domRef = null;
        this.DDMInstance._remove(this)
    },
    destroy: function() {
        this.unreg()
    },
    isLocked: function() {
        return (this.DDMInstance.isLocked() || this.locked)
    },
    handleMouseDown: function(c, b) {
        if (this.primaryButtonOnly && c.button != 0) {
            return
        }
        if (this.isLocked()) {
            return
        }
        this.DDMInstance.refreshCache(this.groups);
        var a = c.getPoint();
        if (!this.hasOuterHandles && !this.DDMInstance.isOverTarget(a, this)) {} else {
            if (this.clickValidator(c)) {
                this.setStartPosition();
                this.b4MouseDown(c);
                this.onMouseDown(c);
                this.DDMInstance.handleMouseDown(c, this);
                this.DDMInstance.stopEvent(c)
            } else {}
        }
    },
    clickValidator: function(b) {
        var a = b.getTarget();
        return (this.isValidHandleChild(a) && (this.id == this.handleElId || this.DDMInstance.handleWasClicked(a, this.id)))
    },
    addInvalidHandleType: function(a) {
        var b = a.toUpperCase();
        this.invalidHandleTypes[b] = b
    },
    addInvalidHandleId: function(a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        this.invalidHandleIds[a] = a
    },
    addInvalidHandleClass: function(a) {
        this.invalidHandleClasses.push(a)
    },
    removeInvalidHandleType: function(a) {
        var b = a.toUpperCase();
        delete this.invalidHandleTypes[b]
    },
    removeInvalidHandleId: function(a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        delete this.invalidHandleIds[a]
    },
    removeInvalidHandleClass: function(b) {
        for (var c = 0,
        a = this.invalidHandleClasses.length; c < a; ++c) {
            if (this.invalidHandleClasses[c] == b) {
                delete this.invalidHandleClasses[c]
            }
        }
    },
    isValidHandleChild: function(d) {
        var c = true;
        var g;
        try {
            g = d.nodeName.toUpperCase()
        } catch(f) {
            g = d.nodeName
        }
        c = c && !this.invalidHandleTypes[g];
        c = c && !this.invalidHandleIds[d.id];
        for (var b = 0,
        a = this.invalidHandleClasses.length; c && b < a; ++b) {
            c = !Ext.fly(d).hasCls(this.invalidHandleClasses[b])
        }
        return c
    },
    setXTicks: function(d, a) {
        this.xTicks = [];
        this.xTickSize = a;
        var c = {};
        for (var b = this.initPageX; b >= this.minX; b = b - a) {
            if (!c[b]) {
                this.xTicks[this.xTicks.length] = b;
                c[b] = true
            }
        }
        for (b = this.initPageX; b <= this.maxX; b = b + a) {
            if (!c[b]) {
                this.xTicks[this.xTicks.length] = b;
                c[b] = true
            }
        }
        Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort)
    },
    setYTicks: function(d, a) {
        this.yTicks = [];
        this.yTickSize = a;
        var c = {};
        for (var b = this.initPageY; b >= this.minY; b = b - a) {
            if (!c[b]) {
                this.yTicks[this.yTicks.length] = b;
                c[b] = true
            }
        }
        for (b = this.initPageY; b <= this.maxY; b = b + a) {
            if (!c[b]) {
                this.yTicks[this.yTicks.length] = b;
                c[b] = true
            }
        }
        Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort)
    },
    setXConstraint: function(c, b, a) {
        this.leftConstraint = c;
        this.rightConstraint = b;
        this.minX = this.initPageX - c;
        this.maxX = this.initPageX + b;
        if (a) {
            this.setXTicks(this.initPageX, a)
        }
        this.constrainX = true
    },
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks()
    },
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0
    },
    setYConstraint: function(a, c, b) {
        this.topConstraint = a;
        this.bottomConstraint = c;
        this.minY = this.initPageY - a;
        this.maxY = this.initPageY + c;
        if (b) {
            this.setYTicks(this.initPageY, b)
        }
        this.constrainY = true
    },
    resetConstraints: function() {
        if (this.initPageX || this.initPageX === 0) {
            var b = (this.maintainOffset) ? this.lastPageX - this.initPageX: 0;
            var a = (this.maintainOffset) ? this.lastPageY - this.initPageY: 0;
            this.setInitPosition(b, a)
        } else {
            this.setInitPosition()
        }
        if (this.constrainX) {
            this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize)
        }
        if (this.constrainY) {
            this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize)
        }
    },
    getTick: function(g, d) {
        if (!d) {
            return g
        } else {
            if (d[0] >= g) {
                return d[0]
            } else {
                for (var b = 0,
                a = d.length; b < a; ++b) {
                    var c = b + 1;
                    if (d[c] && d[c] >= g) {
                        var f = g - d[b];
                        var e = d[c] - g;
                        return (e > f) ? d[b] : d[c]
                    }
                }
                return d[d.length - 1]
            }
        }
    },
    toString: function() {
        return ("DragDrop " + this.id)
    }
});
Ext.define("Ext.dd.DD", {
    extend: "Ext.dd.DragDrop",
    requires: ["Ext.dd.DragDropManager"],
    constructor: function(c, a, b) {
        if (c) {
            this.init(c, a, b)
        }
    },
    scroll: true,
    autoOffset: function(c, b) {
        var a = c - this.startPageX;
        var d = b - this.startPageY;
        this.setDelta(a, d)
    },
    setDelta: function(b, a) {
        this.deltaX = b;
        this.deltaY = a
    },
    setDragElPos: function(c, b) {
        var a = this.getDragEl();
        this.alignElWithMouse(a, c, b)
    },
    alignElWithMouse: function(b, e, c) {
        var f = this.getTargetCoord(e, c),
        d = b.dom ? b: Ext.fly(b, "_dd"),
        l = d.getSize(),
        h = Ext.Element,
        j;
        if (!this.deltaSetXY) {
            j = this.cachedViewportSize = {
                width: h.getDocumentWidth(),
                height: h.getDocumentHeight()
            };
            var a = [Math.max(0, Math.min(f.x, j.width - l.width)), Math.max(0, Math.min(f.y, j.height - l.height))];
            d.setXY(a);
            var k = d.getLeft(true);
            var g = d.getTop(true);
            this.deltaSetXY = [k - f.x, g - f.y]
        } else {
            j = this.cachedViewportSize;
            d.setLeftTop(Math.max(0, Math.min(f.x + this.deltaSetXY[0], j.width - l.width)), Math.max(0, Math.min(f.y + this.deltaSetXY[1], j.height - l.height)))
        }
        this.cachePosition(f.x, f.y);
        this.autoScroll(f.x, f.y, b.offsetHeight, b.offsetWidth);
        return f
    },
    cachePosition: function(b, a) {
        if (b) {
            this.lastPageX = b;
            this.lastPageY = a
        } else {
            var c = Ext.Element.getXY(this.getEl());
            this.lastPageX = c[0];
            this.lastPageY = c[1]
        }
    },
    autoScroll: function(l, k, e, m) {
        if (this.scroll) {
            var n = Ext.Element.getViewHeight();
            var b = Ext.Element.getViewWidth();
            var p = this.DDMInstance.getScrollTop();
            var d = this.DDMInstance.getScrollLeft();
            var j = e + k;
            var o = m + l;
            var g = (n + p - k - this.deltaY);
            var f = (b + d - l - this.deltaX);
            var c = 40;
            var a = (document.all) ? 80 : 30;
            if (j > n && g < c) {
                window.scrollTo(d, p + a)
            }
            if (k < p && p > 0 && k - p < c) {
                window.scrollTo(d, p - a)
            }
            if (o > b && f < c) {
                window.scrollTo(d + a, p)
            }
            if (l < d && d > 0 && l - d < c) {
                window.scrollTo(d - a, p)
            }
        }
    },
    getTargetCoord: function(c, b) {
        var a = c - this.deltaX;
        var d = b - this.deltaY;
        if (this.constrainX) {
            if (a < this.minX) {
                a = this.minX
            }
            if (a > this.maxX) {
                a = this.maxX
            }
        }
        if (this.constrainY) {
            if (d < this.minY) {
                d = this.minY
            }
            if (d > this.maxY) {
                d = this.maxY
            }
        }
        a = this.getTick(a, this.xTicks);
        d = this.getTick(d, this.yTicks);
        return {
            x: a,
            y: d
        }
    },
    applyConfig: function() {
        this.callParent();
        this.scroll = (this.config.scroll !== false)
    },
    b4MouseDown: function(a) {
        this.autoOffset(a.getPageX(), a.getPageY())
    },
    b4Drag: function(a) {
        this.setDragElPos(a.getPageX(), a.getPageY())
    },
    toString: function() {
        return ("DD " + this.id)
    }
});
Ext.define("Ext.dd.DDProxy", {
    extend: "Ext.dd.DD",
    statics: {
        dragElId: "ygddfdiv"
    },
    constructor: function(c, a, b) {
        if (c) {
            this.init(c, a, b);
            this.initFrame()
        }
    },
    resizeFrame: true,
    centerFrame: false,
    createFrame: function() {
        var b = this;
        var a = document.body;
        if (!a || !a.firstChild) {
            setTimeout(function() {
                b.createFrame()
            },
            50);
            return
        }
        var d = this.getDragEl();
        if (!d) {
            d = document.createElement("div");
            d.id = this.dragElId;
            var c = d.style;
            c.position = "absolute";
            c.visibility = "hidden";
            c.cursor = "move";
            c.border = "2px solid #aaa";
            c.zIndex = 999;
            a.insertBefore(d, a.firstChild)
        }
    },
    initFrame: function() {
        this.createFrame()
    },
    applyConfig: function() {
        this.callParent();
        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId)
    },
    showFrame: function(e, d) {
        var c = this.getEl();
        var a = this.getDragEl();
        var b = a.style;
        this._resizeProxy();
        if (this.centerFrame) {
            this.setDelta(Math.round(parseInt(b.width, 10) / 2), Math.round(parseInt(b.height, 10) / 2))
        }
        this.setDragElPos(e, d);
        Ext.fly(a).show()
    },
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var a = this.getEl();
            Ext.fly(this.getDragEl()).setSize(a.offsetWidth, a.offsetHeight)
        }
    },
    b4MouseDown: function(b) {
        var a = b.getPageX();
        var c = b.getPageY();
        this.autoOffset(a, c);
        this.setDragElPos(a, c)
    },
    b4StartDrag: function(a, b) {
        this.showFrame(a, b)
    },
    b4EndDrag: function(a) {
        Ext.fly(this.getDragEl()).hide()
    },
    endDrag: function(c) {
        var b = this.getEl();
        var a = this.getDragEl();
        a.style.visibility = "";
        this.beforeMove();
        b.style.visibility = "hidden";
        Ext.dd.DDM.moveToEl(b, a);
        a.style.visibility = "hidden";
        b.style.visibility = "";
        this.afterDrag()
    },
    beforeMove: function() {},
    afterDrag: function() {},
    toString: function() {
        return ("DDProxy " + this.id)
    }
});
Ext.define("Ext.dd.DragSource", {
    extend: "Ext.dd.DDProxy",
    requires: ["Ext.dd.StatusProxy", "Ext.dd.DragDropManager"],
    dropAllowed: Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    animRepair: true,
    repairHighlightColor: "c3daf9",
    constructor: function(b, a) {
        this.el = Ext.get(b);
        if (!this.dragData) {
            this.dragData = {}
        }
        Ext.apply(this, a);
        if (!this.proxy) {
            this.proxy = Ext.create("Ext.dd.StatusProxy", {
                animRepair: this.animRepair
            })
        }
        this.callParent([this.el.dom, this.ddGroup || this.group, {
            dragElId: this.proxy.id,
            resizeFrame: false,
            isTarget: false,
            scroll: this.scroll === true
        }]);
        this.dragging = false
    },
    getDragData: function(a) {
        return this.dragData
    },
    onDragEnter: function(c, d) {
        var b = Ext.dd.DragDropManager.getDDById(d);
        this.cachedTarget = b;
        if (this.beforeDragEnter(b, c, d) !== false) {
            if (b.isNotifyTarget) {
                var a = b.notifyEnter(this, c, this.dragData);
                this.proxy.setStatus(a)
            } else {
                this.proxy.setStatus(this.dropAllowed)
            }
            if (this.afterDragEnter) {
                this.afterDragEnter(b, c, d)
            }
        }
    },
    beforeDragEnter: function(b, a, c) {
        return true
    },
    alignElWithMouse: function() {
        this.callParent(arguments);
        this.proxy.sync()
    },
    onDragOver: function(c, d) {
        var b = this.cachedTarget || Ext.dd.DragDropManager.getDDById(d);
        if (this.beforeDragOver(b, c, d) !== false) {
            if (b.isNotifyTarget) {
                var a = b.notifyOver(this, c, this.dragData);
                this.proxy.setStatus(a)
            }
            if (this.afterDragOver) {
                this.afterDragOver(b, c, d)
            }
        }
    },
    beforeDragOver: function(b, a, c) {
        return true
    },
    onDragOut: function(b, c) {
        var a = this.cachedTarget || Ext.dd.DragDropManager.getDDById(c);
        if (this.beforeDragOut(a, b, c) !== false) {
            if (a.isNotifyTarget) {
                a.notifyOut(this, b, this.dragData)
            }
            this.proxy.reset();
            if (this.afterDragOut) {
                this.afterDragOut(a, b, c)
            }
        }
        this.cachedTarget = null
    },
    beforeDragOut: function(b, a, c) {
        return true
    },
    onDragDrop: function(b, c) {
        var a = this.cachedTarget || Ext.dd.DragDropManager.getDDById(c);
        if (this.beforeDragDrop(a, b, c) !== false) {
            if (a.isNotifyTarget) {
                if (a.notifyDrop(this, b, this.dragData) !== false) {
                    this.onValidDrop(a, b, c)
                } else {
                    this.onInvalidDrop(a, b, c)
                }
            } else {
                this.onValidDrop(a, b, c)
            }
            if (this.afterDragDrop) {
                this.afterDragDrop(a, b, c)
            }
        }
        delete this.cachedTarget
    },
    beforeDragDrop: function(b, a, c) {
        return true
    },
    onValidDrop: function(b, a, c) {
        this.hideProxy();
        if (this.afterValidDrop) {
            this.afterValidDrop(b, a, c)
        }
    },
    getRepairXY: function(b, a) {
        return this.el.getXY()
    },
    onInvalidDrop: function(b, a, c) {
        this.beforeInvalidDrop(b, a, c);
        if (this.cachedTarget) {
            if (this.cachedTarget.isNotifyTarget) {
                this.cachedTarget.notifyOut(this, a, this.dragData)
            }
            this.cacheTarget = null
        }
        this.proxy.repair(this.getRepairXY(a, this.dragData), this.afterRepair, this);
        if (this.afterInvalidDrop) {
            this.afterInvalidDrop(a, c)
        }
    },
    afterRepair: function() {
        var a = this;
        if (Ext.enableFx) {
            a.el.highlight(a.repairHighlightColor)
        }
        a.dragging = false
    },
    beforeInvalidDrop: function(b, a, c) {
        return true
    },
    handleMouseDown: function(b) {
        if (this.dragging) {
            return
        }
        var a = this.getDragData(b);
        if (a && this.onBeforeDrag(a, b) !== false) {
            this.dragData = a;
            this.proxy.stop();
            this.callParent(arguments)
        }
    },
    onBeforeDrag: function(a, b) {
        return true
    },
    onStartDrag: Ext.emptyFn,
    startDrag: function(a, b) {
        this.proxy.reset();
        this.dragging = true;
        this.proxy.update("");
        this.onInitDrag(a, b);
        this.proxy.show()
    },
    onInitDrag: function(a, c) {
        var b = this.el.dom.cloneNode(true);
        b.id = Ext.id();
        this.proxy.update(b);
        this.onStartDrag(a, c);
        return true
    },
    getProxy: function() {
        return this.proxy
    },
    hideProxy: function() {
        this.proxy.hide();
        this.proxy.reset(true);
        this.dragging = false
    },
    triggerCacheRefresh: function() {
        Ext.dd.DDM.refreshCache(this.groups)
    },
    b4EndDrag: function(a) {},
    endDrag: function(a) {
        this.onEndDrag(this.dragData, a)
    },
    onEndDrag: function(a, b) {},
    autoOffset: function(a, b) {
        this.setDelta( - 12, -20)
    },
    destroy: function() {
        this.callParent();
        Ext.destroy(this.proxy)
    }
});
Ext.define("Ext.panel.DD", {
    extend: "Ext.dd.DragSource",
    requires: ["Ext.panel.Proxy"],
    constructor: function(b, a) {
        this.panel = b;
        this.dragData = {
            panel: b
        };
        this.proxy = Ext.create("Ext.panel.Proxy", b, a);
        this.callParent([b.el, a]);
        Ext.defer(function() {
            var d = b.header,
            c = b.body;
            if (d) {
                this.setHandleElId(d.id);
                c = d.el
            }
            c.setStyle("cursor", "move");
            this.scroll = false
        },
        200, this)
    },
    showFrame: Ext.emptyFn,
    startDrag: Ext.emptyFn,
    b4StartDrag: function(a, b) {
        this.proxy.show()
    },
    b4MouseDown: function(b) {
        var a = b.getPageX(),
        c = b.getPageY();
        this.autoOffset(a, c)
    },
    onInitDrag: function(a, b) {
        this.onStartDrag(a, b);
        return true
    },
    createFrame: Ext.emptyFn,
    getDragEl: function(a) {
        return this.proxy.ghost.el.dom
    },
    endDrag: function(a) {
        this.proxy.hide();
        this.panel.saveState()
    },
    autoOffset: function(a, b) {
        a -= this.startPageX;
        b -= this.startPageY;
        this.setDelta(a, b)
    }
});
Ext.define("Ext.panel.Panel", {
    extend: "Ext.panel.AbstractPanel",
    requires: ["Ext.panel.Header", "Ext.fx.Anim", "Ext.util.KeyMap", "Ext.panel.DD", "Ext.XTemplate", "Ext.layout.component.Dock", "Ext.util.Memento"],
    alias: "widget.panel",
    alternateClassName: "Ext.Panel",
    collapsedCls: "collapsed",
    animCollapse: Ext.enableFx,
    minButtonWidth: 75,
    collapsed: false,
    collapseFirst: true,
    hideCollapseTool: false,
    titleCollapse: false,
    floatable: true,
    collapsible: false,
    closable: false,
    closeAction: "destroy",
    preventHeader: false,
    headerPosition: "top",
    frame: false,
    frameHeader: true,
    initComponent: function() {
        var b = this,
        a;
        b.addEvents("beforeclose", "beforeexpand", "beforecollapse", "expand", "collapse", "titlechange", "iconchange");
        this.addStateEvents("expand", "collapse");
        if (b.unstyled) {
            b.setUI("plain")
        }
        if (b.frame) {
            b.setUI(b.ui + "-framed")
        }
        b.bridgeToolbars();
        b.callParent();
        b.collapseDirection = b.collapseDirection || b.headerPosition || Ext.Component.DIRECTION_TOP
    },
    setBorder: function(a) {
        this.callParent(arguments)
    },
    beforeDestroy: function() {
        Ext.destroy(this.ghostPanel, this.dd);
        this.callParent()
    },
    initAria: function() {
        this.callParent();
        this.initHeaderAria()
    },
    initHeaderAria: function() {
        var b = this,
        a = b.el,
        c = b.header;
        if (a && c) {
            a.dom.setAttribute("aria-labelledby", c.titleCmp.id)
        }
    },
    getHeader: function() {
        return this.header
    },
    setTitle: function(c) {
        var b = this,
        a = this.title;
        b.title = c;
        if (b.header) {
            b.header.setTitle(c)
        } else {
            b.updateHeader()
        }
        if (b.reExpander) {
            b.reExpander.setTitle(c)
        }
        b.fireEvent("titlechange", b, c, a)
    },
    setIconCls: function(a) {
        var c = this,
        b = c.iconCls;
        c.iconCls = a;
        var d = c.header;
        if (d) {
            d.setIconCls(a)
        }
        c.fireEvent("iconchange", c, a, b)
    },
    bridgeToolbars: function() {
        var a = this,
        f = [],
        c,
        b,
        e = a.minButtonWidth;
        function d(g, j, h) {
            if (Ext.isArray(g)) {
                g = {
                    xtype: "toolbar",
                    items: g
                }
            } else {
                if (!g.xtype) {
                    g.xtype = "toolbar"
                }
            }
            g.dock = j;
            if (j == "left" || j == "right") {
                g.vertical = true
            }
            if (h) {
                g.layout = Ext.applyIf(g.layout || {},
                {
                    pack: {
                        left: "start",
                        center: "center"
                    } [a.buttonAlign] || "end"
                })
            }
            return g
        }
        if (a.tbar) {
            f.push(d(a.tbar, "top"));
            a.tbar = null
        }
        if (a.bbar) {
            f.push(d(a.bbar, "bottom"));
            a.bbar = null
        }
        if (a.buttons) {
            a.fbar = a.buttons;
            a.buttons = null
        }
        if (a.fbar) {
            c = d(a.fbar, "bottom", true);
            c.ui = "footer";
            if (e) {
                b = c.defaults;
                c.defaults = function(g) {
                    var h = b || {};
                    if ((!g.xtype || g.xtype === "button" || (g.isComponent && g.isXType("button"))) && !("minWidth" in h)) {
                        h = Ext.apply({
                            minWidth: e
                        },
                        h)
                    }
                    return h
                }
            }
            f.push(c);
            a.fbar = null
        }
        if (a.lbar) {
            f.push(d(a.lbar, "left"));
            a.lbar = null
        }
        if (a.rbar) {
            f.push(d(a.rbar, "right"));
            a.rbar = null
        }
        if (a.dockedItems) {
            if (!Ext.isArray(a.dockedItems)) {
                a.dockedItems = [a.dockedItems]
            }
            a.dockedItems = a.dockedItems.concat(f)
        } else {
            a.dockedItems = f
        }
    },
    initTools: function() {
        var a = this;
        a.tools = a.tools ? Ext.Array.clone(a.tools) : [];
        if (a.collapsible && !(a.hideCollapseTool || a.header === false)) {
            a.collapseDirection = a.collapseDirection || a.headerPosition || "top";
            a.collapseTool = a.expandTool = a.createComponent({
                xtype: "tool",
                type: "collapse-" + a.collapseDirection,
                expandType: a.getOppositeDirection(a.collapseDirection),
                handler: a.toggleCollapse,
                scope: a
            });
            if (a.collapseFirst) {
                a.tools.unshift(a.collapseTool)
            }
        }
        a.addTools();
        if (a.closable) {
            a.addClsWithUI("closable");
            a.addTool({
                type: "close",
                handler: Ext.Function.bind(a.close, this, [])
            })
        }
        if (a.collapseTool && !a.collapseFirst) {
            a.tools.push(a.collapseTool)
        }
    },
    addTools: Ext.emptyFn,
    close: function() {
        if (this.fireEvent("beforeclose", this) !== false) {
            this.doClose()
        }
    },
    doClose: function() {
        this.fireEvent("close", this);
        this[this.closeAction]()
    },
    onRender: function(b, a) {
        var d = this,
        c;
        d.initTools();
        d.updateHeader();
        d.callParent(arguments)
    },
    afterRender: function() {
        var a = this;
        a.callParent(arguments);
        if (a.collapsed) {
            a.collapsed = false;
            a.collapse(null, false, true)
        }
    },
    updateHeader: function(b) {
        var a = this,
        e = a.header,
        d = a.title,
        c = a.tools;
        if (!a.preventHeader && (b || d || (c && c.length))) {
            if (!e) {
                e = a.header = Ext.create("Ext.panel.Header", {
                    title: d,
                    orientation: (a.headerPosition == "left" || a.headerPosition == "right") ? "vertical": "horizontal",
                    dock: a.headerPosition || "top",
                    textCls: a.headerTextCls,
                    iconCls: a.iconCls,
                    baseCls: a.baseCls + "-header",
                    tools: c,
                    ui: a.ui,
                    indicateDrag: a.draggable,
                    border: a.border,
                    frame: a.frame && a.frameHeader,
                    ignoreParentFrame: a.frame || a.overlapHeader,
                    ignoreBorderManagement: a.frame || a.ignoreHeaderBorderManagement,
                    listeners: a.collapsible && a.titleCollapse ? {
                        click: a.toggleCollapse,
                        scope: a
                    }: null
                });
                a.addDocked(e, 0);
                a.tools = e.tools
            }
            e.show();
            a.initHeaderAria()
        } else {
            if (e) {
                e.hide()
            }
        }
    },
    setUI: function(b) {
        var a = this;
        a.callParent(arguments);
        if (a.header) {
            a.header.setUI(b)
        }
    },
    getContentTarget: function() {
        return this.body
    },
    getTargetEl: function() {
        return this.body || this.frameBody || this.el
    },
    isVisible: function(a) {
        var b = this;
        if (b.collapsed && b.placeholder) {
            return b.placeholder.isVisible(a)
        }
        return b.callParent(arguments)
    },
    onHide: function() {
        var a = this;
        if (a.collapsed && a.placeholder) {
            a.placeholder.hide()
        } else {
            a.callParent(arguments)
        }
    },
    onShow: function() {
        var a = this;
        if (a.collapsed && a.placeholder) {
            a.hidden = true;
            a.placeholder.show()
        } else {
            a.callParent(arguments)
        }
    },
    addTool: function(a) {
        var b = this,
        c = b.header;
        if (Ext.isArray(a)) {
            Ext.each(a, b.addTool, b);
            return
        }
        b.tools.push(a);
        if (c) {
            c.addTool(a)
        }
        b.updateHeader()
    },
    getOppositeDirection: function(a) {
        var b = Ext.Component;
        switch (a) {
        case b.DIRECTION_TOP:
            return b.DIRECTION_BOTTOM;
        case b.DIRECTION_RIGHT:
            return b.DIRECTION_LEFT;
        case b.DIRECTION_BOTTOM:
            return b.DIRECTION_TOP;
        case b.DIRECTION_LEFT:
            return b.DIRECTION_RIGHT
        }
    },
    collapse: function(t, f, h) {
        var u = this,
        s = Ext.Component,
        j = u.getHeight(),
        k = u.getWidth(),
        v,
        a = 0,
        p = u.dockedItems.items,
        q = p.length,
        o = 0,
        r,
        g,
        n = {
            from: {
                height: j,
                width: k
            },
            to: {
                height: j,
                width: k
            },
            listeners: {
                afteranimate: u.afterCollapse,
                scope: u
            },
            duration: Ext.Number.from(f, Ext.fx.Anim.prototype.duration)
        },
        e,
        d,
        l,
        b,
        m;
        if (!t) {
            t = u.collapseDirection
        }
        if (h) {
            f = false
        } else {
            if (u.collapsed || u.fireEvent("beforecollapse", u, t, f) === false) {
                return false
            }
        }
        l = t;
        u.expandDirection = u.getOppositeDirection(t);
        u.hiddenDocked = [];
        switch (t) {
        case s.DIRECTION_TOP:
        case s.DIRECTION_BOTTOM:
            d = "horizontal";
            m = "height";
            b = "getHeight";
            for (; o < q; o++) {
                r = p[o];
                if (r.isVisible()) {
                    if (r.isXType("header", true) && (!r.dock || r.dock == "top" || r.dock == "bottom")) {
                        e = r
                    } else {
                        u.hiddenDocked.push(r)
                    }
                } else {
                    if (r === u.reExpander) {
                        e = r
                    }
                }
            }
            if (t == Ext.Component.DIRECTION_BOTTOM) {
                g = u.getPosition()[1] - Ext.fly(u.el.dom.offsetParent).getRegion().top;
                n.from.top = g
            }
            break;
        case s.DIRECTION_LEFT:
        case s.DIRECTION_RIGHT:
            d = "vertical";
            m = "width";
            b = "getWidth";
            for (; o < q; o++) {
                r = p[o];
                if (r.isVisible()) {
                    if (r.isHeader && (r.dock == "left" || r.dock == "right")) {
                        e = r
                    } else {
                        u.hiddenDocked.push(r)
                    }
                } else {
                    if (r === u.reExpander) {
                        e = r
                    }
                }
            }
            if (t == Ext.Component.DIRECTION_RIGHT) {
                g = u.getPosition()[0] - Ext.fly(u.el.dom.offsetParent).getRegion().left;
                n.from.left = g
            }
            break;
        default:
            throw ("Panel collapse must be passed a valid Component collapse direction")
        }
        if (f && u.collapseTool) {
            u.collapseTool.disable()
        }
        u.addClsWithUI(u.collapsedCls);
        if (e && e.rendered) {
            e.addClsWithUI(u.collapsedCls);
            e.addClsWithUI(u.collapsedCls + "-" + e.dock);
            if (u.border && (!u.frame || (u.frame && Ext.supports.CSS3BorderRadius))) {
                e.addClsWithUI(u.collapsedCls + "-border-" + e.dock)
            }
            v = e.getFrameInfo();
            a = e[b]() + (v ? v[t] : 0);
            e.removeClsWithUI(u.collapsedCls);
            e.removeClsWithUI(u.collapsedCls + "-" + e.dock);
            if (u.border && (!u.frame || (u.frame && Ext.supports.CSS3BorderRadius))) {
                e.removeClsWithUI(u.collapsedCls + "-border-" + e.dock)
            }
        } else {
            e = {
                hideMode: "offsets",
                temporary: true,
                title: u.title,
                orientation: d,
                dock: l,
                textCls: u.headerTextCls,
                iconCls: u.iconCls,
                baseCls: u.baseCls + "-header",
                ui: u.ui,
                frame: u.frame && u.frameHeader,
                ignoreParentFrame: u.frame || u.overlapHeader,
                indicateDrag: u.draggable,
                cls: u.baseCls + "-collapsed-placeholder  " + Ext.baseCSSPrefix + "docked " + u.baseCls + "-" + u.ui + "-collapsed",
                renderTo: u.el
            };
            if (!u.hideCollapseTool) {
                e[(e.orientation == "horizontal") ? "tools": "items"] = [{
                    xtype: "tool",
                    type: "expand-" + u.expandDirection,
                    handler: u.toggleCollapse,
                    scope: u
                }]
            }
            e = u.reExpander = Ext.create("Ext.panel.Header", e);
            a = e[b]() + ((e.frame) ? e.frameSize[t] : 0);
            e.hide();
            u.insertDocked(0, e)
        }
        u.reExpander = e;
        u.reExpander.addClsWithUI(u.collapsedCls);
        u.reExpander.addClsWithUI(u.collapsedCls + "-" + e.dock);
        if (u.border && (!u.frame || (u.frame && Ext.supports.CSS3BorderRadius))) {
            u.reExpander.addClsWithUI(u.collapsedCls + "-border-" + u.reExpander.dock)
        }
        if (t == Ext.Component.DIRECTION_RIGHT) {
            n.to.left = g + (k - a)
        } else {
            if (t == Ext.Component.DIRECTION_BOTTOM) {
                n.to.top = g + (j - a)
            }
        }
        n.to[m] = a;
        if (!u.collapseMemento) {
            u.collapseMemento = new Ext.util.Memento(u)
        }
        u.collapseMemento.capture(["width", "height", "minWidth", "minHeight", "layoutManagedHeight", "layoutManagedWidth"]);
        u.savedFlex = u.flex;
        u.minWidth = 0;
        u.minHeight = 0;
        delete u.flex;
        u.suspendLayout = true;
        if (f) {
            u.animate(n)
        } else {
            u.setSize(n.to.width, n.to.height);
            if (Ext.isDefined(n.to.left) || Ext.isDefined(n.to.top)) {
                u.setPosition(n.to.left, n.to.top)
            }
            u.afterCollapse(false, h)
        }
        return u
    },
    afterCollapse: function(e, b) {
        var d = this,
        c = 0,
        a = d.hiddenDocked.length;
        d.collapseMemento.restore(["minWidth", "minHeight"]);
        if (Ext.Component.VERTICAL_DIRECTION_Re.test(d.expandDirection)) {
            d.layoutManagedHeight = 2;
            d.collapseMemento.restore("width", false)
        } else {
            d.layoutManagedWidth = 2;
            d.collapseMemento.restore("height", false)
        }
        d.saveScrollTop = d.body.dom.scrollTop;
        d.body.setStyle("display", "none");
        for (; c < a; c++) {
            d.hiddenDocked[c].hide()
        }
        if (d.reExpander) {
            d.reExpander.updateFrame();
            d.reExpander.show()
        }
        d.collapsed = true;
        d.suspendLayout = false;
        if (!b) {
            if (d.ownerCt) {
                if (e) {
                    d.ownerCt.layout.layout()
                }
            } else {
                if (d.reExpander.temporary) {
                    d.doComponentLayout()
                }
            }
        }
        if (d.resizer) {
            d.resizer.disable()
        }
        if (d.collapseTool) {
            d.collapseTool.setType("expand-" + d.expandDirection)
        }
        if (!b) {
            d.fireEvent("collapse", d)
        }
        if (e && d.collapseTool) {
            d.collapseTool.enable()
        }
    },
    expand: function(b) {
        var f = this;
        if (!f.collapsed || f.fireEvent("beforeexpand", f, b) === false) {
            return false
        }
        var e = 0,
        c = f.hiddenDocked.length,
        h = f.expandDirection,
        j = f.getHeight(),
        a = f.getWidth(),
        g,
        d;
        if (b && f.collapseTool) {
            f.collapseTool.disable()
        }
        for (; e < c; e++) {
            f.hiddenDocked[e].hidden = false;
            f.hiddenDocked[e].el.show()
        }
        if (f.reExpander) {
            if (f.reExpander.temporary) {
                f.reExpander.hide()
            } else {
                f.reExpander.removeClsWithUI(f.collapsedCls);
                f.reExpander.removeClsWithUI(f.collapsedCls + "-" + f.reExpander.dock);
                if (f.border && (!f.frame || (f.frame && Ext.supports.CSS3BorderRadius))) {
                    f.reExpander.removeClsWithUI(f.collapsedCls + "-border-" + f.reExpander.dock)
                }
                f.reExpander.updateFrame()
            }
        }
        if (f.collapseTool) {
            f.collapseTool.setType("collapse-" + f.collapseDirection)
        }
        f.body.setStyle("display", "");
        f.body.dom.scrollTop = f.saveScrollTop;
        f.collapsed = false;
        f.removeClsWithUI(f.collapsedCls);
        d = {
            to: {},
            from: {
                height: j,
                width: a
            },
            listeners: {
                afteranimate: f.afterExpand,
                scope: f
            }
        };
        if ((h == Ext.Component.DIRECTION_TOP) || (h == Ext.Component.DIRECTION_BOTTOM)) {
            f.collapseMemento.restore("height", false);
            if (f.height === undefined) {
                f.setCalculatedSize(f.width, null);
                d.to.height = f.getHeight();
                f.setCalculatedSize(f.width, d.from.height)
            } else {
                if (f.savedFlex) {
                    f.flex = f.savedFlex;
                    d.to.height = f.ownerCt.layout.calculateChildBox(f).height;
                    delete f.flex
                } else {
                    d.to.height = f.height
                }
            }
            if (h == Ext.Component.DIRECTION_TOP) {
                g = f.getPosition()[1] - Ext.fly(f.el.dom.offsetParent).getRegion().top;
                d.from.top = g;
                d.to.top = g - (d.to.height - j)
            }
        } else {
            if ((h == Ext.Component.DIRECTION_LEFT) || (h == Ext.Component.DIRECTION_RIGHT)) {
                f.collapseMemento.restore("width", false);
                if (f.width === undefined) {
                    f.setCalculatedSize(null, f.height);
                    d.to.width = f.getWidth();
                    f.setCalculatedSize(d.from.width, f.height)
                } else {
                    if (f.savedFlex) {
                        f.flex = f.savedFlex;
                        d.to.width = f.ownerCt.layout.calculateChildBox(f).width;
                        delete f.flex
                    } else {
                        d.to.width = f.width
                    }
                }
                if (h == Ext.Component.DIRECTION_LEFT) {
                    g = f.getPosition()[0] - Ext.fly(f.el.dom.offsetParent).getRegion().left;
                    d.from.left = g;
                    d.to.left = g - (d.to.width - a)
                }
            }
        }
        if (b) {
            f.animate(d)
        } else {
            f.setCalculatedSize(d.to.width, d.to.height);
            if (d.to.x) {
                f.setLeft(d.to.x)
            }
            if (d.to.y) {
                f.setTop(d.to.y)
            }
            f.afterExpand(false)
        }
        return f
    },
    afterExpand: function(b) {
        var a = this;
        if (a.savedFlex) {
            a.flex = a.savedFlex;
            delete a.savedFlex;
            delete a.width;
            delete a.height
        }
        if (a.collapseMemento) {
            a.collapseMemento.restoreAll()
        }
        if (b && a.ownerCt) {
            Ext.defer(a.ownerCt.doLayout, Ext.isIE6 ? 1 : 0, a)
        }
        if (a.resizer) {
            a.resizer.enable()
        }
        a.fireEvent("expand", a);
        if (b && a.collapseTool) {
            a.collapseTool.enable()
        }
    },
    toggleCollapse: function() {
        if (this.collapsed) {
            this.expand(this.animCollapse)
        } else {
            this.collapse(this.collapseDirection, this.animCollapse)
        }
        return this
    },
    getKeyMap: function() {
        if (!this.keyMap) {
            this.keyMap = Ext.create("Ext.util.KeyMap", this.el, this.keys)
        }
        return this.keyMap
    },
    initDraggable: function() {
        this.dd = Ext.create("Ext.panel.DD", this, Ext.isBoolean(this.draggable) ? null: this.draggable)
    },
    ghostTools: function() {
        var b = [],
        a = this.header.query("tool[hidden=false]");
        if (a.length) {
            Ext.each(a,
            function(c) {
                b.push({
                    type: c.type
                })
            })
        } else {
            b = [{
                type: "placeholder"
            }]
        }
        return b
    },
    ghost: function(a) {
        var d = this,
        b = d.ghostPanel,
        c = d.getBox(),
        e;
        if (!b) {
            b = Ext.create("Ext.panel.Panel", {
                renderTo: d.floating ? d.el.dom.parentNode: document.body,
                floating: {
                    shadow: false
                },
                frame: Ext.supports.CSS3BorderRadius ? d.frame: false,
                overlapHeader: d.overlapHeader,
                headerPosition: d.headerPosition,
                baseCls: d.baseCls,
                cls: d.baseCls + "-ghost " + (a || "")
            });
            d.ghostPanel = b
        }
        b.floatParent = d.floatParent;
        if (d.floating) {
            b.setZIndex(Ext.Number.from(d.el.getStyle("zIndex"), 0))
        } else {
            b.toFront()
        }
        e = b.header;
        if (e) {
            e.suspendLayout = true;
            Ext.Array.forEach(e.query("tool"),
            function(f) {
                e.remove(f)
            });
            e.suspendLayout = false
        }
        b.addTool(d.ghostTools());
        b.setTitle(d.title);
        b.setIconCls(d.iconCls);
        b.el.show();
        b.setPosition(c.x, c.y);
        b.setSize(c.width, c.height);
        d.el.hide();
        if (d.floatingItems) {
            d.floatingItems.hide()
        }
        return b
    },
    unghost: function(b, a) {
        var c = this;
        if (!c.ghostPanel) {
            return
        }
        if (b !== false) {
            c.el.show();
            if (a !== false) {
                c.setPosition(c.ghostPanel.getPosition())
            }
            if (c.floatingItems) {
                c.floatingItems.show()
            }
            Ext.defer(c.focus, 10, c)
        }
        c.ghostPanel.el.hide()
    },
    initResizable: function(a) {
        if (this.collapsed) {
            a.disabled = true
        }
        this.callParent([a])
    }
},
function() {
    this.prototype.animCollapse = Ext.enableFx
});
Ext.define("Ext.window.Window", {
    extend: "Ext.panel.Panel",
    alternateClassName: "Ext.Window",
    requires: ["Ext.util.ComponentDragger", "Ext.util.Region", "Ext.EventManager"],
    alias: "widget.window",
    baseCls: Ext.baseCSSPrefix + "window",
    resizable: true,
    draggable: true,
    constrain: false,
    constrainHeader: false,
    plain: false,
    minimizable: false,
    maximizable: false,
    minHeight: 100,
    minWidth: 200,
    expandOnShow: true,
    collapsible: false,
    closable: true,
    hidden: true,
    autoRender: true,
    hideMode: "visibility",
    floating: true,
    ariaRole: "alertdialog",
    itemCls: "x-window-item",
    overlapHeader: true,
    ignoreHeaderBorderManagement: true,
    initComponent: function() {
        var a = this;
        a.callParent();
        a.addEvents("resize", "maximize", "minimize", "restore");
        if (a.plain) {
            a.addClsWithUI("plain")
        }
        if (a.modal) {
            a.ariaRole = "dialog"
        }
    },
    initStateEvents: function() {
        var a = this.stateEvents;
        Ext.each(["maximize", "restore", "resize", "dragend"],
        function(b) {
            if (Ext.Array.indexOf(a, b)) {
                a.push(b)
            }
        });
        this.callParent()
    },
    getState: function() {
        var b = this,
        c = b.callParent() || {},
        a = !!b.maximized;
        c.maximized = a;
        Ext.apply(c, {
            size: a ? b.restoreSize: b.getSize(),
            pos: a ? b.restorePos: b.getPosition()
        });
        return c
    },
    applyState: function(b) {
        var a = this;
        if (b) {
            a.maximized = b.maximized;
            if (a.maximized) {
                a.hasSavedRestore = true;
                a.restoreSize = b.size;
                a.restorePos = b.pos
            } else {
                Ext.apply(a, {
                    width: b.size.width,
                    height: b.size.height,
                    x: b.pos[0],
                    y: b.pos[1]
                })
            }
        }
    },
    onMouseDown: function(b) {
        var a;
        if (this.floating) {
            if (Ext.fly(b.getTarget()).focusable()) {
                a = true
            }
            this.toFront(a)
        }
    },
    onRender: function(b, a) {
        var c = this;
        c.callParent(arguments);
        c.focusEl = c.el;
        if (c.maximizable) {
            c.header.on({
                dblclick: {
                    fn: c.toggleMaximize,
                    element: "el",
                    scope: c
                }
            })
        }
    },
    afterRender: function() {
        var a = this,
        b = a.hidden,
        c;
        a.hidden = false;
        a.callParent();
        a.hidden = b;
        a.proxy = a.getProxy();
        a.mon(a.el, "mousedown", a.onMouseDown, a);
        a.el.set({
            tabIndex: -1
        });
        if (a.maximized) {
            a.maximized = false;
            a.maximize()
        }
        if (a.closable) {
            c = a.getKeyMap();
            c.on(27, a.onEsc, a);
            c.disable()
        }
        if (!b) {
            a.syncMonitorWindowResize();
            a.doConstrain()
        }
    },
    initDraggable: function() {
        var b = this,
        a;
        if (!b.header) {
            b.updateHeader(true)
        }
        if (b.header) {
            a = Ext.applyIf({
                el: b.el,
                delegate: "#" + b.header.id
            },
            b.draggable);
            if (b.constrain || b.constrainHeader) {
                a.constrain = b.constrain;
                a.constrainDelegate = b.constrainHeader;
                a.constrainTo = b.constrainTo || b.container
            }
            b.dd = Ext.create("Ext.util.ComponentDragger", this, a);
            b.relayEvents(b.dd, ["dragstart", "drag", "dragend"])
        }
    },
    onEsc: function(a, b) {
        b.stopEvent();
        this[this.closeAction]()
    },
    beforeDestroy: function() {
        var a = this;
        if (a.rendered) {
            delete this.animateTarget;
            a.hide();
            Ext.destroy(a.keyMap)
        }
        a.callParent()
    },
    addTools: function() {
        var a = this;
        a.callParent();
        if (a.minimizable) {
            a.addTool({
                type: "minimize",
                handler: Ext.Function.bind(a.minimize, a, [])
            })
        }
        if (a.maximizable) {
            a.addTool({
                type: "maximize",
                handler: Ext.Function.bind(a.maximize, a, [])
            });
            a.addTool({
                type: "restore",
                handler: Ext.Function.bind(a.restore, a, []),
                hidden: true
            })
        }
    },
    getFocusEl: function() {
        var d = this,
        g = d.focusEl,
        e = d.defaultButton || d.defaultFocus,
        b = typeof db,
        c, a;
        if (Ext.isDefined(e)) {
            if (Ext.isNumber(e)) {
                g = d.query("button")[e]
            } else {
                if (Ext.isString(e)) {
                    g = d.down("#" + e)
                } else {
                    g = e
                }
            }
        }
        return g || d.focusEl
    },
    beforeShow: function() {
        this.callParent();
        if (this.expandOnShow) {
            this.expand(false)
        }
    },
    afterShow: function(c) {
        var b = this,
        a = c || b.animateTarget;
        b.callParent(arguments);
        if (b.maximized) {
            b.fitContainer()
        }
        b.syncMonitorWindowResize();
        if (!a) {
            b.doConstrain()
        }
        if (b.keyMap) {
            b.keyMap.enable()
        }
    },
    doClose: function() {
        var a = this;
        if (a.hidden) {
            a.fireEvent("close", a);
            if (a.closeAction == "destroy") {
                this.destroy()
            }
        } else {
            a.hide(a.animateTarget, a.doClose, a)
        }
    },
    afterHide: function() {
        var a = this;
        a.syncMonitorWindowResize();
        if (a.keyMap) {
            a.keyMap.disable()
        }
        a.callParent(arguments)
    },
    onWindowResize: function() {
        if (this.maximized) {
            this.fitContainer()
        }
        this.doConstrain()
    },
    minimize: function() {
        this.fireEvent("minimize", this);
        return this
    },
    afterCollapse: function() {
        var a = this;
        if (a.maximizable) {
            a.tools.maximize.hide();
            a.tools.restore.hide()
        }
        if (a.resizer) {
            a.resizer.disable()
        }
        a.callParent(arguments)
    },
    afterExpand: function() {
        var a = this;
        if (a.maximized) {
            a.tools.restore.show()
        } else {
            if (a.maximizable) {
                a.tools.maximize.show()
            }
        }
        if (a.resizer) {
            a.resizer.enable()
        }
        a.callParent(arguments)
    },
    maximize: function() {
        var a = this;
        if (!a.maximized) {
            a.expand(false);
            if (!a.hasSavedRestore) {
                a.restoreSize = a.getSize();
                a.restorePos = a.getPosition(true)
            }
            if (a.maximizable) {
                a.tools.maximize.hide();
                a.tools.restore.show()
            }
            a.maximized = true;
            a.el.disableShadow();
            if (a.dd) {
                a.dd.disable()
            }
            if (a.collapseTool) {
                a.collapseTool.hide()
            }
            a.el.addCls(Ext.baseCSSPrefix + "window-maximized");
            a.container.addCls(Ext.baseCSSPrefix + "window-maximized-ct");
            a.syncMonitorWindowResize();
            a.setPosition(0, 0);
            a.fitContainer();
            a.fireEvent("maximize", a)
        }
        return a
    },
    restore: function() {
        var a = this,
        b = a.tools;
        if (a.maximized) {
            delete a.hasSavedRestore;
            a.removeCls(Ext.baseCSSPrefix + "window-maximized");
            if (b.restore) {
                b.restore.hide()
            }
            if (b.maximize) {
                b.maximize.show()
            }
            if (a.collapseTool) {
                a.collapseTool.show()
            }
            a.setPosition(a.restorePos);
            a.setSize(a.restoreSize);
            delete a.restorePos;
            delete a.restoreSize;
            a.maximized = false;
            a.el.enableShadow(true);
            if (a.dd) {
                a.dd.enable()
            }
            a.container.removeCls(Ext.baseCSSPrefix + "window-maximized-ct");
            a.syncMonitorWindowResize();
            a.doConstrain();
            a.fireEvent("restore", a)
        }
        return a
    },
    syncMonitorWindowResize: function() {
        var b = this,
        c = b._monitoringResize,
        d = b.monitorResize || b.constrain || b.constrainHeader || b.maximized,
        a = b.hidden || b.destroying || b.isDestroyed;
        if (d && !a) {
            if (!c) {
                Ext.EventManager.onWindowResize(b.onWindowResize, b);
                b._monitoringResize = true
            }
        } else {
            if (c) {
                Ext.EventManager.removeResizeListener(b.onWindowResize, b);
                b._monitoringResize = false
            }
        }
    },
    toggleMaximize: function() {
        return this[this.maximized ? "restore": "maximize"]()
    }
});
Ext.define("Ext.window.MessageBox", {
    extend: "Ext.window.Window",
    requires: ["Ext.toolbar.Toolbar", "Ext.form.field.Text", "Ext.form.field.TextArea", "Ext.button.Button", "Ext.layout.container.Anchor", "Ext.layout.container.HBox", "Ext.ProgressBar"],
    alias: "widget.messagebox",
    OK: 1,
    YES: 2,
    NO: 4,
    CANCEL: 8,
    OKCANCEL: 9,
    YESNO: 6,
    YESNOCANCEL: 14,
    INFO: "ext-mb-info",
    WARNING: "ext-mb-warning",
    QUESTION: "ext-mb-question",
    ERROR: "ext-mb-error",
    hideMode: "offsets",
    closeAction: "hide",
    resizable: false,
    title: "&#160;",
    width: 600,
    height: 500,
    minWidth: 250,
    maxWidth: 600,
    minHeight: 110,
    maxHeight: 500,
    constrain: true,
    cls: Ext.baseCSSPrefix + "message-box",
    layout: {
        type: "anchor"
    },
    defaultTextHeight: 75,
    minProgressWidth: 250,
    minPromptWidth: 250,
    buttonText: {
        ok: "OK",
        yes: "Yes",
        no: "No",
        cancel: "Cancel"
    },
    buttonIds: ["ok", "yes", "no", "cancel"],
    titleText: {
        confirm: "Confirm",
        prompt: "Prompt",
        wait: "Loading...",
        alert: "Attention"
    },
    iconHeight: 35,
    makeButton: function(a) {
        var b = this.buttonIds[a];
        return Ext.create("Ext.button.Button", {
            handler: this.btnCallback,
            itemId: b,
            scope: this,
            text: this.buttonText[b],
            minWidth: 75
        })
    },
    btnCallback: function(a) {
        var b = this,
        c, d;
        if (b.cfg.prompt || b.cfg.multiline) {
            if (b.cfg.multiline) {
                d = b.textArea
            } else {
                d = b.textField
            }
            c = d.getValue();
            d.reset()
        }
        a.blur();
        b.hide();
        b.userCallback(a.itemId, c, b.cfg)
    },
    hide: function() {
        var a = this;
        a.dd.endDrag();
        a.progressBar.reset();
        a.removeCls(a.cfg.cls);
        a.callParent()
    },
    initComponent: function() {
        var c = this,
        b, a;
        c.title = "&#160;";
        c.topContainer = Ext.create("Ext.container.Container", {
            anchor: "100%",
            style: {
                padding: "10px",
                overflow: "hidden"
            },
            items: [c.iconComponent = Ext.create("Ext.Component", {
                cls: "ext-mb-icon",
                width: 50,
                height: c.iconHeight,
                style: {
                    "float": "left"
                }
            }), c.promptContainer = Ext.create("Ext.container.Container", {
                layout: {
                    type: "anchor"
                },
                items: [c.msg = Ext.create("Ext.Component", {
                    autoEl: {
                        tag: "span"
                    },
                    cls: "ext-mb-text"
                }), c.textField = Ext.create("Ext.form.field.Text", {
                    anchor: "100%",
                    enableKeyEvents: true,
                    listeners: {
                        keydown: c.onPromptKey,
                        scope: c
                    }
                }), c.textArea = Ext.create("Ext.form.field.TextArea", {
                    anchor: "100%",
                    height: 75
                })]
            })]
        });
        c.progressBar = Ext.create("Ext.ProgressBar", {
            anchor: "-10",
            style: "margin-left:10px"
        });
        c.items = [c.topContainer, c.progressBar];
        c.msgButtons = [];
        for (b = 0; b < 4; b++) {
            a = c.makeButton(b);
            c.msgButtons[a.itemId] = a;
            c.msgButtons.push(a)
        }
        c.bottomTb = Ext.create("Ext.toolbar.Toolbar", {
            ui: "footer",
            dock: "bottom",
            layout: {
                pack: "center"
            },
            items: [c.msgButtons[0], c.msgButtons[1], c.msgButtons[2], c.msgButtons[3]]
        });
        c.dockedItems = [c.bottomTb];
        c.callParent()
    },
    onPromptKey: function(a, c) {
        var b = this,
        d;
        if (c.keyCode === Ext.EventObject.RETURN || c.keyCode === 10) {
            if (b.msgButtons.ok.isVisible()) {
                d = true;
                b.msgButtons.ok.handler.call(b, b.msgButtons.ok)
            } else {
                if (b.msgButtons.yes.isVisible()) {
                    b.msgButtons.yes.handler.call(b, b.msgButtons.yes);
                    d = true
                }
            }
            if (d) {
                b.textField.blur()
            }
        }
    },
    reconfigure: function(a) {
        var d = this,
        c = a.buttons || 0,
        f = true,
        e = d.maxWidth,
        b;
        a = a || {};
        d.cfg = a;
        if (a.width) {
            e = a.width
        }
        delete d.defaultFocus;
        d.animateTarget = a.animateTarget || undefined;
        d.modal = a.modal !== false;
        if (a.title) {
            d.setTitle(a.title || "&#160;")
        }
        if (!d.rendered) {
            d.width = e;
            d.render(Ext.getBody())
        } else {
            d.setSize(e, d.maxHeight)
        }
        d.setPosition( - 10000, -10000);
        d.closable = a.closable && !a.wait;
        d.header.child("[type=close]").setVisible(a.closable !== false);
        if (!a.title && !d.closable) {
            d.header.hide()
        } else {
            d.header.show()
        }
        d.liveDrag = !a.proxyDrag;
        d.userCallback = Ext.Function.bind(a.callback || a.fn || Ext.emptyFn, a.scope || Ext.global);
        d.setIcon(a.icon);
        if (a.msg) {
            d.msg.update(a.msg);
            d.msg.show()
        } else {
            d.msg.hide()
        }
        if (a.prompt || a.multiline) {
            d.multiline = a.multiline;
            if (a.multiline) {
                d.textArea.setValue(a.value);
                d.textArea.setHeight(a.defaultTextHeight || d.defaultTextHeight);
                d.textArea.show();
                d.textField.hide();
                d.defaultFocus = d.textArea
            } else {
                d.textField.setValue(a.value);
                d.textArea.hide();
                d.textField.show();
                d.defaultFocus = d.textField
            }
        } else {
            d.textArea.hide();
            d.textField.hide()
        }
        if (a.progress || a.wait) {
            d.progressBar.show();
            d.updateProgress(0, a.progressText);
            if (a.wait === true) {
                d.progressBar.wait(a.waitConfig)
            }
        } else {
            d.progressBar.hide()
        }
        for (b = 0; b < 4; b++) {
            if (c & Math.pow(2, b)) {
                if (!d.defaultFocus) {
                    d.defaultFocus = d.msgButtons[b]
                }
                d.msgButtons[b].show();
                f = false
            } else {
                d.msgButtons[b].hide()
            }
        }
        if (f) {
            d.bottomTb.hide()
        } else {
            d.bottomTb.show()
        }
    },
    show: function(a) {
        var b = this;
        b.reconfigure(a);
        b.addCls(a.cls);
        if (a.animateTarget) {
            b.doAutoSize(true);
            b.callParent()
        } else {
            b.callParent();
            b.doAutoSize(true)
        }
        return b
    },
    afterShow: function() {
        if (this.animateTarget) {
            this.center()
        }
        this.callParent(arguments)
    },
    doAutoSize: function(b) {
        var e = this,
        d = e.iconComponent,
        f = e.iconHeight;
        if (!Ext.isDefined(e.frameWidth)) {
            e.frameWidth = e.el.getWidth() - e.body.getWidth()
        }
        d.setHeight(f);
        e.minWidth = e.cfg.minWidth || Ext.getClass(this).prototype.minWidth;
        e.topContainer.doLayout();
        if (Ext.isIE6 || Ext.isIEQuirks) {
            e.textField.setCalculatedSize(9);
            e.textArea.setCalculatedSize(9)
        }
        var c = e.cfg.width || e.msg.getWidth() + d.getWidth() + 25,
        a = (e.header.rendered ? e.header.getHeight() : 0) + Math.max(e.promptContainer.getHeight(), d.getHeight()) + e.progressBar.getHeight() + (e.bottomTb.rendered ? e.bottomTb.getHeight() : 0) + 20;
        d.setHeight(Math.max(f, e.msg.getHeight()));
        e.setSize(c + e.frameWidth, a + e.frameWidth);
        if (b) {
            e.center()
        }
        return e
    },
    updateText: function(a) {
        this.msg.update(a);
        return this.doAutoSize(true)
    },
    setIcon: function(a) {
        var b = this;
        b.iconComponent.removeCls(b.iconCls);
        if (a) {
            b.iconComponent.show();
            b.iconComponent.addCls(Ext.baseCSSPrefix + "dlg-icon");
            b.iconComponent.addCls(b.iconCls = a)
        } else {
            b.iconComponent.removeCls(Ext.baseCSSPrefix + "dlg-icon");
            b.iconComponent.hide()
        }
        return b
    },
    updateProgress: function(b, a, c) {
        this.progressBar.updateProgress(b, a);
        if (c) {
            this.updateText(c)
        }
        return this
    },
    onEsc: function() {
        if (this.closable !== false) {
            this.callParent(arguments)
        }
    },
    confirm: function(a, d, c, b) {
        if (Ext.isString(a)) {
            a = {
                title: a,
                icon: "ext-mb-question",
                msg: d,
                buttons: this.YESNO,
                callback: c,
                scope: b
            }
        }
        return this.show(a)
    },
    prompt: function(b, f, d, c, a, e) {
        if (Ext.isString(b)) {
            b = {
                prompt: true,
                title: b,
                minWidth: this.minPromptWidth,
                msg: f,
                buttons: this.OKCANCEL,
                callback: d,
                scope: c,
                multiline: a,
                value: e
            }
        }
        return this.show(b)
    },
    wait: function(a, c, b) {
        if (Ext.isString(a)) {
            a = {
                title: c,
                msg: a,
                closable: false,
                wait: true,
                modal: true,
                minWidth: this.minProgressWidth,
                waitConfig: b
            }
        }
        return this.show(a)
    },
    alert: function(a, d, c, b) {
        if (Ext.isString(a)) {
            a = {
                title: a,
                msg: d,
                buttons: this.OK,
                fn: c,
                scope: b,
                minWidth: this.minWidth
            }
        }
        return this.show(a)
    },
    progress: function(a, c, b) {
        if (Ext.isString(a)) {
            a = {
                title: a,
                msg: c,
                progress: true,
                progressText: b
            }
        }
        return this.show(a)
    }
},
function() {
    Ext.MessageBox = Ext.Msg = new this()
});
Ext.define("Ext.tip.Tip", {
    extend: "Ext.panel.Panel",
    requires: ["Ext.layout.component.Tip"],
    alternateClassName: "Ext.Tip",
    minWidth: 40,
    maxWidth: 300,
    shadow: "sides",
    defaultAlign: "tl-bl?",
    constrainPosition: true,
    frame: false,
    autoRender: true,
    hidden: true,
    baseCls: Ext.baseCSSPrefix + "tip",
    floating: {
        shadow: true,
        shim: true,
        constrain: true
    },
    focusOnToFront: false,
    componentLayout: "tip",
    closeAction: "hide",
    ariaRole: "tooltip",
    initComponent: function() {
        var a = this;
        a.floating = Ext.apply({},
        {
            shadow: a.shadow
        },
        a.self.prototype.floating);
        a.callParent(arguments);
        a.constrain = a.constrain || a.constrainPosition
    },
    showAt: function(b) {
        var a = this;
        this.callParent(arguments);
        if (a.isVisible()) {
            a.setPagePosition(b[0], b[1]);
            if (a.constrainPosition || a.constrain) {
                a.doConstrain()
            }
            a.toFront(true)
        }
    },
    showBy: function(a, b) {
        this.showAt(this.el.getAlignToXY(a, b || this.defaultAlign))
    },
    initDraggable: function() {
        var a = this;
        a.draggable = {
            el: a.getDragEl(),
            delegate: a.header.el,
            constrain: a,
            constrainTo: a.el.getScopeParent()
        };
        Ext.Component.prototype.initDraggable.call(a)
    },
    ghost: undefined,
    unghost: undefined
});
Ext.define("Ext.slider.Tip", {
    extend: "Ext.tip.Tip",
    minWidth: 10,
    alias: "widget.slidertip",
    offsets: [0, -10],
    isSliderTip: true,
    init: function(b) {
        var a = this;
        b.on({
            scope: a,
            dragstart: a.onSlide,
            drag: a.onSlide,
            dragend: a.hide,
            destroy: a.destroy
        })
    },
    onSlide: function(c, d, a) {
        var b = this;
        b.show();
        b.update(b.getText(a));
        b.doComponentLayout();
        b.el.alignTo(a.el, "b-t?", b.offsets)
    },
    getText: function(a) {
        return String(a.value)
    }
});
Ext.define("Ext.slider.Multi", {
    extend: "Ext.form.field.Base",
    alias: "widget.multislider",
    alternateClassName: "Ext.slider.MultiSlider",
    requires: ["Ext.slider.Thumb", "Ext.slider.Tip", "Ext.Number", "Ext.util.Format", "Ext.Template", "Ext.layout.component.field.Slider"],
    fieldSubTpl: ['<div id="{id}" class="' + Ext.baseCSSPrefix + 'slider {fieldCls} {vertical}" aria-valuemin="{minValue}" aria-valuemax="{maxValue}" aria-valuenow="{value}" aria-valuetext="{value}">', '<div id="{cmpId}-endEl" class="' + Ext.baseCSSPrefix + 'slider-end" role="presentation">', '<div id="{cmpId}-innerEl" class="' + Ext.baseCSSPrefix + 'slider-inner" role="presentation">', '<a id="{cmpId}-focusEl" class="' + Ext.baseCSSPrefix + 'slider-focus" href="#" tabIndex="-1" hidefocus="on" role="presentation"></a>', "</div>", "</div>", "</div>", {
        disableFormats: true,
        compiled: true
    }],
    vertical: false,
    minValue: 0,
    maxValue: 100,
    decimalPrecision: 0,
    keyIncrement: 1,
    increment: 0,
    clickRange: [5, 15],
    clickToChange: true,
    animate: true,
    dragging: false,
    constrainThumbs: true,
    componentLayout: "sliderfield",
    useTips: true,
    tipText: null,
    ariaRole: "slider",
    initValue: function() {
        var e = this,
        c = Ext.value,
        b = c(e.values, [c(e.value, c(e.minValue, 0))]),
        d = 0,
        a = b.length;
        e.originalValue = b;
        for (; d < a; d++) {
            e.addThumb(b[d])
        }
    },
    initComponent: function() {
        var c = this,
        a, b;
        c.thumbs = [];
        c.keyIncrement = Math.max(c.increment, c.keyIncrement);
        c.addEvents("beforechange", "change", "changecomplete", "dragstart", "drag", "dragend");
        if (c.vertical) {
            Ext.apply(c, Ext.slider.Multi.Vertical)
        }
        c.callParent();
        if (c.useTips) {
            a = c.tipText ? {
                getText: c.tipText
            }: {};
            c.plugins = c.plugins || [];
            Ext.each(c.plugins,
            function(d) {
                if (d.isSliderTip) {
                    b = true;
                    return false
                }
            });
            if (!b) {
                c.plugins.push(Ext.create("Ext.slider.Tip", a))
            }
        }
    },
    addThumb: function(c) {
        var b = this,
        a = Ext.create("Ext.slider.Thumb", {
            value: c,
            slider: b,
            index: b.thumbs.length,
            constrain: b.constrainThumbs
        });
        b.thumbs.push(a);
        if (b.rendered) {
            a.render()
        }
        return a
    },
    promoteThumb: function(c) {
        var a = this.thumbs,
        e = a.length,
        f, b, d;
        for (d = 0; d < e; d++) {
            b = a[d];
            if (b == c) {
                b.bringToFront()
            } else {
                b.sendToBack()
            }
        }
    },
    onRender: function() {
        var e = this,
        d = 0,
        b = e.thumbs,
        a = b.length,
        c;
        Ext.applyIf(e.subTplData, {
            vertical: e.vertical ? Ext.baseCSSPrefix + "slider-vert": Ext.baseCSSPrefix + "slider-horz",
            minValue: e.minValue,
            maxValue: e.maxValue,
            value: e.value
        });
        e.addChildEls("endEl", "innerEl", "focusEl");
        e.callParent(arguments);
        for (; d < a; d++) {
            b[d].render()
        }
        c = e.innerEl.down("." + Ext.baseCSSPrefix + "slider-thumb");
        e.halfThumb = (e.vertical ? c.getHeight() : c.getWidth()) / 2
    },
    onChange: function(b, a) {
        this.setValue(a, undefined, true)
    },
    initEvents: function() {
        var a = this;
        a.mon(a.el, {
            scope: a,
            mousedown: a.onMouseDown,
            keydown: a.onKeyDown,
            change: a.onChange
        });
        a.focusEl.swallowEvent("click", true)
    },
    onMouseDown: function(h) {
        var f = this,
        g = false,
        d = 0,
        b = f.thumbs,
        a = b.length,
        c;
        if (f.disabled) {
            return
        }
        for (; d < a; d++) {
            g = g || h.target == b[d].el.dom
        }
        if (f.clickToChange && !g) {
            c = f.innerEl.translatePoints(h.getXY());
            f.onClickChange(c)
        }
        f.focus()
    },
    onClickChange: function(c) {
        var d = this,
        a, b;
        if (c.top > d.clickRange[0] && c.top < d.clickRange[1]) {
            a = d.getNearest(c, "left");
            if (!a.disabled) {
                b = a.index;
                d.setValue(b, Ext.util.Format.round(d.reverseValue(c.left), d.decimalPrecision), undefined, true)
            }
        }
    },
    getNearest: function(m, b) {
        var k = this,
        o = b == "top" ? k.innerEl.getHeight() - m[b] : m[b],
        h = k.reverseValue(o),
        l = (k.maxValue - k.minValue) + 5,
        f = 0,
        c = null,
        g = k.thumbs,
        d = 0,
        e = g.length,
        a,
        n,
        j;
        for (; d < e; d++) {
            a = k.thumbs[d];
            n = a.value;
            j = Math.abs(n - h);
            if (Math.abs(j <= l)) {
                c = a;
                f = d;
                l = j
            }
        }
        return c
    },
    onKeyDown: function(c) {
        var b = this,
        a, d;
        if (b.disabled || b.thumbs.length !== 1) {
            c.preventDefault();
            return
        }
        a = c.getKey();
        switch (a) {
        case c.UP:
        case c.RIGHT:
            c.stopEvent();
            d = c.ctrlKey ? b.maxValue: b.getValue(0) + b.keyIncrement;
            b.setValue(0, d, undefined, true);
            break;
        case c.DOWN:
        case c.LEFT:
            c.stopEvent();
            d = c.ctrlKey ? b.minValue: b.getValue(0) - b.keyIncrement;
            b.setValue(0, d, undefined, true);
            break;
        default:
            c.preventDefault()
        }
    },
    afterRender: function() {
        var f = this,
        e = 0,
        b = f.thumbs,
        a = b.length,
        d, c;
        f.callParent(arguments);
        for (; e < a; e++) {
            d = b[e];
            if (d.value !== undefined) {
                c = f.normalizeValue(d.value);
                if (c !== d.value) {
                    f.setValue(e, c, false)
                } else {
                    d.move(f.translateValue(c), false)
                }
            }
        }
    },
    getRatio: function() {
        var a = this.innerEl.getWidth(),
        b = this.maxValue - this.minValue;
        return b === 0 ? a: (a / b)
    },
    normalizeValue: function(a) {
        var b = this;
        a = Ext.Number.snap(a, this.increment, this.minValue, this.maxValue);
        a = Ext.util.Format.round(a, b.decimalPrecision);
        a = Ext.Number.constrain(a, b.minValue, b.maxValue);
        return a
    },
    setMinValue: function(f) {
        var e = this,
        d = 0,
        b = e.thumbs,
        a = b.length,
        c;
        e.minValue = f;
        if (e.rendered) {
            e.inputEl.dom.setAttribute("aria-valuemin", f)
        }
        for (; d < a; ++d) {
            c = b[d];
            c.value = c.value < f ? f: c.value
        }
        e.syncThumbs()
    },
    setMaxValue: function(f) {
        var e = this,
        d = 0,
        b = e.thumbs,
        a = b.length,
        c;
        e.maxValue = f;
        if (e.rendered) {
            e.inputEl.dom.setAttribute("aria-valuemax", f)
        }
        for (; d < a; ++d) {
            c = b[d];
            c.value = c.value > f ? f: c.value
        }
        e.syncThumbs()
    },
    setValue: function(c, f, b, e) {
        var d = this,
        a = d.thumbs[c];
        f = d.normalizeValue(f);
        if (f !== a.value && d.fireEvent("beforechange", d, f, a.value, a) !== false) {
            a.value = f;
            if (d.rendered) {
                d.inputEl.set({
                    "aria-valuenow": f,
                    "aria-valuetext": f
                });
                a.move(d.translateValue(f), Ext.isDefined(b) ? b !== false: d.animate);
                d.fireEvent("change", d, f, a);
                if (e) {
                    d.fireEvent("changecomplete", d, f, a)
                }
            }
        }
    },
    translateValue: function(a) {
        var b = this.getRatio();
        return (a * b) - (this.minValue * b) - this.halfThumb
    },
    reverseValue: function(b) {
        var a = this.getRatio();
        return (b + (this.minValue * a)) / a
    },
    focus: function() {
        this.focusEl.focus(10)
    },
    onDisable: function() {
        var f = this,
        d = 0,
        b = f.thumbs,
        a = b.length,
        c, e, g;
        f.callParent();
        for (; d < a; d++) {
            c = b[d];
            e = c.el;
            c.disable();
            if (Ext.isIE) {
                g = e.getXY();
                e.hide();
                f.innerEl.addCls(f.disabledCls).dom.disabled = true;
                if (!f.thumbHolder) {
                    f.thumbHolder = f.endEl.createChild({
                        cls: Ext.baseCSSPrefix + "slider-thumb " + f.disabledCls
                    })
                }
                f.thumbHolder.show().setXY(g)
            }
        }
    },
    onEnable: function() {
        var f = this,
        d = 0,
        b = f.thumbs,
        a = b.length,
        c, e;
        this.callParent();
        for (; d < a; d++) {
            c = b[d];
            e = c.el;
            c.enable();
            if (Ext.isIE) {
                f.innerEl.removeCls(f.disabledCls).dom.disabled = false;
                if (f.thumbHolder) {
                    f.thumbHolder.hide()
                }
                e.show();
                f.syncThumbs()
            }
        }
    },
    syncThumbs: function() {
        if (this.rendered) {
            var a = this.thumbs,
            c = a.length,
            b = 0;
            for (; b < c; b++) {
                a[b].move(this.translateValue(a[b].value))
            }
        }
    },
    getValue: function(a) {
        return Ext.isNumber(a) ? this.thumbs[a].value: this.getValues()
    },
    getValues: function() {
        var c = [],
        d = 0,
        b = this.thumbs,
        a = b.length;
        for (; d < a; d++) {
            c.push(b[d].value)
        }
        return c
    },
    getSubmitValue: function() {
        var a = this;
        return (a.disabled || !a.submitValue) ? null: a.getValue()
    },
    reset: function() {
        var b = this,
        a = Ext.Array;
        a.forEach(a.from(b.originalValue),
        function(d, c) {
            b.setValue(c, d)
        });
        b.clearInvalid();
        delete b.wasValid
    },
    beforeDestroy: function() {
        var a = this;
        Ext.destroy(a.innerEl, a.endEl, a.focusEl);
        Ext.each(a.thumbs,
        function(b) {
            Ext.destroy(b)
        },
        a);
        a.callParent()
    },
    statics: {
        Vertical: {
            getRatio: function() {
                var b = this.innerEl.getHeight(),
                a = this.maxValue - this.minValue;
                return b / a
            },
            onClickChange: function(d) {
                var e = this,
                b, c, a;
                if (d.left > e.clickRange[0] && d.left < e.clickRange[1]) {
                    b = e.getNearest(d, "top");
                    if (!b.disabled) {
                        c = b.index;
                        a = e.reverseValue(e.innerEl.getHeight() - d.top);
                        e.setValue(c, Ext.util.Format.round(e.minValue + a, e.decimalPrecision), undefined, true)
                    }
                }
            }
        }
    }
});
Ext.define("Ext.slider.Single", {
    extend: "Ext.slider.Multi",
    alias: ["widget.slider", "widget.sliderfield"],
    alternateClassName: ["Ext.Slider", "Ext.form.SliderField", "Ext.slider.SingleSlider", "Ext.slider.Slider"],
    getValue: function() {
        return this.callParent([0])
    },
    setValue: function(d, b) {
        var c = Ext.toArray(arguments),
        a = c.length;
        if (a == 1 || (a <= 3 && typeof arguments[1] != "number")) {
            c.unshift(0)
        }
        return this.callParent(c)
    },
    getNearest: function() {
        return this.thumbs[0]
    }
});
Ext.define("Ext.tip.ToolTip", {
    extend: "Ext.tip.Tip",
    alias: "widget.tooltip",
    alternateClassName: "Ext.ToolTip",
    showDelay: 500,
    hideDelay: 200,
    dismissDelay: 5000,
    trackMouse: false,
    anchorToTarget: true,
    anchorOffset: 0,
    targetCounter: 0,
    quickShowInterval: 250,
    initComponent: function() {
        var a = this;
        a.callParent(arguments);
        a.lastActive = new Date();
        a.setTarget(a.target);
        a.origAnchor = a.anchor
    },
    onRender: function(b, a) {
        var c = this;
        c.callParent(arguments);
        c.anchorCls = Ext.baseCSSPrefix + "tip-anchor-" + c.getAnchorPosition();
        c.anchorEl = c.el.createChild({
            cls: Ext.baseCSSPrefix + "tip-anchor " + c.anchorCls
        })
    },
    afterRender: function() {
        var a = this,
        b;
        a.callParent(arguments);
        b = parseInt(a.el.getZIndex(), 10) || 0;
        a.anchorEl.setStyle("z-index", b + 1).setVisibilityMode(Ext.Element.DISPLAY)
    },
    setTarget: function(d) {
        var b = this,
        a = Ext.get(d),
        c;
        if (b.target) {
            c = Ext.get(b.target);
            b.mun(c, "mouseover", b.onTargetOver, b);
            b.mun(c, "mouseout", b.onTargetOut, b);
            b.mun(c, "mousemove", b.onMouseMove, b)
        }
        b.target = a;
        if (a) {
            b.mon(a, {
                freezeEvent: true,
                mouseover: b.onTargetOver,
                mouseout: b.onTargetOut,
                mousemove: b.onMouseMove,
                scope: b
            })
        }
        if (b.anchor) {
            b.anchorTarget = b.target
        }
    },
    onMouseMove: function(d) {
        var b = this,
        a = b.delegate ? d.getTarget(b.delegate) : b.triggerElement = true,
        c;
        if (a) {
            b.targetXY = d.getXY();
            if (a === b.triggerElement) {
                if (!b.hidden && b.trackMouse) {
                    c = b.getTargetXY();
                    if (b.constrainPosition) {
                        c = b.el.adjustForConstraints(c, b.el.getScopeParent())
                    }
                    b.setPagePosition(c)
                }
            } else {
                b.hide();
                b.lastActive = new Date(0);
                b.onTargetOver(d)
            }
        } else {
            if ((!b.closable && b.isVisible()) && b.autoHide !== false) {
                b.hide()
            }
        }
    },
    getTargetXY: function() {
        var j = this,
        d;
        if (j.delegate) {
            j.anchorTarget = j.triggerElement
        }
        if (j.anchor) {
            j.targetCounter++;
            var c = j.getOffsets(),
            n = (j.anchorToTarget && !j.trackMouse) ? j.el.getAlignToXY(j.anchorTarget, j.getAnchorAlign()) : j.targetXY,
            a = Ext.Element.getViewWidth() - 5,
            h = Ext.Element.getViewHeight() - 5,
            l = document.documentElement,
            e = document.body,
            m = (l.scrollLeft || e.scrollLeft || 0) + 5,
            k = (l.scrollTop || e.scrollTop || 0) + 5,
            b = [n[0] + c[0], n[1] + c[1]],
            g = j.getSize(),
            f = j.constrainPosition;
            j.anchorEl.removeCls(j.anchorCls);
            if (j.targetCounter < 2 && f) {
                if (b[0] < m) {
                    if (j.anchorToTarget) {
                        j.defaultAlign = "l-r";
                        if (j.mouseOffset) {
                            j.mouseOffset[0] *= -1
                        }
                    }
                    j.anchor = "left";
                    return j.getTargetXY()
                }
                if (b[0] + g.width > a) {
                    if (j.anchorToTarget) {
                        j.defaultAlign = "r-l";
                        if (j.mouseOffset) {
                            j.mouseOffset[0] *= -1
                        }
                    }
                    j.anchor = "right";
                    return j.getTargetXY()
                }
                if (b[1] < k) {
                    if (j.anchorToTarget) {
                        j.defaultAlign = "t-b";
                        if (j.mouseOffset) {
                            j.mouseOffset[1] *= -1
                        }
                    }
                    j.anchor = "top";
                    return j.getTargetXY()
                }
                if (b[1] + g.height > h) {
                    if (j.anchorToTarget) {
                        j.defaultAlign = "b-t";
                        if (j.mouseOffset) {
                            j.mouseOffset[1] *= -1
                        }
                    }
                    j.anchor = "bottom";
                    return j.getTargetXY()
                }
            }
            j.anchorCls = Ext.baseCSSPrefix + "tip-anchor-" + j.getAnchorPosition();
            j.anchorEl.addCls(j.anchorCls);
            j.targetCounter = 0;
            return b
        } else {
            d = j.getMouseOffset();
            return (j.targetXY) ? [j.targetXY[0] + d[0], j.targetXY[1] + d[1]] : d
        }
    },
    getMouseOffset: function() {
        var a = this,
        b = a.anchor ? [0, 0] : [15, 18];
        if (a.mouseOffset) {
            b[0] += a.mouseOffset[0];
            b[1] += a.mouseOffset[1]
        }
        return b
    },
    getAnchorPosition: function() {
        var b = this,
        a;
        if (b.anchor) {
            b.tipAnchor = b.anchor.charAt(0)
        } else {
            a = b.defaultAlign.match(/^([a-z]+)-([a-z]+)(\?)?$/);
            if (!a) {
                Ext.Error.raise('The AnchorTip.defaultAlign value "' + b.defaultAlign + '" is invalid.')
            }
            b.tipAnchor = a[1].charAt(0)
        }
        switch (b.tipAnchor) {
        case "t":
            return "top";
        case "b":
            return "bottom";
        case "r":
            return "right"
        }
        return "left"
    },
    getAnchorAlign: function() {
        switch (this.anchor) {
        case "top":
            return "tl-bl";
        case "left":
            return "tl-tr";
        case "right":
            return "tr-tl";
        default:
            return "bl-tl"
        }
    },
    getOffsets: function() {
        var c = this,
        d, b, a = c.getAnchorPosition().charAt(0);
        if (c.anchorToTarget && !c.trackMouse) {
            switch (a) {
            case "t":
                b = [0, 9];
                break;
            case "b":
                b = [0, -13];
                break;
            case "r":
                b = [ - 13, 0];
                break;
            default:
                b = [9, 0];
                break
            }
        } else {
            switch (a) {
            case "t":
                b = [ - 15 - c.anchorOffset, 30];
                break;
            case "b":
                b = [ - 19 - c.anchorOffset, -13 - c.el.dom.offsetHeight];
                break;
            case "r":
                b = [ - 15 - c.el.dom.offsetWidth, -13 - c.anchorOffset];
                break;
            default:
                b = [25, -13 - c.anchorOffset];
                break
            }
        }
        d = c.getMouseOffset();
        b[0] += d[0];
        b[1] += d[1];
        return b
    },
    onTargetOver: function(c) {
        var b = this,
        a;
        if (b.disabled || c.within(b.target.dom, true)) {
            return
        }
        a = c.getTarget(b.delegate);
        if (a) {
            b.triggerElement = a;
            b.clearTimer("hide");
            b.targetXY = c.getXY();
            b.delayShow()
        }
    },
    delayShow: function() {
        var a = this;
        if (a.hidden && !a.showTimer) {
            if (Ext.Date.getElapsed(a.lastActive) < a.quickShowInterval) {
                a.show()
            } else {
                a.showTimer = Ext.defer(a.show, a.showDelay, a)
            }
        } else {
            if (!a.hidden && a.autoHide !== false) {
                a.show()
            }
        }
    },
    onTargetOut: function(b) {
        var a = this;
        if (a.disabled || b.within(a.target.dom, true)) {
            return
        }
        a.clearTimer("show");
        if (a.autoHide !== false) {
            a.delayHide()
        }
    },
    delayHide: function() {
        var a = this;
        if (!a.hidden && !a.hideTimer) {
            a.hideTimer = Ext.defer(a.hide, a.hideDelay, a)
        }
    },
    hide: function() {
        var a = this;
        a.clearTimer("dismiss");
        a.lastActive = new Date();
        if (a.anchorEl) {
            a.anchorEl.hide()
        }
        a.callParent(arguments);
        delete a.triggerElement
    },
    show: function() {
        var a = this;
        this.callParent();
        if (this.hidden === false) {
            a.setPagePosition( - 10000, -10000);
            if (a.anchor) {
                a.anchor = a.origAnchor
            }
            a.showAt(a.getTargetXY());
            if (a.anchor) {
                a.syncAnchor();
                a.anchorEl.show()
            } else {
                a.anchorEl.hide()
            }
        }
    },
    showAt: function(b) {
        var a = this;
        a.lastActive = new Date();
        a.clearTimers();
        if (!a.isVisible()) {
            this.callParent(arguments)
        }
        if (a.isVisible()) {
            a.setPagePosition(b[0], b[1]);
            if (a.constrainPosition || a.constrain) {
                a.doConstrain()
            }
            a.toFront(true)
        }
        if (a.dismissDelay && a.autoHide !== false) {
            a.dismissTimer = Ext.defer(a.hide, a.dismissDelay, a)
        }
        if (a.anchor) {
            a.syncAnchor();
            if (!a.anchorEl.isVisible()) {
                a.anchorEl.show()
            }
        } else {
            a.anchorEl.hide()
        }
    },
    syncAnchor: function() {
        var c = this,
        a, b, d;
        switch (c.tipAnchor.charAt(0)) {
        case "t":
            a = "b";
            b = "tl";
            d = [20 + c.anchorOffset, 1];
            break;
        case "r":
            a = "l";
            b = "tr";
            d = [ - 1, 12 + c.anchorOffset];
            break;
        case "b":
            a = "t";
            b = "bl";
            d = [20 + c.anchorOffset, -1];
            break;
        default:
            a = "r";
            b = "tl";
            d = [1, 12 + c.anchorOffset];
            break
        }
        c.anchorEl.alignTo(c.el, a + "-" + b, d)
    },
    setPagePosition: function(a, c) {
        var b = this;
        b.callParent(arguments);
        if (b.anchor) {
            b.syncAnchor()
        }
    },
    clearTimer: function(a) {
        a = a + "Timer";
        clearTimeout(this[a]);
        delete this[a]
    },
    clearTimers: function() {
        var a = this;
        a.clearTimer("show");
        a.clearTimer("dismiss");
        a.clearTimer("hide")
    },
    onShow: function() {
        var a = this;
        a.callParent();
        a.mon(Ext.getDoc(), "mousedown", a.onDocMouseDown, a)
    },
    onHide: function() {
        var a = this;
        a.callParent();
        a.mun(Ext.getDoc(), "mousedown", a.onDocMouseDown, a)
    },
    onDocMouseDown: function(b) {
        var a = this;
        if (a.autoHide !== true && !a.closable && !b.within(a.el.dom)) {
            a.disable();
            Ext.defer(a.doEnable, 100, a)
        }
    },
    doEnable: function() {
        if (!this.isDestroyed) {
            this.enable()
        }
    },
    onDisable: function() {
        this.callParent();
        this.clearTimers();
        this.hide()
    },
    beforeDestroy: function() {
        var a = this;
        a.clearTimers();
        Ext.destroy(a.anchorEl);
        delete a.anchorEl;
        delete a.target;
        delete a.anchorTarget;
        delete a.triggerElement;
        a.callParent()
    },
    onDestroy: function() {
        Ext.getDoc().un("mousedown", this.onDocMouseDown, this);
        this.callParent()
    }
});
Ext.define("Ext.tip.QuickTip", {
    extend: "Ext.tip.ToolTip",
    alternateClassName: "Ext.QuickTip",
    interceptTitles: false,
    title: "&#160;",
    tagConfig: {
        namespace: "data-",
        attribute: "qtip",
        width: "qwidth",
        target: "target",
        title: "qtitle",
        hide: "hide",
        cls: "qclass",
        align: "qalign",
        anchor: "anchor"
    },
    initComponent: function() {
        var a = this;
        a.target = a.target || Ext.getDoc();
        a.targets = a.targets || {};
        a.callParent()
    },
    register: function(c) {
        var g = Ext.isArray(c) ? c: arguments,
        d = 0,
        a = g.length,
        f,
        b,
        e;
        for (; d < a; d++) {
            c = g[d];
            f = c.target;
            if (f) {
                if (Ext.isArray(f)) {
                    for (b = 0, e = f.length; b < e; b++) {
                        this.targets[Ext.id(f[b])] = c
                    }
                } else {
                    this.targets[Ext.id(f)] = c
                }
            }
        }
    },
    unregister: function(a) {
        delete this.targets[Ext.id(a)]
    },
    cancelShow: function(a) {
        var b = this,
        c = b.activeTarget;
        a = Ext.get(a).dom;
        if (b.isVisible()) {
            if (c && c.el == a) {
                b.hide()
            }
        } else {
            if (c && c.el == a) {
                b.clearTimer("show")
            }
        }
    },
    getTipCfg: function(d) {
        var c = d.getTarget(),
        b = c.title,
        a;
        if (this.interceptTitles && b && Ext.isString(b)) {
            c.qtip = b;
            c.removeAttribute("title");
            d.preventDefault();
            return {
                text: b
            }
        } else {
            a = this.tagConfig;
            c = d.getTarget("[" + a.namespace + a.attribute + "]");
            if (c) {
                return {
                    target: c,
                    text: c.getAttribute(a.namespace + a.attribute)
                }
            }
        }
    },
    onTargetOver: function(h) {
        var f = this,
        g = h.getTarget(),
        j,
        c,
        d,
        b,
        a;
        if (f.disabled) {
            return
        }
        f.targetXY = h.getXY();
        if (!g || g.nodeType !== 1 || g == document || g == document.body) {
            return
        }
        if (f.activeTarget && ((g == f.activeTarget.el) || Ext.fly(f.activeTarget.el).contains(g))) {
            f.clearTimer("hide");
            f.show();
            return
        }
        if (g) {
            Ext.Object.each(f.targets,
            function(e, k) {
                var l = Ext.fly(k.target);
                if (l && (l.dom === g || l.contains(g))) {
                    j = l.dom;
                    return false
                }
            });
            if (j) {
                f.activeTarget = f.targets[j.id];
                f.activeTarget.el = g;
                f.anchor = f.activeTarget.anchor;
                if (f.anchor) {
                    f.anchorTarget = g
                }
                f.delayShow();
                return
            }
        }
        j = Ext.get(g);
        c = f.tagConfig;
        d = c.namespace;
        b = f.getTipCfg(h);
        if (b) {
            if (b.target) {
                g = b.target;
                j = Ext.get(g)
            }
            a = j.getAttribute(d + c.hide);
            f.activeTarget = {
                el: g,
                text: b.text,
                width: +j.getAttribute(d + c.width) || null,
                autoHide: a != "user" && a !== "false",
                title: j.getAttribute(d + c.title),
                cls: j.getAttribute(d + c.cls),
                align: j.getAttribute(d + c.align)
            };
            f.anchor = j.getAttribute(d + c.anchor);
            if (f.anchor) {
                f.anchorTarget = g
            }
            f.delayShow()
        }
    },
    onTargetOut: function(b) {
        var a = this;
        if (a.activeTarget && b.within(a.activeTarget.el) && !a.getTipCfg(b)) {
            return
        }
        a.clearTimer("show");
        if (a.autoHide !== false) {
            a.delayHide()
        }
    },
    showAt: function(c) {
        var a = this,
        b = a.activeTarget;
        if (b) {
            if (!a.rendered) {
                a.render(Ext.getBody());
                a.activeTarget = b
            }
            if (b.title) {
                a.setTitle(b.title || "");
                a.header.show()
            } else {
                a.header.hide()
            }
            a.body.update(b.text);
            a.autoHide = b.autoHide;
            a.dismissDelay = b.dismissDelay || a.dismissDelay;
            if (a.lastCls) {
                a.el.removeCls(a.lastCls);
                delete a.lastCls
            }
            if (b.cls) {
                a.el.addCls(b.cls);
                a.lastCls = b.cls
            }
            a.setWidth(b.width);
            if (a.anchor) {
                a.constrainPosition = false
            } else {
                if (b.align) {
                    c = a.el.getAlignToXY(b.el, b.align);
                    a.constrainPosition = false
                } else {
                    a.constrainPosition = true
                }
            }
        }
        a.callParent([c])
    },
    hide: function() {
        delete this.activeTarget;
        this.callParent()
    }
});
Ext.define("Ext.tip.QuickTipManager",
function() {
    var b, a = false;
    return {
        requires: ["Ext.tip.QuickTip"],
        singleton: true,
        alternateClassName: "Ext.QuickTips",
        init: function(f, d) {
            if (!b) {
                if (!Ext.isReady) {
                    Ext.onReady(function() {
                        Ext.tip.QuickTipManager.init(f)
                    });
                    return
                }
                var c = Ext.apply({
                    disabled: a
                },
                d),
                e = c.className,
                g = c.xtype;
                if (e) {
                    delete c.className
                } else {
                    if (g) {
                        e = "widget." + g;
                        delete c.xtype
                    }
                }
                if (f !== false) {
                    c.renderTo = document.body;
                    if (c.renderTo.tagName != "BODY") {
                        Ext.Error.raise({
                            sourceClass: "Ext.tip.QuickTipManager",
                            sourceMethod: "init",
                            msg: "Cannot init QuickTipManager: no document body"
                        })
                    }
                }
                b = Ext.create(e || "Ext.tip.QuickTip", c)
            }
        },
        destroy: function() {
            if (b) {
                var c;
                b.destroy();
                b = c
            }
        },
        ddDisable: function() {
            if (b && !a) {
                b.disable()
            }
        },
        ddEnable: function() {
            if (b && !a) {
                b.enable()
            }
        },
        enable: function() {
            if (b) {
                b.enable()
            }
            a = false
        },
        disable: function() {
            if (b) {
                b.disable()
            }
            a = true
        },
        isEnabled: function() {
            return b !== undefined && !b.disabled
        },
        getQuickTip: function() {
            return b
        },
        register: function() {
            b.register.apply(b, arguments)
        },
        unregister: function() {
            b.unregister.apply(b, arguments)
        },
        tips: function() {
            b.register.apply(b, arguments)
        }
    }
} ());
Ext.define("Ext.app.Application", {
    extend: "Ext.app.Controller",
    requires: ["Ext.ModelManager", "Ext.data.Model", "Ext.data.StoreManager", "Ext.tip.QuickTipManager", "Ext.ComponentManager", "Ext.app.EventBus"],
    scope: undefined,
    enableQuickTips: true,
    appFolder: "app",
    autoCreateViewport: false,
    constructor: function(b) {
        b = b || {};
        Ext.apply(this, b);
        var d = b.requires || [];
        Ext.Loader.setPath(this.name, this.appFolder);
        if (this.paths) {
            Ext.Object.each(this.paths,
            function(g, h) {
                Ext.Loader.setPath(g, h)
            })
        }
        this.callParent(arguments);
        this.eventbus = Ext.create("Ext.app.EventBus");
        var f = Ext.Array.from(this.controllers),
        e = f && f.length,
        c,
        a;
        this.controllers = Ext.create("Ext.util.MixedCollection");
        if (this.autoCreateViewport) {
            d.push(this.getModuleClassName("Viewport", "view"))
        }
        for (c = 0; c < e; c++) {
            d.push(this.getModuleClassName(f[c], "controller"))
        }
        Ext.require(d);
        Ext.onReady(function() {
            for (c = 0; c < e; c++) {
                a = this.getController(f[c]);
                a.init(this)
            }
            this.onBeforeLaunch.call(this)
        },
        this)
    },
    control: function(b, c, a) {
        this.eventbus.control(b, c, a)
    },
    launch: Ext.emptyFn,
    onBeforeLaunch: function() {
        if (this.enableQuickTips) {
            Ext.tip.QuickTipManager.init()
        }
        if (this.autoCreateViewport) {
            this.getView("Viewport").create()
        }
        this.launch.call(this.scope || this);
        this.launched = true;
        this.fireEvent("launch", this);
        this.controllers.each(function(a) {
            a.onLaunch(this)
        },
        this)
    },
    getModuleClassName: function(a, c) {
        var b = Ext.Loader.getPrefix(a);
        if (b.length > 0 && b !== a) {
            return a
        }
        return this.name + "." + c + "." + a
    },
    getController: function(b) {
        var a = this.controllers.get(b);
        if (!a) {
            a = Ext.create(this.getModuleClassName(b, "controller"), {
                application: this,
                id: b
            });
            this.controllers.add(a)
        }
        return a
    },
    getStore: function(b) {
        var a = Ext.StoreManager.get(b);
        if (!a) {
            a = Ext.create(this.getModuleClassName(b, "store"), {
                storeId: b
            })
        }
        return a
    },
    getModel: function(a) {
        a = this.getModuleClassName(a, "model");
        return Ext.ModelManager.getModel(a)
    },
    getView: function(a) {
        a = this.getModuleClassName(a, "view");
        return Ext.ClassManager.get(a)
    }
});
Ext.define("Ext.util.Point", {
    extend: "Ext.util.Region",
    statics: {
        fromEvent: function(a) {
            a = (a.changedTouches && a.changedTouches.length > 0) ? a.changedTouches[0] : a;
            return new this(a.pageX, a.pageY)
        }
    },
    constructor: function(a, b) {
        this.callParent([b, a, b, a])
    },
    toString: function() {
        return "Point[" + this.x + "," + this.y + "]"
    },
    equals: function(a) {
        return (this.x == a.x && this.y == a.y)
    },
    isWithin: function(b, a) {
        if (!Ext.isObject(a)) {
            a = {
                x: a,
                y: a
            }
        }
        return (this.x <= b.x + a.x && this.x >= b.x - a.x && this.y <= b.y + a.y && this.y >= b.y - a.y)
    },
    roundedEquals: function(a) {
        return (Math.round(this.x) == Math.round(a.x) && Math.round(this.y) == Math.round(a.y))
    }
},
function() {
    this.prototype.translate = Ext.util.Region.prototype.translateBy
});
Ext.define("Ext.Layer", {
    uses: ["Ext.Shadow"],
    statics: {
        shims: []
    },
    extend: "Ext.Element",
    constructor: function(b, a) {
        b = b || {};
        var c = this,
        d = Ext.DomHelper,
        f = b.parentEl,
        e = f ? Ext.getDom(f) : document.body,
        g = b.hideMode;
        if (a) {
            c.dom = Ext.getDom(a)
        }
        if (!c.dom) {
            c.dom = d.append(e, b.dh || {
                tag: "div",
                cls: Ext.baseCSSPrefix + "layer"
            })
        } else {
            c.addCls(Ext.baseCSSPrefix + "layer");
            if (!c.dom.parentNode) {
                e.appendChild(c.dom)
            }
        }
        if (b.cls) {
            c.addCls(b.cls)
        }
        c.constrain = b.constrain !== false;
        if (g) {
            c.setVisibilityMode(Ext.Element[g.toUpperCase()]);
            if (c.visibilityMode == Ext.Element.ASCLASS) {
                c.visibilityCls = b.visibilityCls
            }
        } else {
            if (b.useDisplay) {
                c.setVisibilityMode(Ext.Element.DISPLAY)
            } else {
                c.setVisibilityMode(Ext.Element.VISIBILITY)
            }
        }
        if (b.id) {
            c.id = c.dom.id = b.id
        } else {
            c.id = Ext.id(c.dom)
        }
        c.position("absolute");
        if (b.shadow) {
            c.shadowOffset = b.shadowOffset || 4;
            c.shadow = Ext.create("Ext.Shadow", {
                offset: c.shadowOffset,
                mode: b.shadow
            });
            c.disableShadow()
        } else {
            c.shadowOffset = 0
        }
        c.useShim = b.shim !== false && Ext.useShims;
        if (b.hidden === true) {
            c.hide()
        } else {
            c.show()
        }
    },
    getZIndex: function() {
        return parseInt((this.getShim() || this).getStyle("z-index"), 10)
    },
    getShim: function() {
        var b = this,
        c, a;
        if (!b.useShim) {
            return null
        }
        if (!b.shim) {
            c = b.self.shims.shift();
            if (!c) {
                c = b.createShim();
                c.enableDisplayMode("block");
                c.hide()
            }
            a = b.dom.parentNode;
            if (c.dom.parentNode != a) {
                a.insertBefore(c.dom, b.dom)
            }
            b.shim = c
        }
        return b.shim
    },
    hideShim: function() {
        var a = this;
        if (a.shim) {
            a.shim.setDisplayed(false);
            a.self.shims.push(a.shim);
            delete a.shim
        }
    },
    disableShadow: function() {
        var a = this;
        if (a.shadow && !a.shadowDisabled) {
            a.shadowDisabled = true;
            a.shadow.hide();
            a.lastShadowOffset = a.shadowOffset;
            a.shadowOffset = 0
        }
    },
    enableShadow: function(a) {
        var b = this;
        if (b.shadow && b.shadowDisabled) {
            b.shadowDisabled = false;
            b.shadowOffset = b.lastShadowOffset;
            delete b.lastShadowOffset;
            if (a) {
                b.sync(true)
            }
        }
    },
    sync: function(b) {
        var j = this,
        n = j.shadow,
        g, e, a;
        if (!j.updating && j.isVisible() && (n || j.useShim)) {
            var d = j.getShim(),
            c = j.getLeft(true),
            o = j.getTop(true),
            m = j.dom.offsetWidth,
            f = j.dom.offsetHeight,
            k;
            if (n && !j.shadowDisabled) {
                if (b && !n.isVisible()) {
                    n.show(j)
                } else {
                    n.realign(c, o, m, f)
                }
                if (d) {
                    k = d.getStyle("z-index");
                    if (k > j.zindex) {
                        j.shim.setStyle("z-index", j.zindex - 2)
                    }
                    d.show();
                    if (n.isVisible()) {
                        g = n.el.getXY();
                        e = d.dom.style;
                        a = n.el.getSize();
                        if (Ext.supports.CSS3BoxShadow) {
                            a.height += 6;
                            a.width += 4;
                            g[0] -= 2;
                            g[1] -= 4
                        }
                        e.left = (g[0]) + "px";
                        e.top = (g[1]) + "px";
                        e.width = (a.width) + "px";
                        e.height = (a.height) + "px"
                    } else {
                        d.setSize(m, f);
                        d.setLeftTop(c, o)
                    }
                }
            } else {
                if (d) {
                    k = d.getStyle("z-index");
                    if (k > j.zindex) {
                        j.shim.setStyle("z-index", j.zindex - 2)
                    }
                    d.show();
                    d.setSize(m, f);
                    d.setLeftTop(c, o)
                }
            }
        }
        return j
    },
    remove: function() {
        this.hideUnders();
        this.callParent()
    },
    beginUpdate: function() {
        this.updating = true
    },
    endUpdate: function() {
        this.updating = false;
        this.sync(true)
    },
    hideUnders: function() {
        if (this.shadow) {
            this.shadow.hide()
        }
        this.hideShim()
    },
    constrainXY: function() {
        if (this.constrain) {
            var f = Ext.Element.getViewWidth(),
            b = Ext.Element.getViewHeight(),
            l = Ext.getDoc().getScroll(),
            k = this.getXY(),
            g = k[0],
            e = k[1],
            a = this.shadowOffset,
            j = this.dom.offsetWidth + a,
            c = this.dom.offsetHeight + a,
            d = false;
            if ((g + j) > f + l.left) {
                g = f - j - a;
                d = true
            }
            if ((e + c) > b + l.top) {
                e = b - c - a;
                d = true
            }
            if (g < l.left) {
                g = l.left;
                d = true
            }
            if (e < l.top) {
                e = l.top;
                d = true
            }
            if (d) {
                Ext.Layer.superclass.setXY.call(this, [g, e]);
                this.sync()
            }
        }
        return this
    },
    getConstrainOffset: function() {
        return this.shadowOffset
    },
    setVisible: function(e, b, d, g, f) {
        var c = this,
        a;
        a = function() {
            if (e) {
                c.sync(true)
            }
            if (g) {
                g()
            }
        };
        if (!e) {
            c.hideUnders(true)
        }
        c.callParent([e, b, d, g, f]);
        if (!b) {
            a()
        }
        return c
    },
    beforeFx: function() {
        this.beforeAction();
        return this.callParent(arguments)
    },
    afterFx: function() {
        this.callParent(arguments);
        this.sync(this.isVisible())
    },
    beforeAction: function() {
        if (!this.updating && this.shadow) {
            this.shadow.hide()
        }
    },
    setLeft: function(a) {
        this.callParent(arguments);
        return this.sync()
    },
    setTop: function(a) {
        this.callParent(arguments);
        return this.sync()
    },
    setLeftTop: function(b, a) {
        this.callParent(arguments);
        return this.sync()
    },
    setXY: function(d, a, c, f, e) {
        var b = this;
        f = b.createCB(f);
        b.fixDisplay();
        b.beforeAction();
        b.callParent([d, a, c, f, e]);
        if (!a) {
            f()
        }
        return b
    },
    createCB: function(c) {
        var a = this,
        b = a.shadow && a.shadow.isVisible();
        return function() {
            a.constrainXY();
            a.sync(b);
            if (c) {
                c()
            }
        }
    },
    setX: function(a, b, c, e, d) {
        this.setXY([a, this.getY()], b, c, e, d);
        return this
    },
    setY: function(e, a, b, d, c) {
        this.setXY([this.getX(), e], a, b, d, c);
        return this
    },
    setSize: function(a, c, b, e, g, f) {
        var d = this;
        g = d.createCB(g);
        d.beforeAction();
        d.callParent([a, c, b, e, g, f]);
        if (!b) {
            g()
        }
        return d
    },
    setWidth: function(a, b, d, f, e) {
        var c = this;
        f = c.createCB(f);
        c.beforeAction();
        c.callParent([a, b, d, f, e]);
        if (!b) {
            f()
        }
        return c
    },
    setHeight: function(b, a, d, f, e) {
        var c = this;
        f = c.createCB(f);
        c.beforeAction();
        c.callParent([b, a, d, f, e]);
        if (!a) {
            f()
        }
        return c
    },
    setBounds: function(g, f, a, j, b, c, h, d) {
        var e = this;
        h = e.createCB(h);
        e.beforeAction();
        if (!b) {
            Ext.Layer.superclass.setXY.call(e, [g, f]);
            Ext.Layer.superclass.setSize.call(e, a, j);
            h()
        } else {
            e.callParent([g, f, a, j, b, c, h, d])
        }
        return e
    },
    setZIndex: function(a) {
        var b = this;
        b.zindex = a;
        if (b.getShim()) {
            b.shim.setStyle("z-index", a++)
        }
        if (b.shadow) {
            b.shadow.setZIndex(a++)
        }
        return b.setStyle("z-index", a)
    },
    setOpacity: function(a) {
        if (this.shadow) {
            this.shadow.setOpacity(a)
        }
        return this.callParent(arguments)
    }
});
Ext.define("Ext.PluginManager", {
    extend: "Ext.AbstractManager",
    alternateClassName: "Ext.PluginMgr",
    singleton: true,
    typeName: "ptype",
    create: function(a, b) {
        if (a.init) {
            return a
        } else {
            return Ext.createByAlias("plugin." + (a.ptype || b), a)
        }
    },
    findByType: function(c, f) {
        var e = [],
        b = this.types;
        for (var a in b) {
            if (!b.hasOwnProperty(a)) {
                continue
            }
            var d = b[a];
            if (d.type == c && (!f || (f === true && d.isDefault))) {
                e.push(d)
            }
        }
        return e
    }
},
function() {
    Ext.preg = function() {
        return Ext.PluginManager.registerType.apply(Ext.PluginManager, arguments)
    }
});
Ext.define("Ext.LoadMask", {
    extend: "Ext.Component",
    alias: "widget.loadmask",
    mixins: {
        floating: "Ext.util.Floating"
    },
    uses: ["Ext.data.StoreManager"],
    msg: "Loading...",
    msgCls: Ext.baseCSSPrefix + "mask-loading",
    useMsg: true,
    disabled: false,
    baseCls: Ext.baseCSSPrefix + "mask-msg",
    renderTpl: '<div style="position:relative" class="{msgCls}"></div>',
    modal: true,
    floating: {
        shadow: "frame"
    },
    focusOnToFront: false,
    constructor: function(b, a) {
        var c = this;
        if (b.isComponent) {
            c.ownerCt = b;
            c.bindComponent(b)
        } else {
            c.ownerCt = new Ext.Component({
                el: Ext.get(b),
                rendered: true,
                componentLayoutCounter: 1
            });
            c.container = b
        }
        c.callParent([a]);
        if (c.store) {
            c.bindStore(c.store, true)
        }
        c.renderData = {
            msgCls: c.msgCls
        };
        c.renderSelectors = {
            msgEl: "div"
        }
    },
    bindComponent: function(a) {
        this.mon(a, {
            resize: this.onComponentResize,
            scope: this
        })
    },
    afterRender: function() {
        this.callParent(arguments);
        this.container = this.floatParent.getContentTarget()
    },
    onComponentResize: function() {
        var a = this;
        if (a.rendered && a.isVisible()) {
            a.toFront();
            a.center()
        }
    },
    bindStore: function(a, b) {
        var c = this;
        if (!b && c.store) {
            c.mun(c.store, {
                scope: c,
                beforeload: c.onBeforeLoad,
                load: c.onLoad,
                exception: c.onLoad
            });
            if (!a) {
                c.store = null
            }
        }
        if (a) {
            a = Ext.data.StoreManager.lookup(a);
            c.mon(a, {
                scope: c,
                beforeload: c.onBeforeLoad,
                load: c.onLoad,
                exception: c.onLoad
            })
        }
        c.store = a;
        if (a && a.isLoading()) {
            c.onBeforeLoad()
        }
    },
    onDisable: function() {
        this.callParent(arguments);
        if (this.loading) {
            this.onLoad()
        }
    },
    onBeforeLoad: function() {
        var c = this,
        a = c.ownerCt || c.floatParent,
        b;
        if (!this.disabled) {
            if (a.componentLayoutCounter) {
                Ext.Component.prototype.show.call(c)
            } else {
                b = a.afterComponentLayout;
                a.afterComponentLayout = function() {
                    a.afterComponentLayout = b;
                    b.apply(a, arguments);
                    if (c.loading) {
                        Ext.Component.prototype.show.call(c)
                    }
                }
            }
        }
    },
    onHide: function() {
        var a = this;
        a.callParent(arguments);
        a.showOnParentShow = true
    },
    onShow: function() {
        var b = this,
        a = b.msgEl;
        b.callParent(arguments);
        b.loading = true;
        if (b.useMsg) {
            a.show().update(b.msg)
        } else {
            a.parent().hide()
        }
    },
    afterShow: function() {
        this.callParent(arguments);
        this.center()
    },
    onLoad: function() {
        this.loading = false;
        Ext.Component.prototype.hide.call(this)
    }
});
Ext.define("Ext.layout.component.Auto", {
    alias: "layout.autocomponent",
    extend: "Ext.layout.component.Component",
    type: "autocomponent",
    onLayout: function(b, a) {
        this.setTargetSize(b, a)
    }
});
Ext.define("Ext.util.CSS",
function() {
    var d = null;
    var c = document;
    var b = /(-[a-z])/gi;
    var a = function(e, f) {
        return f.charAt(1).toUpperCase()
    };
    return {
        singleton: true,
        constructor: function() {
            this.rules = {};
            this.initialized = false
        },
        createStyleSheet: function(h, l) {
            var g, f = c.getElementsByTagName("head")[0],
            k = c.createElement("style");
            k.setAttribute("type", "text/css");
            if (l) {
                k.setAttribute("id", l)
            }
            if (Ext.isIE) {
                f.appendChild(k);
                g = k.styleSheet;
                g.cssText = h
            } else {
                try {
                    k.appendChild(c.createTextNode(h))
                } catch(j) {
                    k.cssText = h
                }
                f.appendChild(k);
                g = k.styleSheet ? k.styleSheet: (k.sheet || c.styleSheets[c.styleSheets.length - 1])
            }
            this.cacheStyleSheet(g);
            return g
        },
        removeStyleSheet: function(f) {
            var e = document.getElementById(f);
            if (e) {
                e.parentNode.removeChild(e)
            }
        },
        swapStyleSheet: function(h, e) {
            var g = document;
            this.removeStyleSheet(h);
            var f = g.createElement("link");
            f.setAttribute("rel", "stylesheet");
            f.setAttribute("type", "text/css");
            f.setAttribute("id", h);
            f.setAttribute("href", e);
            g.getElementsByTagName("head")[0].appendChild(f)
        },
        refreshCache: function() {
            return this.getRules(true)
        },
        cacheStyleSheet: function(k) {
            if (!d) {
                d = {}
            }
            try {
                var n = k.cssRules || k.rules,
                l, h = n.length - 1,
                f, g;
                for (; h >= 0; --h) {
                    l = n[h].selectorText;
                    if (l) {
                        l = l.split(",");
                        g = l.length;
                        for (f = 0; f < g; f++) {
                            d[Ext.String.trim(l[f]).toLowerCase()] = n[h]
                        }
                    }
                }
            } catch(m) {}
        },
        getRules: function(g) {
            if (d === null || g) {
                d = {};
                var j = c.styleSheets,
                h = 0,
                f = j.length;
                for (; h < f; h++) {
                    try {
                        if (!j[h].disabled) {
                            this.cacheStyleSheet(j[h])
                        }
                    } catch(k) {}
                }
            }
            return d
        },
        getRule: function(e, g) {
            var f = this.getRules(g);
            if (!Ext.isArray(e)) {
                return f[e.toLowerCase()]
            }
            for (var h = 0; h < e.length; h++) {
                if (f[e[h]]) {
                    return f[e[h].toLowerCase()]
                }
            }
            return null
        },
        updateRule: function(e, h, g) {
            if (!Ext.isArray(e)) {
                var j = this.getRule(e);
                if (j) {
                    j.style[h.replace(b, a)] = g;
                    return true
                }
            } else {
                for (var f = 0; f < e.length; f++) {
                    if (this.updateRule(e[f], h, g)) {
                        return true
                    }
                }
            }
            return false
        }
    }
} ());
Ext.define("Ext.panel.Tool", {
    extend: "Ext.Component",
    requires: ["Ext.tip.QuickTipManager"],
    alias: "widget.tool",
    baseCls: Ext.baseCSSPrefix + "tool",
    disabledCls: Ext.baseCSSPrefix + "tool-disabled",
    toolPressedCls: Ext.baseCSSPrefix + "tool-pressed",
    toolOverCls: Ext.baseCSSPrefix + "tool-over",
    ariaRole: "button",
    renderTpl: ['<img id="{id}-toolEl" src="{blank}" class="{baseCls}-{type}" role="presentation"/>'],
    tooltipType: "qtip",
    stopEvent: true,
    initComponent: function() {
        var b = this;
        b.addEvents("click");
        var a = ["close", "collapse", "down", "expand", "gear", "help", "left", "maximize", "minimize", "minus", "move", "next", "pin", "plus", "prev", "print", "refresh", "resize", "restore", "right", "save", "search", "toggle", "unpin", "up"];
        if (b.id && Ext.Array.indexOf(a, b.id) > -1 && Ext.global.console) {
            Ext.global.console.warn("When specifying a tool you should use the type option, the id can conflict now that tool is a Component")
        }
        b.type = b.type || b.id;
        Ext.applyIf(b.renderData, {
            baseCls: b.baseCls,
            blank: Ext.BLANK_IMAGE_URL,
            type: b.type
        });
        b.addChildEls("toolEl");
        b.tooltip = b.tooltip || b.qtip;
        b.callParent()
    },
    afterRender: function() {
        var b = this,
        a;
        b.callParent(arguments);
        if (b.tooltip) {
            if (Ext.isObject(b.tooltip)) {
                Ext.tip.QuickTipManager.register(Ext.apply({
                    target: b.id
                },
                b.tooltip))
            } else {
                a = b.tooltipType == "qtip" ? "data-qtip": "title";
                b.toolEl.dom.setAttribute(a, b.tooltip)
            }
        }
        b.mon(b.toolEl, {
            click: b.onClick,
            mousedown: b.onMouseDown,
            mouseover: b.onMouseOver,
            mouseout: b.onMouseOut,
            scope: b
        })
    },
    setType: function(a) {
        var b = this;
        b.type = a;
        if (b.rendered) {
            b.toolEl.dom.className = b.baseCls + "-" + a
        }
        return b
    },
    bindTo: function(a) {
        this.owner = a
    },
    onClick: function(d, c) {
        var b = this,
        a;
        if (b.disabled) {
            return false
        }
        a = b.owner || b.ownerCt;
        b.el.removeCls(b.toolPressedCls);
        b.el.removeCls(b.toolOverCls);
        if (b.stopEvent !== false) {
            d.stopEvent()
        }
        Ext.callback(b.handler, b.scope || b, [d, c, a, b]);
        b.fireEvent("click", b, d);
        return true
    },
    onDestroy: function() {
        if (Ext.isObject(this.tooltip)) {
            Ext.tip.QuickTipManager.unregister(this.id)
        }
        this.callParent()
    },
    onMouseDown: function() {
        if (this.disabled) {
            return false
        }
        this.el.addCls(this.toolPressedCls)
    },
    onMouseOver: function() {
        if (this.disabled) {
            return false
        }
        this.el.addCls(this.toolOverCls)
    },
    onMouseOut: function() {
        this.el.removeCls(this.toolOverCls)
    }
});
Ext.define("Ext.resizer.Resizer", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    uses: ["Ext.resizer.ResizeTracker", "Ext.Component"],
    alternateClassName: "Ext.Resizable",
    handleCls: Ext.baseCSSPrefix + "resizable-handle",
    pinnedCls: Ext.baseCSSPrefix + "resizable-pinned",
    overCls: Ext.baseCSSPrefix + "resizable-over",
    wrapCls: Ext.baseCSSPrefix + "resizable-wrap",
    dynamic: true,
    handles: "s e se",
    height: null,
    width: null,
    heightIncrement: 0,
    widthIncrement: 0,
    minHeight: 20,
    minWidth: 20,
    maxHeight: 10000,
    maxWidth: 10000,
    pinned: false,
    preserveRatio: false,
    transparent: false,
    possiblePositions: {
        n: "north",
        s: "south",
        e: "east",
        w: "west",
        se: "southeast",
        sw: "southwest",
        nw: "northwest",
        ne: "northeast"
    },
    constructor: function(a) {
        var g = this,
        f, l, k = g.handles,
        b, j, e, c = 0,
        h;
        this.addEvents("beforeresize", "resizedrag", "resize");
        if (Ext.isString(a) || Ext.isElement(a) || a.dom) {
            f = a;
            a = arguments[1] || {};
            a.target = f
        }
        g.mixins.observable.constructor.call(g, a);
        f = g.target;
        if (f) {
            if (f.isComponent) {
                g.el = f.getEl();
                if (f.minWidth) {
                    g.minWidth = f.minWidth
                }
                if (f.minHeight) {
                    g.minHeight = f.minHeight
                }
                if (f.maxWidth) {
                    g.maxWidth = f.maxWidth
                }
                if (f.maxHeight) {
                    g.maxHeight = f.maxHeight
                }
                if (f.floating) {
                    if (!this.hasOwnProperty("handles")) {
                        this.handles = "n ne e se s sw w nw"
                    }
                }
            } else {
                g.el = g.target = Ext.get(f)
            }
        } else {
            g.target = g.el = Ext.get(g.el)
        }
        l = g.el.dom.tagName;
        if (l == "TEXTAREA" || l == "IMG") {
            g.originalTarget = g.target;
            g.target = g.el = g.el.wrap({
                cls: g.wrapCls,
                id: g.el.id + "-rzwrap"
            });
            g.el.setPositioning(g.originalTarget.getPositioning());
            g.originalTarget.clearPositioning();
            var d = g.originalTarget.getBox();
            g.el.setBox(d)
        }
        g.el.position();
        if (g.pinned) {
            g.el.addCls(g.pinnedCls)
        }
        g.resizeTracker = Ext.create("Ext.resizer.ResizeTracker", {
            disabled: g.disabled,
            target: g.target,
            constrainTo: g.constrainTo,
            overCls: g.overCls,
            throttle: g.throttle,
            originalTarget: g.originalTarget,
            delegate: "." + g.handleCls,
            dynamic: g.dynamic,
            preserveRatio: g.preserveRatio,
            heightIncrement: g.heightIncrement,
            widthIncrement: g.widthIncrement,
            minHeight: g.minHeight,
            maxHeight: g.maxHeight,
            minWidth: g.minWidth,
            maxWidth: g.maxWidth
        });
        g.resizeTracker.on("mousedown", g.onBeforeResize, g);
        g.resizeTracker.on("drag", g.onResize, g);
        g.resizeTracker.on("dragend", g.onResizeEnd, g);
        if (g.handles == "all") {
            g.handles = "n s e w ne nw se sw"
        }
        k = g.handles = g.handles.split(/ |\s*?[,;]\s*?/);
        j = g.possiblePositions;
        e = k.length;
        b = g.handleCls + " " + (this.target.isComponent ? (g.target.baseCls + "-handle ") : "") + g.handleCls + "-";
        for (; c < e; c++) {
            if (k[c] && j[k[c]]) {
                h = j[k[c]];
                g[h] = Ext.create("Ext.Component", {
                    owner: this,
                    region: h,
                    cls: b + h,
                    renderTo: g.el
                });
                g[h].el.unselectable();
                if (g.transparent) {
                    g[h].el.setOpacity(0)
                }
            }
        }
        if (Ext.isNumber(g.width)) {
            g.width = Ext.Number.constrain(g.width, g.minWidth, g.maxWidth)
        }
        if (Ext.isNumber(g.height)) {
            g.height = Ext.Number.constrain(g.height, g.minHeight, g.maxHeight)
        }
        if (g.width != null || g.height != null) {
            if (g.originalTarget) {
                g.originalTarget.setWidth(g.width);
                g.originalTarget.setHeight(g.height)
            }
            g.resizeTo(g.width, g.height)
        }
        g.forceHandlesHeight()
    },
    disable: function() {
        this.resizeTracker.disable()
    },
    enable: function() {
        this.resizeTracker.enable()
    },
    onBeforeResize: function(c, d) {
        var a = this.target.getBox();
        return this.fireEvent("beforeresize", this, a.width, a.height, d)
    },
    onResize: function(d, f) {
        var c = this,
        a = c.target.getBox();
        c.forceHandlesHeight();
        return c.fireEvent("resizedrag", c, a.width, a.height, f)
    },
    onResizeEnd: function(d, f) {
        var c = this,
        a = c.target.getBox();
        c.forceHandlesHeight();
        return c.fireEvent("resize", c, a.width, a.height, f)
    },
    resizeTo: function(b, a) {
        this.target.setSize(b, a);
        this.fireEvent("resize", this, b, a, null)
    },
    getEl: function() {
        return this.el
    },
    getTarget: function() {
        return this.target
    },
    destroy: function() {
        var c;
        for (var b = 0,
        a = this.handles.length; b < a; b++) {
            c = this[this.possiblePositions[this.handles[b]]];
            delete c.owner;
            Ext.destroy(c)
        }
    },
    forceHandlesHeight: function() {
        var a = this,
        b;
        if (Ext.isIE6) {
            b = a.east;
            if (b) {
                b.setHeight(a.el.getHeight())
            }
            b = a.west;
            if (b) {
                b.setHeight(a.el.getHeight())
            }
            a.el.repaint()
        }
    }
});
Ext.define("Ext.data.Batch", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    autoStart: false,
    current: -1,
    total: 0,
    isRunning: false,
    isComplete: false,
    hasException: false,
    pauseOnException: true,
    constructor: function(a) {
        var b = this;
        b.addEvents("complete", "exception", "operationcomplete");
        b.mixins.observable.constructor.call(b, a);
        b.operations = []
    },
    add: function(a) {
        this.total++;
        a.setBatch(this);
        this.operations.push(a)
    },
    start: function() {
        this.hasException = false;
        this.isRunning = true;
        this.runNextOperation()
    },
    runNextOperation: function() {
        this.runOperation(this.current + 1)
    },
    pause: function() {
        this.isRunning = false
    },
    runOperation: function(d) {
        var e = this,
        c = e.operations,
        b = c[d],
        a;
        if (b === undefined) {
            e.isRunning = false;
            e.isComplete = true;
            e.fireEvent("complete", e, c[c.length - 1])
        } else {
            e.current = d;
            a = function(f) {
                var g = f.hasException();
                if (g) {
                    e.hasException = true;
                    e.fireEvent("exception", e, f)
                } else {
                    e.fireEvent("operationcomplete", e, f)
                }
                if (g && e.pauseOnException) {
                    e.pause()
                } else {
                    f.setCompleted();
                    e.runNextOperation()
                }
            };
            b.setStarted();
            e.proxy[b.action](b, a, e)
        }
    }
});
Ext.define("Ext.data.Request", {
    action: undefined,
    params: undefined,
    method: "GET",
    url: undefined,
    constructor: function(a) {
        Ext.apply(this, a)
    }
});
Ext.define("Ext.menu.Item", {
    extend: "Ext.Component",
    alias: "widget.menuitem",
    alternateClassName: "Ext.menu.TextItem",
    activeCls: Ext.baseCSSPrefix + "menu-item-active",
    ariaRole: "menuitem",
    canActivate: true,
    clickHideDelay: 1,
    destroyMenu: true,
    disabledCls: Ext.baseCSSPrefix + "menu-item-disabled",
    hideOnClick: true,
    isMenuItem: true,
    menuAlign: "tl-tr?",
    menuExpandDelay: 200,
    menuHideDelay: 200,
    renderTpl: ['<tpl if="plain">', "{text}", "</tpl>", '<tpl if="!plain">', '<a id="{id}-itemEl" class="' + Ext.baseCSSPrefix + 'menu-item-link" href="{href}" <tpl if="hrefTarget">target="{hrefTarget}"</tpl> hidefocus="true" unselectable="on">', '<img id="{id}-iconEl" src="{icon}" class="' + Ext.baseCSSPrefix + 'menu-item-icon {iconCls}" />', '<span id="{id}-textEl" class="' + Ext.baseCSSPrefix + 'menu-item-text" <tpl if="menu">style="margin-right: 17px;"</tpl> >{text}</span>', '<tpl if="menu">', '<img id="{id}-arrowEl" src="{blank}" class="' + Ext.baseCSSPrefix + 'menu-item-arrow" />', "</tpl>", "</a>", "</tpl>"],
    maskOnDisable: false,
    activate: function() {
        var a = this;
        if (!a.activated && a.canActivate && a.rendered && !a.isDisabled() && a.isVisible()) {
            a.el.addCls(a.activeCls);
            a.focus();
            a.activated = true;
            a.fireEvent("activate", a)
        }
    },
    blur: function() {
        this.$focused = false;
        this.callParent(arguments)
    },
    deactivate: function() {
        var a = this;
        if (a.activated) {
            a.el.removeCls(a.activeCls);
            a.blur();
            a.hideMenu();
            a.activated = false;
            a.fireEvent("deactivate", a)
        }
    },
    deferExpandMenu: function() {
        var a = this;
        if (!a.menu.rendered || !a.menu.isVisible()) {
            a.parentMenu.activeChild = a.menu;
            a.menu.parentItem = a;
            a.menu.parentMenu = a.menu.ownerCt = a.parentMenu;
            a.menu.showBy(a, a.menuAlign)
        }
    },
    deferHideMenu: function() {
        if (this.menu.isVisible()) {
            this.menu.hide()
        }
    },
    deferHideParentMenus: function() {
        Ext.menu.Manager.hideAll()
    },
    expandMenu: function(a) {
        var b = this;
        if (b.menu) {
            clearTimeout(b.hideMenuTimer);
            if (a === 0) {
                b.deferExpandMenu()
            } else {
                b.expandMenuTimer = Ext.defer(b.deferExpandMenu, Ext.isNumber(a) ? a: b.menuExpandDelay, b)
            }
        }
    },
    focus: function() {
        this.$focused = true;
        this.callParent(arguments)
    },
    getRefItems: function(a) {
        var c = this.menu,
        b;
        if (c) {
            b = c.getRefItems(a);
            b.unshift(c)
        }
        return b || []
    },
    hideMenu: function(a) {
        var b = this;
        if (b.menu) {
            clearTimeout(b.expandMenuTimer);
            b.hideMenuTimer = Ext.defer(b.deferHideMenu, Ext.isNumber(a) ? a: b.menuHideDelay, b)
        }
    },
    initComponent: function() {
        var b = this,
        c = Ext.baseCSSPrefix,
        a = [c + "menu-item"];
        b.addEvents("activate", "click", "deactivate");
        if (b.plain) {
            a.push(c + "menu-item-plain")
        }
        if (b.cls) {
            a.push(b.cls)
        }
        b.cls = a.join(" ");
        if (b.menu) {
            b.menu = Ext.menu.Manager.get(b.menu)
        }
        b.callParent(arguments)
    },
    onClick: function(b) {
        var a = this;
        if (!a.href) {
            b.stopEvent()
        }
        if (a.disabled) {
            return
        }
        if (a.hideOnClick) {
            a.deferHideParentMenusTimer = Ext.defer(a.deferHideParentMenus, a.clickHideDelay, a)
        }
        Ext.callback(a.handler, a.scope || a, [a, b]);
        a.fireEvent("click", a, b);
        if (!a.hideOnClick) {
            a.focus()
        }
    },
    onDestroy: function() {
        var a = this;
        clearTimeout(a.expandMenuTimer);
        clearTimeout(a.hideMenuTimer);
        clearTimeout(a.deferHideParentMenusTimer);
        if (a.menu) {
            delete a.menu.parentItem;
            delete a.menu.parentMenu;
            delete a.menu.ownerCt;
            if (a.destroyMenu !== false) {
                a.menu.destroy()
            }
        }
        a.callParent(arguments)
    },
    onRender: function(a, d) {
        var b = this,
        c = Ext.BLANK_IMAGE_URL;
        Ext.applyIf(b.renderData, {
            href: b.href || "#",
            hrefTarget: b.hrefTarget,
            icon: b.icon || c,
            iconCls: b.iconCls + (b.checkChangeDisabled ? " " + b.disabledCls: ""),
            menu: Ext.isDefined(b.menu),
            plain: b.plain,
            text: b.text,
            blank: c
        });
        b.addChildEls("itemEl", "iconEl", "textEl", "arrowEl");
        b.callParent(arguments)
    },
    setHandler: function(b, a) {
        this.handler = b || null;
        this.scope = a
    },
    setIconCls: function(a) {
        var b = this;
        if (b.iconEl) {
            if (b.iconCls) {
                b.iconEl.removeCls(b.iconCls)
            }
            if (a) {
                b.iconEl.addCls(a)
            }
        }
        b.iconCls = a
    },
    setText: function(c) {
        var b = this,
        a = b.textEl || b.el;
        b.text = c;
        if (b.rendered) {
            a.update(c || "");
            b.ownerCt.redoComponentLayout()
        }
    }
});
Ext.define("Ext.menu.KeyNav", {
    extend: "Ext.util.KeyNav",
    requires: ["Ext.FocusManager"],
    constructor: function(b) {
        var a = this;
        a.menu = b;
        a.callParent([b.el, {
            down: a.down,
            enter: a.enter,
            esc: a.escape,
            left: a.left,
            right: a.right,
            space: a.enter,
            tab: a.tab,
            up: a.up
        }])
    },
    down: function(b) {
        var a = this,
        c = a.menu.focusedItem;
        if (c && b.getKey() == Ext.EventObject.DOWN && a.isWhitelisted(c)) {
            return true
        }
        a.focusNextItem(1)
    },
    enter: function(b) {
        var c = this.menu,
        a = c.focusedItem;
        if (c.activeItem) {
            c.onClick(b)
        } else {
            if (a && a.isFormField) {
                return true
            }
        }
    },
    escape: function(a) {
        Ext.menu.Manager.hideAll()
    },
    focusNextItem: function(f) {
        var g = this.menu,
        b = g.items,
        d = g.focusedItem,
        c = d ? b.indexOf(d) : -1,
        a = c + f;
        while (a != c) {
            if (a < 0) {
                a = b.length - 1
            } else {
                if (a >= b.length) {
                    a = 0
                }
            }
            var e = b.getAt(a);
            if (g.canActivateItem(e)) {
                g.setActiveItem(e);
                break
            }
            a += f
        }
    },
    isWhitelisted: function(a) {
        return Ext.FocusManager.isWhitelisted(a)
    },
    left: function(b) {
        var c = this.menu,
        d = c.focusedItem,
        a = c.activeItem;
        if (d && this.isWhitelisted(d)) {
            return true
        }
        c.hide();
        if (c.parentMenu) {
            c.parentMenu.focus()
        }
    },
    right: function(c) {
        var d = this.menu,
        f = d.focusedItem,
        a = d.activeItem,
        b;
        if (f && this.isWhitelisted(f)) {
            return true
        }
        if (a) {
            b = d.activeItem.menu;
            if (b) {
                a.expandMenu(0);
                Ext.defer(function() {
                    b.setActiveItem(b.items.getAt(0))
                },
                25)
            }
        }
    },
    tab: function(b) {
        var a = this;
        if (b.shiftKey) {
            a.up(b)
        } else {
            a.down(b)
        }
    },
    up: function(b) {
        var a = this,
        c = a.menu.focusedItem;
        if (c && b.getKey() == Ext.EventObject.UP && a.isWhitelisted(c)) {
            return true
        }
        a.focusNextItem( - 1)
    }
});
Ext.define("Ext.layout.component.Draw", {
    alias: "layout.draw",
    extend: "Ext.layout.component.Auto",
    type: "draw",
    onLayout: function(b, a) {
        this.owner.surface.setSize(b, a);
        this.callParent(arguments)
    }
});
Ext.define("Ext.menu.CheckItem", {
    extend: "Ext.menu.Item",
    alias: "widget.menucheckitem",
    checkedCls: Ext.baseCSSPrefix + "menu-item-checked",
    uncheckedCls: Ext.baseCSSPrefix + "menu-item-unchecked",
    groupCls: Ext.baseCSSPrefix + "menu-group-icon",
    hideOnClick: false,
    afterRender: function() {
        var a = this;
        this.callParent();
        a.checked = !a.checked;
        a.setChecked(!a.checked, true)
    },
    initComponent: function() {
        var a = this;
        a.addEvents("beforecheckchange", "checkchange");
        a.callParent(arguments);
        Ext.menu.Manager.registerCheckable(a);
        if (a.group) {
            if (!a.iconCls) {
                a.iconCls = a.groupCls
            }
            if (a.initialConfig.hideOnClick !== false) {
                a.hideOnClick = true
            }
        }
    },
    disableCheckChange: function() {
        var a = this;
        if (a.iconEl) {
            a.iconEl.addCls(a.disabledCls)
        }
        a.checkChangeDisabled = true
    },
    enableCheckChange: function() {
        var a = this;
        a.iconEl.removeCls(a.disabledCls);
        a.checkChangeDisabled = false
    },
    onClick: function(b) {
        var a = this;
        if (!a.disabled && !a.checkChangeDisabled && !(a.checked && a.group)) {
            a.setChecked(!a.checked)
        }
        this.callParent([b])
    },
    onDestroy: function() {
        Ext.menu.Manager.unregisterCheckable(this);
        this.callParent(arguments)
    },
    setChecked: function(c, a) {
        var b = this;
        if (b.checked !== c && (a || b.fireEvent("beforecheckchange", b, c) !== false)) {
            if (b.el) {
                b.el[c ? "addCls": "removeCls"](b.checkedCls)[!c ? "addCls": "removeCls"](b.uncheckedCls)
            }
            b.checked = c;
            Ext.menu.Manager.onCheckChange(b, c);
            if (!a) {
                Ext.callback(b.checkHandler, b.scope, [b, c]);
                b.fireEvent("checkchange", b, c)
            }
        }
    }
});
Ext.define("Ext.ElementLoader", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    uses: ["Ext.data.Connection", "Ext.Ajax"],
    statics: {
        Renderer: {
            Html: function(a, b, c) {
                a.getTarget().update(b.responseText, c.scripts === true);
                return true
            }
        }
    },
    url: null,
    params: null,
    baseParams: null,
    autoLoad: false,
    target: null,
    loadMask: false,
    ajaxOptions: null,
    scripts: false,
    isLoader: true,
    constructor: function(b) {
        var c = this,
        a;
        b = b || {};
        Ext.apply(c, b);
        c.setTarget(c.target);
        c.addEvents("beforeload", "exception", "load");
        c.mixins.observable.constructor.call(c);
        if (c.autoLoad) {
            a = c.autoLoad;
            if (a === true) {
                a = {}
            }
            c.load(a)
        }
    },
    setTarget: function(b) {
        var a = this;
        b = Ext.get(b);
        if (a.target && a.target != b) {
            a.abort()
        }
        a.target = b
    },
    getTarget: function() {
        return this.target || null
    },
    abort: function() {
        var a = this.active;
        if (a !== undefined) {
            Ext.Ajax.abort(a.request);
            if (a.mask) {
                this.removeMask()
            }
            delete this.active
        }
    },
    removeMask: function() {
        this.target.unmask()
    },
    addMask: function(a) {
        this.target.mask(a === true ? null: a)
    },
    load: function(h) {
        if (!this.target) {
            Ext.Error.raise("A valid target is required when loading content")
        }
        h = Ext.apply({},
        h);
        var e = this,
        d = e.target,
        j = Ext.isDefined(h.loadMask) ? h.loadMask: e.loadMask,
        b = Ext.apply({},
        h.params),
        a = Ext.apply({},
        h.ajaxOptions),
        f = h.callback || e.callback,
        g = h.scope || e.scope || e,
        c;
        Ext.applyIf(a, e.ajaxOptions);
        Ext.applyIf(h, a);
        Ext.applyIf(b, e.params);
        Ext.apply(b, e.baseParams);
        Ext.applyIf(h, {
            url: e.url
        });
        if (!h.url) {
            Ext.Error.raise("You must specify the URL from which content should be loaded")
        }
        Ext.apply(h, {
            scope: e,
            params: b,
            callback: e.onComplete
        });
        if (e.fireEvent("beforeload", e, h) === false) {
            return
        }
        if (j) {
            e.addMask(j)
        }
        c = Ext.Ajax.request(h);
        e.active = {
            request: c,
            options: h,
            mask: j,
            scope: g,
            callback: f,
            success: h.success || e.success,
            failure: h.failure || e.failure,
            renderer: h.renderer || e.renderer,
            scripts: Ext.isDefined(h.scripts) ? h.scripts: e.scripts
        };
        e.setOptions(e.active, h)
    },
    setOptions: Ext.emptyFn,
    onComplete: function(b, g, a) {
        var d = this,
        f = d.active,
        c = f.scope,
        e = d.getRenderer(f.renderer);
        if (g) {
            g = e.call(d, d, a, f)
        }
        if (g) {
            Ext.callback(f.success, c, [d, a, b]);
            d.fireEvent("load", d, a, b)
        } else {
            Ext.callback(f.failure, c, [d, a, b]);
            d.fireEvent("exception", d, a, b)
        }
        Ext.callback(f.callback, c, [d, g, a, b]);
        if (f.mask) {
            d.removeMask()
        }
        delete d.active
    },
    getRenderer: function(a) {
        if (Ext.isFunction(a)) {
            return a
        }
        return this.statics().Renderer.Html
    },
    startAutoRefresh: function(a, b) {
        var c = this;
        c.stopAutoRefresh();
        c.autoRefresh = setInterval(function() {
            c.load(b)
        },
        a)
    },
    stopAutoRefresh: function() {
        clearInterval(this.autoRefresh);
        delete this.autoRefresh
    },
    isAutoRefreshing: function() {
        return Ext.isDefined(this.autoRefresh)
    },
    destroy: function() {
        var a = this;
        a.stopAutoRefresh();
        delete a.target;
        a.abort();
        a.clearListeners()
    }
});
Ext.define("Ext.util.Grouper", {
    extend: "Ext.util.Sorter",
    getGroupString: function(a) {
        return a.get(this.property)
    }
});
Ext.define("Ext.layout.container.AbstractFit", {
    extend: "Ext.layout.container.Container",
    itemCls: Ext.baseCSSPrefix + "fit-item",
    targetCls: Ext.baseCSSPrefix + "layout-fit",
    type: "fit"
});
Ext.define("Ext.data.AbstractStore", {
    requires: ["Ext.util.MixedCollection", "Ext.data.Operation", "Ext.util.Filter"],
    mixins: {
        observable: "Ext.util.Observable",
        sortable: "Ext.util.Sortable"
    },
    statics: {
        create: function(a) {
            if (!a.isStore) {
                if (!a.type) {
                    a.type = "store"
                }
                a = Ext.createByAlias("store." + a.type, a)
            }
            return a
        }
    },
    remoteSort: false,
    remoteFilter: false,
    autoLoad: false,
    autoSync: false,
    batchUpdateMode: "operation",
    filterOnLoad: true,
    sortOnLoad: true,
    implicitModel: false,
    defaultProxyType: "memory",
    isDestroyed: false,
    isStore: true,
    sortRoot: "data",
    constructor: function(a) {
        var c = this,
        b;
        c.addEvents("add", "remove", "update", "datachanged", "beforeload", "load", "write", "beforesync", "clear");
        Ext.apply(c, a);
        c.removed = [];
        c.mixins.observable.constructor.apply(c, arguments);
        c.model = Ext.ModelManager.getModel(c.model);
        Ext.applyIf(c, {
            modelDefaults: {}
        });
        if (!c.model && c.fields) {
            c.model = Ext.define("Ext.data.Store.ImplicitModel-" + (c.storeId || Ext.id()), {
                extend: "Ext.data.Model",
                fields: c.fields,
                proxy: c.proxy || c.defaultProxyType
            });
            delete c.fields;
            c.implicitModel = true
        }
        if (!c.model) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Store defined with no model. You may have mistyped the model name.")
            }
        }
        c.setProxy(c.proxy || c.model.getProxy());
        if (c.id && !c.storeId) {
            c.storeId = c.id;
            delete c.id
        }
        if (c.storeId) {
            Ext.data.StoreManager.register(c)
        }
        c.mixins.sortable.initSortable.call(c);
        b = c.decodeFilters(c.filters);
        c.filters = Ext.create("Ext.util.MixedCollection");
        c.filters.addAll(b)
    },
    setProxy: function(a) {
        var b = this;
        if (a instanceof Ext.data.proxy.Proxy) {
            a.setModel(b.model)
        } else {
            if (Ext.isString(a)) {
                a = {
                    type: a
                }
            }
            Ext.applyIf(a, {
                model: b.model
            });
            a = Ext.createByAlias("proxy." + a.type, a)
        }
        b.proxy = a;
        return b.proxy
    },
    getProxy: function() {
        return this.proxy
    },
    create: function(e, c) {
        var d = this,
        a = Ext.ModelManager.create(Ext.applyIf(e, d.modelDefaults), d.model.modelName),
        b;
        c = c || {};
        Ext.applyIf(c, {
            action: "create",
            records: [a]
        });
        b = Ext.create("Ext.data.Operation", c);
        d.proxy.create(b, d.onProxyWrite, d);
        return a
    },
    read: function() {
        return this.load.apply(this, arguments)
    },
    onProxyRead: Ext.emptyFn,
    update: function(b) {
        var c = this,
        a;
        b = b || {};
        Ext.applyIf(b, {
            action: "update",
            records: c.getUpdatedRecords()
        });
        a = Ext.create("Ext.data.Operation", b);
        return c.proxy.update(a, c.onProxyWrite, c)
    },
    onProxyWrite: function(b) {
        var c = this,
        d = b.wasSuccessful(),
        a = b.getRecords();
        switch (b.action) {
        case "create":
            c.onCreateRecords(a, b, d);
            break;
        case "update":
            c.onUpdateRecords(a, b, d);
            break;
        case "destroy":
            c.onDestroyRecords(a, b, d);
            break
        }
        if (d) {
            c.fireEvent("write", c, b);
            c.fireEvent("datachanged", c)
        }
        Ext.callback(b.callback, b.scope || c, [a, b, d])
    },
    destroy: function(b) {
        var c = this,
        a;
        b = b || {};
        Ext.applyIf(b, {
            action: "destroy",
            records: c.getRemovedRecords()
        });
        a = Ext.create("Ext.data.Operation", b);
        return c.proxy.destroy(a, c.onProxyWrite, c)
    },
    onBatchOperationComplete: function(b, a) {
        return this.onProxyWrite(a)
    },
    onBatchComplete: function(c, a) {
        var f = this,
        b = c.operations,
        e = b.length,
        d;
        f.suspendEvents();
        for (d = 0; d < e; d++) {
            f.onProxyWrite(b[d])
        }
        f.resumeEvents();
        f.fireEvent("datachanged", f)
    },
    onBatchException: function(b, a) {},
    filterNew: function(a) {
        return a.phantom === true && a.isValid()
    },
    getNewRecords: function() {
        return []
    },
    getUpdatedRecords: function() {
        return []
    },
    filterUpdated: function(a) {
        return a.dirty === true && a.phantom !== true && a.isValid()
    },
    getRemovedRecords: function() {
        return this.removed
    },
    filter: function(a, b) {},
    decodeFilters: function(e) {
        if (!Ext.isArray(e)) {
            if (e === undefined) {
                e = []
            } else {
                e = [e]
            }
        }
        var d = e.length,
        a = Ext.util.Filter,
        b, c;
        for (c = 0; c < d; c++) {
            b = e[c];
            if (! (b instanceof a)) {
                Ext.apply(b, {
                    root: "data"
                });
                if (b.fn) {
                    b.filterFn = b.fn
                }
                if (typeof b == "function") {
                    b = {
                        filterFn: b
                    }
                }
                e[c] = new a(b)
            }
        }
        return e
    },
    clearFilter: function(a) {},
    isFiltered: function() {},
    filterBy: function(b, a) {},
    sync: function() {
        var d = this,
        b = {},
        e = d.getNewRecords(),
        c = d.getUpdatedRecords(),
        a = d.getRemovedRecords(),
        f = false;
        if (e.length > 0) {
            b.create = e;
            f = true
        }
        if (c.length > 0) {
            b.update = c;
            f = true
        }
        if (a.length > 0) {
            b.destroy = a;
            f = true
        }
        if (f && d.fireEvent("beforesync", b) !== false) {
            d.proxy.batch(b, d.getBatchListeners())
        }
    },
    getBatchListeners: function() {
        var b = this,
        a = {
            scope: b,
            exception: b.onBatchException
        };
        if (b.batchUpdateMode == "operation") {
            a.operationcomplete = b.onBatchOperationComplete
        } else {
            a.complete = b.onBatchComplete
        }
        return a
    },
    save: function() {
        return this.sync.apply(this, arguments)
    },
    load: function(b) {
        var c = this,
        a;
        b = b || {};
        Ext.applyIf(b, {
            action: "read",
            filters: c.filters.items,
            sorters: c.getSorters()
        });
        a = Ext.create("Ext.data.Operation", b);
        if (c.fireEvent("beforeload", c, a) !== false) {
            c.loading = true;
            c.proxy.read(a, c.onProxyLoad, c)
        }
        return c
    },
    afterEdit: function(a) {
        var b = this;
        if (b.autoSync) {
            b.sync()
        }
        b.fireEvent("update", b, a, Ext.data.Model.EDIT)
    },
    afterReject: function(a) {
        this.fireEvent("update", this, a, Ext.data.Model.REJECT)
    },
    afterCommit: function(a) {
        this.fireEvent("update", this, a, Ext.data.Model.COMMIT)
    },
    clearData: Ext.emptyFn,
    destroyStore: function() {
        var a = this;
        if (!a.isDestroyed) {
            if (a.storeId) {
                Ext.data.StoreManager.unregister(a)
            }
            a.clearData();
            a.data = null;
            a.tree = null;
            a.reader = a.writer = null;
            a.clearListeners();
            a.isDestroyed = true;
            if (a.implicitModel) {
                Ext.destroy(a.model)
            }
        }
    },
    doSort: function(a) {
        var b = this;
        if (b.remoteSort) {
            b.load()
        } else {
            b.data.sortBy(a);
            b.fireEvent("datachanged", b)
        }
    },
    getCount: Ext.emptyFn,
    getById: Ext.emptyFn,
    removeAll: Ext.emptyFn,
    isLoading: function() {
        return !! this.loading
    }
});
Ext.define("Ext.draw.CompositeSprite", {
    extend: "Ext.util.MixedCollection",
    mixins: {
        animate: "Ext.util.Animate"
    },
    isCompositeSprite: true,
    constructor: function(a) {
        var b = this;
        a = a || {};
        Ext.apply(b, a);
        b.addEvents("mousedown", "mouseup", "mouseover", "mouseout", "click");
        b.id = Ext.id(null, "ext-sprite-group-");
        b.callParent()
    },
    onClick: function(a) {
        this.fireEvent("click", a)
    },
    onMouseUp: function(a) {
        this.fireEvent("mouseup", a)
    },
    onMouseDown: function(a) {
        this.fireEvent("mousedown", a)
    },
    onMouseOver: function(a) {
        this.fireEvent("mouseover", a)
    },
    onMouseOut: function(a) {
        this.fireEvent("mouseout", a)
    },
    attachEvents: function(b) {
        var a = this;
        b.on({
            scope: a,
            mousedown: a.onMouseDown,
            mouseup: a.onMouseUp,
            mouseover: a.onMouseOver,
            mouseout: a.onMouseOut,
            click: a.onClick
        })
    },
    add: function(b, c) {
        var a = this.callParent(arguments);
        this.attachEvents(a);
        return a
    },
    insert: function(a, b, c) {
        return this.callParent(arguments)
    },
    remove: function(b) {
        var a = this;
        b.un({
            scope: a,
            mousedown: a.onMouseDown,
            mouseup: a.onMouseUp,
            mouseover: a.onMouseOver,
            mouseout: a.onMouseOut,
            click: a.onClick
        });
        return a.callParent(arguments)
    },
    getBBox: function() {
        var e = 0,
        m, h, j = this.items,
        f = this.length,
        g = Infinity,
        c = g,
        l = -g,
        b = g,
        k = -g,
        d, a;
        for (; e < f; e++) {
            m = j[e];
            if (m.el) {
                h = m.getBBox();
                c = Math.min(c, h.x);
                b = Math.min(b, h.y);
                l = Math.max(l, h.height + h.y);
                k = Math.max(k, h.width + h.x)
            }
        }
        return {
            x: c,
            y: b,
            height: l - b,
            width: k - c
        }
    },
    setAttributes: function(c, e) {
        var d = 0,
        b = this.items,
        a = this.length;
        for (; d < a; d++) {
            b[d].setAttributes(c, e)
        }
        return this
    },
    hide: function(d) {
        var c = 0,
        b = this.items,
        a = this.length;
        for (; c < a; c++) {
            b[c].hide(d)
        }
        return this
    },
    show: function(d) {
        var c = 0,
        b = this.items,
        a = this.length;
        for (; c < a; c++) {
            b[c].show(d)
        }
        return this
    },
    redraw: function() {
        var e = this,
        d = 0,
        c = e.items,
        b = e.getSurface(),
        a = e.length;
        if (b) {
            for (; d < a; d++) {
                b.renderItem(c[d])
            }
        }
        return e
    },
    setStyle: function(f) {
        var c = 0,
        b = this.items,
        a = this.length,
        e, d;
        for (; c < a; c++) {
            e = b[c];
            d = e.el;
            if (d) {
                d.setStyle(f)
            }
        }
    },
    addCls: function(e) {
        var d = 0,
        c = this.items,
        b = this.getSurface(),
        a = this.length;
        if (b) {
            for (; d < a; d++) {
                b.addCls(c[d], e)
            }
        }
    },
    removeCls: function(e) {
        var d = 0,
        c = this.items,
        b = this.getSurface(),
        a = this.length;
        if (b) {
            for (; d < a; d++) {
                b.removeCls(c[d], e)
            }
        }
    },
    getSurface: function() {
        var a = this.first();
        if (a) {
            return a.surface
        }
        return null
    },
    destroy: function() {
        var c = this,
        a = c.getSurface(),
        b;
        if (a) {
            while (c.getCount() > 0) {
                b = c.first();
                c.remove(b);
                a.remove(b)
            }
        }
        c.clearListeners()
    }
});
Ext.define("Ext.ComponentLoader", {
    extend: "Ext.ElementLoader",
    statics: {
        Renderer: {
            Data: function(a, b, d) {
                var f = true;
                try {
                    a.getTarget().update(Ext.decode(b.responseText))
                } catch(c) {
                    f = false
                }
                return f
            },
            Component: function(a, c, g) {
                var h = true,
                f = a.getTarget(),
                b = [];
                if (!f.isContainer) {
                    Ext.Error.raise({
                        target: f,
                        msg: "Components can only be loaded into a container"
                    })
                }
                try {
                    b = Ext.decode(c.responseText)
                } catch(d) {
                    h = false
                }
                if (h) {
                    if (g.removeAll) {
                        f.removeAll()
                    }
                    f.add(b)
                }
                return h
            }
        }
    },
    target: null,
    loadMask: false,
    renderer: "html",
    setTarget: function(b) {
        var a = this;
        if (Ext.isString(b)) {
            b = Ext.getCmp(b)
        }
        if (a.target && a.target != b) {
            a.abort()
        }
        a.target = b
    },
    removeMask: function() {
        this.target.setLoading(false)
    },
    addMask: function(a) {
        this.target.setLoading(a)
    },
    setOptions: function(b, a) {
        b.removeAll = Ext.isDefined(a.removeAll) ? a.removeAll: this.removeAll
    },
    getRenderer: function(b) {
        if (Ext.isFunction(b)) {
            return b
        }
        var a = this.statics().Renderer;
        switch (b) {
        case "component":
            return a.Component;
        case "data":
            return a.Data;
        default:
            return Ext.ElementLoader.Renderer.Html
        }
    }
});
Ext.define("Ext.data.Store", {
    extend: "Ext.data.AbstractStore",
    alias: "store.store",
    requires: ["Ext.data.StoreManager", "Ext.ModelManager", "Ext.data.Model", "Ext.util.Grouper"],
    uses: ["Ext.data.proxy.Memory"],
    remoteSort: false,
    remoteFilter: false,
    remoteGroup: false,
    groupField: undefined,
    groupDir: "ASC",
    pageSize: 25,
    currentPage: 1,
    clearOnPageLoad: true,
    loading: false,
    sortOnFilter: true,
    buffered: false,
    purgePageCount: 5,
    isStore: true,
    onClassExtended: function(a, c) {
        var b = c.model;
        if (typeof b == "string") {
            var d = c.onBeforeClassCreated;
            c.onBeforeClassCreated = function(e, g) {
                var f = this;
                Ext.require(b,
                function() {
                    d.call(f, e, g)
                })
            }
        }
    },
    constructor: function(b) {
        b = Ext.Object.merge({},
        b);
        var d = this,
        f = b.groupers || d.groupers,
        a = b.groupField || d.groupField,
        c, e;
        if (b.buffered || d.buffered) {
            d.prefetchData = Ext.create("Ext.util.MixedCollection", false,
            function(g) {
                return g.index
            });
            d.pendingRequests = [];
            d.pagesRequested = [];
            d.sortOnLoad = false;
            d.filterOnLoad = false
        }
        d.addEvents("beforeprefetch", "groupchange", "prefetch");
        e = b.data || d.data;
        d.data = Ext.create("Ext.util.MixedCollection", false,
        function(g) {
            return g.internalId
        });
        if (e) {
            d.inlineData = e;
            delete b.data
        }
        if (!f && a) {
            f = [{
                property: a,
                direction: b.groupDir || d.groupDir
            }]
        }
        delete b.groupers;
        d.groupers = Ext.create("Ext.util.MixedCollection");
        d.groupers.addAll(d.decodeGroupers(f));
        this.callParent([b]);
        if (d.groupers.items.length) {
            d.sort(d.groupers.items, "prepend", false)
        }
        c = d.proxy;
        e = d.inlineData;
        if (e) {
            if (c instanceof Ext.data.proxy.Memory) {
                c.data = e;
                d.read()
            } else {
                d.add.apply(d, e)
            }
            d.sort();
            delete d.inlineData
        } else {
            if (d.autoLoad) {
                Ext.defer(d.load, 10, d, [typeof d.autoLoad === "object" ? d.autoLoad: undefined])
            }
        }
    },
    onBeforeSort: function() {
        var a = this.groupers;
        if (a.getCount() > 0) {
            this.sort(a.items, "prepend", false)
        }
    },
    decodeGroupers: function(d) {
        if (!Ext.isArray(d)) {
            if (d === undefined) {
                d = []
            } else {
                d = [d]
            }
        }
        var c = d.length,
        e = Ext.util.Grouper,
        a, b;
        for (b = 0; b < c; b++) {
            a = d[b];
            if (! (a instanceof e)) {
                if (Ext.isString(a)) {
                    a = {
                        property: a
                    }
                }
                Ext.applyIf(a, {
                    root: "data",
                    direction: "ASC"
                });
                if (a.fn) {
                    a.sorterFn = a.fn
                }
                if (typeof a == "function") {
                    a = {
                        sorterFn: a
                    }
                }
                d[b] = new e(a)
            }
        }
        return d
    },
    group: function(e, f) {
        var d = this,
        c = false,
        b, a;
        if (Ext.isArray(e)) {
            a = e
        } else {
            if (Ext.isObject(e)) {
                a = [e]
            } else {
                if (Ext.isString(e)) {
                    b = d.groupers.get(e);
                    if (!b) {
                        b = {
                            property: e,
                            direction: f
                        };
                        a = [b]
                    } else {
                        if (f === undefined) {
                            b.toggle()
                        } else {
                            b.setDirection(f)
                        }
                    }
                }
            }
        }
        if (a && a.length) {
            c = true;
            a = d.decodeGroupers(a);
            d.groupers.clear();
            d.groupers.addAll(a)
        }
        if (d.remoteGroup) {
            d.load({
                scope: d,
                callback: d.fireGroupChange
            })
        } else {
            d.sort(null, null, null, c);
            d.fireGroupChange()
        }
    },
    clearGrouping: function() {
        var a = this;
        a.groupers.each(function(b) {
            a.sorters.remove(b)
        });
        a.groupers.clear();
        if (a.remoteGroup) {
            a.load({
                scope: a,
                callback: a.fireGroupChange
            })
        } else {
            a.sort();
            a.fireEvent("groupchange", a, a.groupers)
        }
    },
    isGrouped: function() {
        return this.groupers.getCount() > 0
    },
    fireGroupChange: function() {
        this.fireEvent("groupchange", this, this.groupers)
    },
    getGroups: function(b) {
        var d = this.data.items,
        a = d.length,
        c = [],
        j = {},
        f,
        g,
        h,
        e;
        for (e = 0; e < a; e++) {
            f = d[e];
            g = this.getGroupString(f);
            h = j[g];
            if (h === undefined) {
                h = {
                    name: g,
                    children: []
                };
                c.push(h);
                j[g] = h
            }
            h.children.push(f)
        }
        return b ? j[b] : c
    },
    getGroupsForGrouper: function(f, b) {
        var d = f.length,
        e = [],
        a,
        c,
        h,
        j,
        g;
        for (g = 0; g < d; g++) {
            h = f[g];
            c = b.getGroupString(h);
            if (c !== a) {
                j = {
                    name: c,
                    grouper: b,
                    records: []
                };
                e.push(j)
            }
            j.records.push(h);
            a = c
        }
        return e
    },
    getGroupsForGrouperIndex: function(c, h) {
        var f = this,
        g = f.groupers,
        b = g.getAt(h),
        a = f.getGroupsForGrouper(c, b),
        e = a.length,
        d;
        if (h + 1 < g.length) {
            for (d = 0; d < e; d++) {
                a[d].children = f.getGroupsForGrouperIndex(a[d].records, h + 1)
            }
        }
        for (d = 0; d < e; d++) {
            a[d].depth = h
        }
        return a
    },
    getGroupData: function(a) {
        var b = this;
        if (a !== false) {
            b.sort()
        }
        return b.getGroupsForGrouperIndex(b.data.items, 0)
    },
    getGroupString: function(a) {
        var b = this.groupers.first();
        if (b) {
            return a.get(b.property)
        }
        return ""
    },
    insert: function(d, c) {
        var g = this,
        f = false,
        e, b, a;
        c = [].concat(c);
        for (e = 0, a = c.length; e < a; e++) {
            b = g.createModel(c[e]);
            b.set(g.modelDefaults);
            c[e] = b;
            g.data.insert(d + e, b);
            b.join(g);
            f = f || b.phantom === true
        }
        if (g.snapshot) {
            g.snapshot.addAll(c)
        }
        g.fireEvent("add", g, c, d);
        g.fireEvent("datachanged", g);
        if (g.autoSync && f) {
            g.sync()
        }
    },
    add: function(b) {
        if (!Ext.isArray(b)) {
            b = Array.prototype.slice.apply(arguments)
        }
        var e = this,
        c = 0,
        d = b.length,
        a;
        for (; c < d; c++) {
            a = e.createModel(b[c]);
            b[c] = a
        }
        e.insert(e.data.length, b);
        return b
    },
    createModel: function(a) {
        if (!a.isModel) {
            a = Ext.ModelManager.create(a, this.model)
        }
        return a
    },
    each: function(b, a) {
        this.data.each(b, a)
    },
    remove: function(b, j) {
        if (!Ext.isArray(b)) {
            b = [b]
        }
        j = j === true;
        var f = this,
        g = false,
        c = 0,
        a = b.length,
        h, e, d;
        for (; c < a; c++) {
            d = b[c];
            e = f.data.indexOf(d);
            if (f.snapshot) {
                f.snapshot.remove(d)
            }
            if (e > -1) {
                h = d.phantom === true;
                if (!j && !h) {
                    f.removed.push(d)
                }
                d.unjoin(f);
                f.data.remove(d);
                g = g || !h;
                f.fireEvent("remove", f, d, e)
            }
        }
        f.fireEvent("datachanged", f);
        if (!j && f.autoSync && g) {
            f.sync()
        }
    },
    removeAt: function(b) {
        var a = this.getAt(b);
        if (a) {
            this.remove(a)
        }
    },
    load: function(a) {
        var b = this;
        a = a || {};
        if (Ext.isFunction(a)) {
            a = {
                callback: a
            }
        }
        Ext.applyIf(a, {
            groupers: b.groupers.items,
            page: b.currentPage,
            start: (b.currentPage - 1) * b.pageSize,
            limit: b.pageSize,
            addRecords: false
        });
        return b.callParent([a])
    },
    onProxyLoad: function(b) {
        var d = this,
        c = b.getResultSet(),
        a = b.getRecords(),
        e = b.wasSuccessful();
        if (c) {
            d.totalCount = c.total
        }
        if (e) {
            d.loadRecords(a, b)
        }
        d.loading = false;
        d.fireEvent("load", d, a, e);
        d.fireEvent("read", d, a, b.wasSuccessful());
        Ext.callback(b.callback, b.scope || d, [a, b, e])
    },
    onCreateRecords: function(d, e, l) {
        if (l) {
            var g = 0,
            f = this.data,
            a = this.snapshot,
            b = d.length,
            k = e.records,
            h, c, j;
            for (; g < b; ++g) {
                h = d[g];
                c = k[g];
                if (c) {
                    j = f.indexOf(c);
                    if (j > -1) {
                        f.removeAt(j);
                        f.insert(j, h)
                    }
                    if (a) {
                        j = a.indexOf(c);
                        if (j > -1) {
                            a.removeAt(j);
                            a.insert(j, h)
                        }
                    }
                    h.phantom = false;
                    h.join(this)
                }
            }
        }
    },
    onUpdateRecords: function(d, c, h) {
        if (h) {
            var e = 0,
            f = d.length,
            g = this.data,
            b = this.snapshot,
            a;
            for (; e < f; ++e) {
                a = d[e];
                g.replace(a);
                if (b) {
                    b.replace(a)
                }
                a.join(this)
            }
        }
    },
    onDestroyRecords: function(c, d, j) {
        if (j) {
            var h = this,
            f = 0,
            b = c.length,
            e = h.data,
            a = h.snapshot,
            g;
            for (; f < b; ++f) {
                g = c[f];
                g.unjoin(h);
                e.remove(g);
                if (a) {
                    a.remove(g)
                }
            }
            h.removed = []
        }
    },
    getNewRecords: function() {
        return this.data.filterBy(this.filterNew).items
    },
    getUpdatedRecords: function() {
        return this.data.filterBy(this.filterUpdated).items
    },
    filter: function(e, f) {
        if (Ext.isString(e)) {
            e = {
                property: e,
                value: f
            }
        }
        var d = this,
        a = d.decodeFilters(e),
        b = 0,
        g = d.sortOnFilter && !d.remoteSort,
        c = a.length;
        for (; b < c; b++) {
            d.filters.replace(a[b])
        }
        if (d.remoteFilter) {
            d.load()
        } else {
            if (d.filters.getCount()) {
                d.snapshot = d.snapshot || d.data.clone();
                d.data = d.data.filter(d.filters.items);
                if (g) {
                    d.sort()
                }
                if (!g || d.sorters.length < 1) {
                    d.fireEvent("datachanged", d)
                }
            }
        }
    },
    clearFilter: function(a) {
        var b = this;
        b.filters.clear();
        if (b.remoteFilter) {
            b.load()
        } else {
            if (b.isFiltered()) {
                b.data = b.snapshot.clone();
                delete b.snapshot;
                if (a !== true) {
                    b.fireEvent("datachanged", b)
                }
            }
        }
    },
    isFiltered: function() {
        var a = this.snapshot;
        return !! a && a !== this.data
    },
    filterBy: function(b, a) {
        var c = this;
        c.snapshot = c.snapshot || c.data.clone();
        c.data = c.queryBy(b, a || c);
        c.fireEvent("datachanged", c)
    },
    queryBy: function(b, a) {
        var c = this,
        d = c.snapshot || c.data;
        return d.filterBy(b, a || c)
    },
    loadData: function(g, a) {
        var c = this.model,
        f = g.length,
        e = [],
        d,
        b;
        for (d = 0; d < f; d++) {
            b = g[d];
            if (! (b instanceof Ext.data.Model)) {
                b = Ext.ModelManager.create(b, c)
            }
            e.push(b)
        }
        this.loadRecords(e, {
            addRecords: a
        })
    },
    loadRawData: function(e, b) {
        var d = this,
        a = d.proxy.reader.read(e),
        c = a.records;
        if (a.success) {
            d.loadRecords(c, {
                addRecords: b
            });
            d.fireEvent("load", d, c, true)
        }
    },
    loadRecords: function(a, b) {
        var e = this,
        c = 0,
        d = a.length;
        b = b || {};
        if (!b.addRecords) {
            delete e.snapshot;
            e.clearData()
        }
        e.data.addAll(a);
        for (; c < d; c++) {
            if (b.start !== undefined) {
                a[c].index = b.start + c
            }
            a[c].join(e)
        }
        e.suspendEvents();
        if (e.filterOnLoad && !e.remoteFilter) {
            e.filter()
        }
        if (e.sortOnLoad && !e.remoteSort) {
            e.sort()
        }
        e.resumeEvents();
        e.fireEvent("datachanged", e, a)
    },
    loadPage: function(c, a) {
        var b = this;
        a = Ext.apply({},
        a);
        b.currentPage = c;
        b.read(Ext.applyIf(a, {
            page: c,
            start: (c - 1) * b.pageSize,
            limit: b.pageSize,
            addRecords: !b.clearOnPageLoad
        }))
    },
    nextPage: function(a) {
        this.loadPage(this.currentPage + 1, a)
    },
    previousPage: function(a) {
        this.loadPage(this.currentPage - 1, a)
    },
    clearData: function() {
        var a = this;
        a.data.each(function(b) {
            b.unjoin(a)
        });
        a.data.clear()
    },
    prefetch: function(b) {
        var c = this,
        a, d = c.getRequestId();
        b = b || {};
        Ext.applyIf(b, {
            action: "read",
            filters: c.filters.items,
            sorters: c.sorters.items,
            requestId: d
        });
        c.pendingRequests.push(d);
        a = Ext.create("Ext.data.Operation", b);
        if (c.fireEvent("beforeprefetch", c, a) !== false) {
            c.loading = true;
            c.proxy.read(a, c.onProxyPrefetch, c)
        }
        return c
    },
    prefetchPage: function(e, c) {
        var d = this,
        b = d.pageSize,
        f = (e - 1) * d.pageSize,
        a = f + b;
        if (Ext.Array.indexOf(d.pagesRequested, e) === -1 && !d.rangeSatisfied(f, a)) {
            c = c || {};
            d.pagesRequested.push(e);
            Ext.applyIf(c, {
                page: e,
                start: f,
                limit: b,
                callback: d.onWaitForGuarantee,
                scope: d
            });
            d.prefetch(c)
        }
    },
    getRequestId: function() {
        this.requestSeed = this.requestSeed || 1;
        return this.requestSeed++
    },
    onProxyPrefetch: function(b) {
        var d = this,
        c = b.getResultSet(),
        a = b.getRecords(),
        e = b.wasSuccessful();
        if (c) {
            d.totalCount = c.total;
            d.fireEvent("totalcountchange", d.totalCount)
        }
        if (e) {
            d.cacheRecords(a, b)
        }
        Ext.Array.remove(d.pendingRequests, b.requestId);
        if (b.page) {
            Ext.Array.remove(d.pagesRequested, b.page)
        }
        d.loading = false;
        d.fireEvent("prefetch", d, a, e, b);
        if (b.blocking) {
            d.fireEvent("load", d, a, e)
        }
        Ext.callback(b.callback, b.scope || d, [a, b, e])
    },
    cacheRecords: function(b, a) {
        var e = this,
        c = 0,
        d = b.length,
        f = a ? a.start: 0;
        if (!Ext.isDefined(e.totalCount)) {
            e.totalCount = b.length;
            e.fireEvent("totalcountchange", e.totalCount)
        }
        for (; c < d; c++) {
            b[c].index = f + c
        }
        e.prefetchData.addAll(b);
        if (e.purgePageCount) {
            e.purgeRecords()
        }
    },
    purgeRecords: function() {
        var c = this,
        b = c.prefetchData.getCount(),
        d = c.purgePageCount * c.pageSize,
        e = b - d - 1,
        a = 0;
        for (; a <= e; a++) {
            c.prefetchData.removeAt(0)
        }
    },
    rangeSatisfied: function(e, a) {
        var c = this,
        b = e,
        d = true;
        for (; b < a; b++) {
            if (!c.prefetchData.getByKey(b)) {
                d = false;
                if (a - b > c.pageSize) {
                    Ext.Error.raise("A single page prefetch could never satisfy this request.")
                }
                break
            }
        }
        return d
    },
    getPageFromRecordIndex: function(a) {
        return Math.floor(a / this.pageSize) + 1
    },
    onGuaranteedRange: function() {
        var f = this,
        c = f.getTotalCount(),
        g = f.requestStart,
        b = ((c - 1) < f.requestEnd) ? c - 1 : f.requestEnd,
        d = [],
        a,
        e = g;
        b = Math.max(0, b);
        if (g > b) {
            Ext.log({
                level: "warn",
                msg: "Start (" + g + ") was greater than end (" + b + ") for the range of records requested (" + f.requestStart + "-" + f.requestEnd + ")" + (this.storeId ? ' from store "' + this.storeId + '"': "")
            })
        }
        if (g !== f.guaranteedStart && b !== f.guaranteedEnd) {
            f.guaranteedStart = g;
            f.guaranteedEnd = b;
            for (; e <= b; e++) {
                a = f.prefetchData.getByKey(e);
                if (a) {
                    d.push(a)
                }
            }
            f.fireEvent("guaranteedrange", d, g, b);
            if (f.cb) {
                f.cb.call(f.scope || f, d)
            }
        }
        f.unmask()
    },
    mask: function() {
        this.masked = true;
        this.fireEvent("beforeload")
    },
    unmask: function() {
        if (this.masked) {
            this.fireEvent("load")
        }
    },
    hasPendingRequests: function() {
        return this.pendingRequests.length
    },
    onWaitForGuarantee: function() {
        if (!this.hasPendingRequests()) {
            this.onGuaranteedRange()
        }
    },
    guaranteeRange: function(a, c, b, m) {
        if (a && c) {
            if (c - a > this.pageSize) {
                Ext.Error.raise({
                    start: a,
                    end: c,
                    pageSize: this.pageSize,
                    msg: "Requested a bigger range than the specified pageSize"
                })
            }
        }
        c = (c > this.totalCount) ? this.totalCount - 1 : c;
        var h = this,
        d = a,
        k = h.prefetchData,
        e = [],
        g = !!k.getByKey(a),
        j = !!k.getByKey(c),
        f = h.getPageFromRecordIndex(a),
        l = h.getPageFromRecordIndex(c);
        h.cb = b;
        h.scope = m;
        h.requestStart = a;
        h.requestEnd = c;
        if (!g || !j) {
            if (f === l) {
                h.mask();
                h.prefetchPage(f, {
                    callback: h.onWaitForGuarantee,
                    scope: h
                })
            } else {
                h.mask();
                h.prefetchPage(f, {
                    callback: h.onWaitForGuarantee,
                    scope: h
                });
                h.prefetchPage(l, {
                    callback: h.onWaitForGuarantee,
                    scope: h
                })
            }
        } else {
            h.onGuaranteedRange()
        }
    },
    sort: function() {
        var d = this,
        c = d.prefetchData,
        e, f, a, b;
        if (d.buffered) {
            if (d.remoteSort) {
                c.clear();
                d.callParent(arguments)
            } else {
                e = d.getSorters();
                f = d.guaranteedStart;
                a = d.guaranteedEnd;
                if (e.length) {
                    c.sort(e);
                    b = c.getRange();
                    c.clear();
                    d.cacheRecords(b);
                    delete d.guaranteedStart;
                    delete d.guaranteedEnd;
                    d.guaranteeRange(f, a)
                }
                d.callParent(arguments)
            }
        } else {
            d.callParent(arguments)
        }
    },
    doSort: function(b) {
        var e = this;
        if (e.remoteSort) {
            e.load()
        } else {
            e.data.sortBy(b);
            if (!e.buffered) {
                var a = e.getRange(),
                d = a.length,
                c = 0;
                for (; c < d; c++) {
                    a[c].index = c
                }
            }
            e.fireEvent("datachanged", e)
        }
    },
    find: function(e, d, g, f, a, c) {
        var b = this.createFilterFn(e, d, f, a, c);
        return b ? this.data.findIndexBy(b, null, g) : -1
    },
    findRecord: function() {
        var b = this,
        a = b.find.apply(b, arguments);
        return a !== -1 ? b.getAt(a) : null
    },
    createFilterFn: function(d, c, e, a, b) {
        if (Ext.isEmpty(c)) {
            return false
        }
        c = this.data.createValueMatcher(c, e, a, b);
        return function(f) {
            return c.test(f.data[d])
        }
    },
    findExact: function(b, a, c) {
        return this.data.findIndexBy(function(d) {
            return d.get(b) == a
        },
        this, c)
    },
    findBy: function(b, a, c) {
        return this.data.findIndexBy(b, a, c)
    },
    collect: function(b, a, c) {
        var d = this,
        e = (c === true && d.snapshot) ? d.snapshot: d.data;
        return e.collect(b, "data", a)
    },
    getCount: function() {
        return this.data.length || 0
    },
    getTotalCount: function() {
        return this.totalCount
    },
    getAt: function(a) {
        return this.data.getAt(a)
    },
    getRange: function(b, a) {
        return this.data.getRange(b, a)
    },
    getById: function(a) {
        return (this.snapshot || this.data).findBy(function(b) {
            return b.getId() === a
        })
    },
    indexOf: function(a) {
        return this.data.indexOf(a)
    },
    indexOfTotal: function(a) {
        var b = a.index;
        if (b || b === 0) {
            return b
        }
        return this.indexOf(a)
    },
    indexOfId: function(a) {
        return this.indexOf(this.getById(a))
    },
    removeAll: function(a) {
        var b = this;
        b.clearData();
        if (b.snapshot) {
            b.snapshot.clear()
        }
        if (a !== true) {
            b.fireEvent("clear", b)
        }
    },
    first: function(a) {
        var b = this;
        if (a && b.isGrouped()) {
            return b.aggregate(function(c) {
                return c.length ? c[0] : undefined
            },
            b, true)
        } else {
            return b.data.first()
        }
    },
    last: function(a) {
        var b = this;
        if (a && b.isGrouped()) {
            return b.aggregate(function(d) {
                var c = d.length;
                return c ? d[c - 1] : undefined
            },
            b, true)
        } else {
            return b.data.last()
        }
    },
    sum: function(c, a) {
        var b = this;
        if (a && b.isGrouped()) {
            return b.aggregate(b.getSum, b, true, [c])
        } else {
            return b.getSum(b.data.items, c)
        }
    },
    getSum: function(b, e) {
        var d = 0,
        c = 0,
        a = b.length;
        for (; c < a; ++c) {
            d += b[c].get(e)
        }
        return d
    },
    count: function(a) {
        var b = this;
        if (a && b.isGrouped()) {
            return b.aggregate(function(c) {
                return c.length
            },
            b, true)
        } else {
            return b.getCount()
        }
    },
    min: function(c, a) {
        var b = this;
        if (a && b.isGrouped()) {
            return b.aggregate(b.getMin, b, true, [c])
        } else {
            return b.getMin(b.data.items, c)
        }
    },
    getMin: function(b, f) {
        var d = 1,
        a = b.length,
        e, c;
        if (a > 0) {
            c = b[0].get(f)
        }
        for (; d < a; ++d) {
            e = b[d].get(f);
            if (e < c) {
                c = e
            }
        }
        return c
    },
    max: function(c, a) {
        var b = this;
        if (a && b.isGrouped()) {
            return b.aggregate(b.getMax, b, true, [c])
        } else {
            return b.getMax(b.data.items, c)
        }
    },
    getMax: function(c, f) {
        var d = 1,
        b = c.length,
        e, a;
        if (b > 0) {
            a = c[0].get(f)
        }
        for (; d < b; ++d) {
            e = c[d].get(f);
            if (e > a) {
                a = e
            }
        }
        return a
    },
    average: function(c, a) {
        var b = this;
        if (a && b.isGrouped()) {
            return b.aggregate(b.getAverage, b, true, [c])
        } else {
            return b.getAverage(b.data.items, c)
        }
    },
    getAverage: function(b, e) {
        var c = 0,
        a = b.length,
        d = 0;
        if (b.length > 0) {
            for (; c < a; ++c) {
                d += b[c].get(e)
            }
            return d / a
        }
        return 0
    },
    aggregate: function(g, j, e, f) {
        f = f || [];
        if (e && this.isGrouped()) {
            var a = this.getGroups(),
            c = 0,
            d = a.length,
            b = {},
            h;
            for (; c < d; ++c) {
                h = a[c];
                b[h.name] = g.apply(j || this, [h.children].concat(f))
            }
            return b
        } else {
            return g.apply(j || this, [this.data.items].concat(f))
        }
    }
},
function() {
    Ext.regStore("ext-empty-store", {
        fields: [],
        proxy: "proxy"
    })
});
Ext.define("Ext.data.ArrayStore", {
    extend: "Ext.data.Store",
    alias: "store.array",
    uses: ["Ext.data.reader.Array"],
    constructor: function(a) {
        a = a || {};
        Ext.applyIf(a, {
            proxy: {
                type: "memory",
                reader: "array"
            }
        });
        this.callParent([a])
    },
    loadData: function(e, a) {
        if (this.expandData === true) {
            var d = [],
            b = 0,
            c = e.length;
            for (; b < c; b++) {
                d[d.length] = [e[b]]
            }
            e = d
        }
        this.callParent([e, a])
    }
},
function() {
    Ext.data.SimpleStore = Ext.data.ArrayStore
});
Ext.define("Ext.layout.container.Fit", {
    extend: "Ext.layout.container.AbstractFit",
    alias: "layout.fit",
    alternateClassName: "Ext.layout.FitLayout",
    requires: ["Ext.layout.container.Box"],
    defaultMargins: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    },
    onLayout: function() {
        var c = this,
        a, b, d;
        c.callParent();
        if (c.owner.items.length) {
            b = c.owner.items.get(0);
            d = b.margins || c.defaultMargins;
            a = c.getLayoutTargetSize();
            a.width -= d.width;
            a.height -= d.height;
            c.setItemBox(b, a);
            if (d.left || d.top) {
                b.setPosition(d.left, d.top)
            }
        }
    },
    getTargetBox: function() {
        return this.getLayoutTargetSize()
    },
    setItemBox: function(c, b) {
        var a = this;
        if (c && b.height > 0) {
            if (!a.owner.isFixedWidth()) {
                b.width = undefined
            }
            if (!a.owner.isFixedHeight()) {
                b.height = undefined
            }
            a.setItemSize(c, b.width, b.height)
        }
    },
    configureItem: function(a) {
        a.layoutManagedHeight = 0;
        a.layoutManagedWidth = 0;
        this.callParent(arguments)
    }
},
function() {
    this.prototype.renderItem = Ext.layout.container.Box.prototype.renderItem
});
Ext.define("Ext.menu.Separator", {
    extend: "Ext.menu.Item",
    alias: "widget.menuseparator",
    canActivate: false,
    focusable: false,
    hideOnClick: false,
    plain: true,
    separatorCls: Ext.baseCSSPrefix + "menu-item-separator",
    text: "&#160;",
    onRender: function(b, d) {
        var c = this,
        a = c.separatorCls;
        c.cls += " " + a;
        c.callParent(arguments)
    }
});
Ext.define("Ext.menu.Menu", {
    extend: "Ext.panel.Panel",
    alias: "widget.menu",
    requires: ["Ext.layout.container.Fit", "Ext.layout.container.VBox", "Ext.menu.CheckItem", "Ext.menu.Item", "Ext.menu.KeyNav", "Ext.menu.Manager", "Ext.menu.Separator"],
    allowOtherMenus: false,
    ariaRole: "menu",
    defaultAlign: "tl-bl?",
    floating: true,
    constrain: true,
    hidden: true,
    hideMode: "visibility",
    ignoreParentClicks: false,
    isMenu: true,
    showSeparator: true,
    minWidth: 120,
    initComponent: function() {
        var b = this,
        d = Ext.baseCSSPrefix,
        a = [d + "menu"],
        c = b.bodyCls ? [b.bodyCls] : [];
        b.addEvents("click", "mouseenter", "mouseleave", "mouseover");
        Ext.menu.Manager.register(b);
        if (b.plain) {
            a.push(d + "menu-plain")
        }
        b.cls = a.join(" ");
        c.unshift(d + "menu-body");
        b.bodyCls = c.join(" ");
        b.layout = {
            type: "vbox",
            align: "stretchmax",
            autoSize: true,
            clearInnerCtOnLayout: true,
            overflowHandler: "Scroller"
        };
        if (b.floating === false && b.initialConfig.hidden !== true) {
            b.hidden = false
        }
        b.callParent(arguments);
        b.on("beforeshow",
        function() {
            var e = !!b.items.length;
            if (e && b.rendered) {
                b.el.setStyle("visibility", null)
            }
            return e
        })
    },
    afterRender: function(a) {
        var b = this,
        d = Ext.baseCSSPrefix,
        c = "&#160;";
        b.callParent(arguments);
        if (b.showSeparator) {
            b.iconSepEl = b.layout.getRenderTarget().insertFirst({
                cls: d + "menu-icon-separator",
                html: c
            })
        }
        b.focusEl = b.el.createChild({
            cls: d + "menu-focus",
            tabIndex: "-1",
            html: c
        });
        b.mon(b.el, {
            click: b.onClick,
            mouseover: b.onMouseOver,
            scope: b
        });
        b.mouseMonitor = b.el.monitorMouseLeave(100, b.onMouseLeave, b);
        if (b.showSeparator && ((!Ext.isStrict && Ext.isIE) || Ext.isIE6)) {
            b.iconSepEl.setHeight(b.el.getHeight())
        }
        b.keyNav = Ext.create("Ext.menu.KeyNav", b)
    },
    afterLayout: function() {
        var j = this;
        j.callParent(arguments);
        if ((!Ext.isStrict && Ext.isIE) || Ext.isIE6) {
            var a = j.layout.getRenderTarget(),
            c = 0,
            b = j.dockedItems,
            d = b.length,
            f = 0,
            g,
            h,
            e;
            c = a.getWidth();
            e = c + j.body.getBorderWidth("lr") + j.body.getPadding("lr");
            j.body.setWidth(e);
            for (; f < d, g = b.getAt(f); f++) {
                if (g.dock == "left" || g.dock == "right") {
                    e += g.getWidth()
                }
            }
            j.el.setWidth(e)
        }
    },
    getBubbleTarget: function() {
        return this.parentMenu || this.callParent()
    },
    canActivateItem: function(a) {
        return a && !a.isDisabled() && a.isVisible() && (a.canActivate || a.getXTypes().indexOf("menuitem") < 0)
    },
    deactivateActiveItem: function() {
        var a = this;
        if (a.activeItem) {
            a.activeItem.deactivate();
            if (!a.activeItem.activated) {
                delete a.activeItem
            }
        }
        if (a.focusedItem && !a.filtered) {
            a.focusedItem.blur();
            if (!a.focusedItem.$focused) {
                delete a.focusedItem
            }
        }
    },
    clearStretch: function() {
        if (this.rendered) {
            this.items.each(function(a) {
                if (a.componentLayout) {
                    delete a.componentLayout.lastComponentSize
                }
                if (a.el) {
                    a.el.setWidth(null)
                }
            })
        }
    },
    onAdd: function() {
        var a = this;
        a.clearStretch();
        a.callParent(arguments);
        if (Ext.isIE6 || Ext.isIE7) {
            Ext.Function.defer(a.doComponentLayout, 10, a)
        }
    },
    onRemove: function() {
        this.clearStretch();
        this.callParent(arguments)
    },
    redoComponentLayout: function() {
        if (this.rendered) {
            this.clearStretch();
            this.doComponentLayout()
        }
    },
    getFocusEl: function() {
        return this.focusEl
    },
    hide: function() {
        this.deactivateActiveItem();
        this.callParent(arguments)
    },
    getItemFromEvent: function(a) {
        return this.getChildByElement(a.getTarget())
    },
    lookupComponent: function(b) {
        var a = this;
        if (Ext.isString(b)) {
            b = a.lookupItemFromString(b)
        } else {
            if (Ext.isObject(b)) {
                b = a.lookupItemFromObject(b)
            }
        }
        b.minWidth = b.minWidth || a.minWidth;
        return b
    },
    lookupItemFromObject: function(c) {
        var b = this,
        d = Ext.baseCSSPrefix,
        a, e;
        if (!c.isComponent) {
            if (!c.xtype) {
                c = Ext.create("Ext.menu." + (Ext.isBoolean(c.checked) ? "Check": "") + "Item", c)
            } else {
                c = Ext.ComponentManager.create(c, c.xtype)
            }
        }
        if (c.isMenuItem) {
            c.parentMenu = b
        }
        if (!c.isMenuItem && !c.dock) {
            a = [d + "menu-item", d + "menu-item-cmp"];
            e = Ext.Function.createInterceptor;
            c.focus = e(c.focus,
            function() {
                this.$focused = true
            },
            c);
            c.blur = e(c.blur,
            function() {
                this.$focused = false
            },
            c);
            if (!b.plain && (c.indent === true || c.iconCls === "no-icon")) {
                a.push(d + "menu-item-indent")
            }
            if (c.rendered) {
                c.el.addCls(a)
            } else {
                c.cls = (c.cls ? c.cls: "") + " " + a.join(" ")
            }
            c.isMenuItem = true
        }
        return c
    },
    lookupItemFromString: function(a) {
        return (a == "separator" || a == "-") ? Ext.createWidget("menuseparator") : Ext.createWidget("menuitem", {
            canActivate: false,
            hideOnClick: false,
            plain: true,
            text: a
        })
    },
    onClick: function(c) {
        var b = this,
        a;
        if (b.disabled) {
            c.stopEvent();
            return
        }
        if ((c.getTarget() == b.focusEl.dom) || c.within(b.layout.getRenderTarget())) {
            a = b.getItemFromEvent(c) || b.activeItem;
            if (a) {
                if (a.getXTypes().indexOf("menuitem") >= 0) {
                    if (!a.menu || !b.ignoreParentClicks) {
                        a.onClick(c)
                    } else {
                        c.stopEvent()
                    }
                }
            }
            b.fireEvent("click", b, a, c)
        }
    },
    onDestroy: function() {
        var a = this;
        Ext.menu.Manager.unregister(a);
        if (a.rendered) {
            a.el.un(a.mouseMonitor);
            a.keyNav.destroy();
            delete a.keyNav
        }
        a.callParent(arguments)
    },
    onMouseLeave: function(b) {
        var a = this;
        a.deactivateActiveItem();
        if (a.disabled) {
            return
        }
        a.fireEvent("mouseleave", a, b)
    },
    onMouseOver: function(d) {
        var c = this,
        f = d.getRelatedTarget(),
        a = !c.el.contains(f),
        b = c.getItemFromEvent(d);
        if (a && c.parentMenu) {
            c.parentMenu.setActiveItem(c.parentItem);
            c.parentMenu.mouseMonitor.mouseenter()
        }
        if (c.disabled) {
            return
        }
        if (b) {
            c.setActiveItem(b);
            if (b.activated && b.expandMenu) {
                b.expandMenu()
            }
        }
        if (a) {
            c.fireEvent("mouseenter", c, d)
        }
        c.fireEvent("mouseover", c, b, d)
    },
    setActiveItem: function(b) {
        var a = this;
        if (b && (b != a.activeItem && b != a.focusedItem)) {
            a.deactivateActiveItem();
            if (a.canActivateItem(b)) {
                if (b.activate) {
                    b.activate();
                    if (b.activated) {
                        a.activeItem = b;
                        a.focusedItem = b;
                        a.focus()
                    }
                } else {
                    b.focus();
                    a.focusedItem = b
                }
            }
            b.el.scrollIntoView(a.layout.getRenderTarget())
        }
    },
    showBy: function(b, f, e) {
        var a = this,
        d, c;
        if (a.floating && b) {
            a.layout.autoSize = true;
            a.doAutoRender();
            delete a.needsLayout;
            b = b.el || b;
            d = a.el.getAlignToXY(b, f || a.defaultAlign, e);
            if (a.floatParent) {
                c = a.floatParent.getTargetEl().getViewRegion();
                d[0] -= c.x;
                d[1] -= c.y
            }
            a.showAt(d)
        }
        return a
    },
    doConstrain: function() {
        var f = this,
        g = f.el.getY(),
        h,
        e,
        b,
        j = g,
        k,
        d,
        a,
        c;
        delete f.height;
        f.setSize();
        e = f.getHeight();
        if (f.floating) {
            d = Ext.fly(f.el.getScopeParent());
            a = d.getScroll().top;
            c = d.getViewSize().height;
            k = g - a;
            h = f.maxHeight ? f.maxHeight: c - k;
            if (e > c) {
                h = c;
                j = g - k
            } else {
                if (h < e) {
                    j = g - (e - h);
                    h = e
                }
            }
        } else {
            h = f.getHeight()
        }
        if (f.maxHeight) {
            h = Math.min(f.maxHeight, h)
        }
        if (e > h && h > 0) {
            f.layout.autoSize = false;
            f.setHeight(h);
            if (f.showSeparator) {
                f.iconSepEl.setHeight(f.layout.getRenderTarget().dom.scrollHeight)
            }
        }
        b = f.getConstrainVector(f.el.getScopeParent());
        if (b) {
            f.setPosition(f.getPosition()[0] + b[0])
        }
        f.el.setY(j)
    }
});
Ext.define("Ext.draw.Surface", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.draw.CompositeSprite"],
    uses: ["Ext.draw.engine.Svg", "Ext.draw.engine.Vml"],
    separatorRe: /[, ]+/,
    statics: {
        create: function(b, d) {
            d = d || ["Svg", "Vml"];
            var c = 0,
            a = d.length,
            e;
            for (; c < a; c++) {
                if (Ext.supports[d[c]]) {
                    return Ext.create("Ext.draw.engine." + d[c], b)
                }
            }
            return false
        }
    },
    availableAttrs: {
        blur: 0,
        "clip-rect": "0 0 1e9 1e9",
        cursor: "default",
        cx: 0,
        cy: 0,
        "dominant-baseline": "auto",
        fill: "none",
        "fill-opacity": 1,
        font: '10px "Arial"',
        "font-family": '"Arial"',
        "font-size": "10",
        "font-style": "normal",
        "font-weight": 400,
        gradient: "",
        height: 0,
        hidden: false,
        href: "http://sencha.com/",
        opacity: 1,
        path: "M0,0",
        radius: 0,
        rx: 0,
        ry: 0,
        scale: "1 1",
        src: "",
        stroke: "#000",
        "stroke-dasharray": "",
        "stroke-linecap": "butt",
        "stroke-linejoin": "butt",
        "stroke-miterlimit": 0,
        "stroke-opacity": 1,
        "stroke-width": 1,
        target: "_blank",
        text: "",
        "text-anchor": "middle",
        title: "Ext Draw",
        width: 0,
        x: 0,
        y: 0,
        zIndex: 0
    },
    container: undefined,
    height: 352,
    width: 512,
    x: 0,
    y: 0,
    orderSpritesByZIndex: true,
    constructor: function(a) {
        var b = this;
        a = a || {};
        Ext.apply(b, a);
        b.domRef = Ext.getDoc().dom;
        b.customAttributes = {};
        b.addEvents("mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "click");
        b.mixins.observable.constructor.call(b);
        b.getId();
        b.initGradients();
        b.initItems();
        if (b.renderTo) {
            b.render(b.renderTo);
            delete b.renderTo
        }
        b.initBackground(a.background)
    },
    initSurface: Ext.emptyFn,
    renderItem: Ext.emptyFn,
    renderItems: Ext.emptyFn,
    setViewBox: function(b, d, c, a) {
        if (isFinite(b) && isFinite(d) && isFinite(c) && isFinite(a)) {
            this.viewBox = {
                x: b,
                y: d,
                width: c,
                height: a
            };
            this.applyViewBox()
        }
    },
    addCls: Ext.emptyFn,
    removeCls: Ext.emptyFn,
    setStyle: Ext.emptyFn,
    initGradients: function() {
        var a = this.gradients;
        if (a) {
            Ext.each(a, this.addGradient, this)
        }
    },
    initItems: function() {
        var a = this.items;
        this.items = Ext.create("Ext.draw.CompositeSprite");
        this.groups = Ext.create("Ext.draw.CompositeSprite");
        if (a) {
            this.add(a)
        }
    },
    initBackground: function(b) {
        var e = this,
        d = e.width,
        a = e.height,
        f, g, c;
        if (b) {
            if (b.gradient) {
                g = b.gradient;
                f = g.id;
                e.addGradient(g);
                e.background = e.add({
                    type: "rect",
                    x: 0,
                    y: 0,
                    width: d,
                    height: a,
                    fill: "url(#" + f + ")"
                })
            } else {
                if (b.fill) {
                    e.background = e.add({
                        type: "rect",
                        x: 0,
                        y: 0,
                        width: d,
                        height: a,
                        fill: b.fill
                    })
                } else {
                    if (b.image) {
                        e.background = e.add({
                            type: "image",
                            x: 0,
                            y: 0,
                            width: d,
                            height: a,
                            src: b.image
                        })
                    }
                }
            }
        }
    },
    setSize: function(a, b) {
        if (this.background) {
            this.background.setAttributes({
                width: a,
                height: b,
                hidden: false
            },
            true)
        }
        this.applyViewBox()
    },
    scrubAttrs: function(d) {
        var c, b = {},
        a = {},
        e = d.attr;
        for (c in e) {
            if (this.translateAttrs.hasOwnProperty(c)) {
                b[this.translateAttrs[c]] = e[c];
                a[this.translateAttrs[c]] = true
            } else {
                if (this.availableAttrs.hasOwnProperty(c) && !a[c]) {
                    b[c] = e[c]
                }
            }
        }
        return b
    },
    onClick: function(a) {
        this.processEvent("click", a)
    },
    onMouseUp: function(a) {
        this.processEvent("mouseup", a)
    },
    onMouseDown: function(a) {
        this.processEvent("mousedown", a)
    },
    onMouseOver: function(a) {
        this.processEvent("mouseover", a)
    },
    onMouseOut: function(a) {
        this.processEvent("mouseout", a)
    },
    onMouseMove: function(a) {
        this.fireEvent("mousemove", a)
    },
    onMouseEnter: Ext.emptyFn,
    onMouseLeave: Ext.emptyFn,
    addGradient: Ext.emptyFn,
    add: function() {
        var f = Array.prototype.slice.call(arguments),
        h,
        d;
        var a = f.length > 1;
        if (a || Ext.isArray(f[0])) {
            var g = a ? f: f[0],
            b = [],
            c,
            e,
            j;
            for (c = 0, e = g.length; c < e; c++) {
                j = g[c];
                j = this.add(j);
                b.push(j)
            }
            return b
        }
        h = this.prepareItems(f[0], true)[0];
        this.insertByZIndex(h);
        this.onAdd(h);
        return h
    },
    insertByZIndex: function(j) {
        var f = this,
        d = f.items.items,
        c = d.length,
        k = Math.ceil,
        g = j.attr.zIndex,
        h = c,
        b = h - 1,
        e = 0,
        a;
        if (f.orderSpritesByZIndex && c && g < d[b].attr.zIndex) {
            while (e <= b) {
                h = k((e + b) / 2);
                a = d[h].attr.zIndex;
                if (a > g) {
                    b = h - 1
                } else {
                    if (a < g) {
                        e = h + 1
                    } else {
                        break
                    }
                }
            }
            while (h < c && d[h].attr.zIndex <= g) {
                h++
            }
        }
        f.items.insert(h, j);
        return h
    },
    onAdd: function(d) {
        var f = d.group,
        b = d.draggable,
        a, e, c;
        if (f) {
            a = [].concat(f);
            e = a.length;
            for (c = 0; c < e; c++) {
                f = a[c];
                this.getGroup(f).add(d)
            }
            delete d.group
        }
        if (b) {
            d.initDraggable()
        }
    },
    remove: function(a, b) {
        if (a) {
            this.items.remove(a);
            this.groups.each(function(c) {
                c.remove(a)
            });
            a.onRemove();
            if (b === true) {
                a.destroy()
            }
        }
    },
    removeAll: function(d) {
        var a = this.items.items,
        c = a.length,
        b;
        for (b = c - 1; b > -1; b--) {
            this.remove(a[b], d)
        }
    },
    onRemove: Ext.emptyFn,
    onDestroy: Ext.emptyFn,
    applyViewBox: function() {
        var d = this,
        l = d.viewBox,
        a = d.width,
        g = d.height,
        f, e, j, b, h, c, k;
        if (l && (a || g)) {
            f = l.x;
            e = l.y;
            j = l.width;
            b = l.height;
            h = g / b;
            c = a / j;
            if (j * h < a) {
                f -= (a - j * h) / 2 / h
            }
            if (b * c < g) {
                e -= (g - b * c) / 2 / c
            }
            k = 1 / Math.min(j, h);
            d.viewBoxShift = {
                dx: -f,
                dy: -e,
                scale: k
            }
        }
    },
    transformToViewBox: function(a, d) {
        if (this.viewBoxShift) {
            var c = this,
            b = c.viewBoxShift;
            return [a * b.scale - b.dx, d * b.scale - b.dy]
        } else {
            return [a, d]
        }
    },
    applyTransformations: function(b) {
        b.bbox.transform = 0;
        this.transform(b);
        var d = this,
        c = false,
        a = b.attr;
        if (a.translation.x != null || a.translation.y != null) {
            d.translate(b);
            c = true
        }
        if (a.scaling.x != null || a.scaling.y != null) {
            d.scale(b);
            c = true
        }
        if (a.rotation.degrees != null) {
            d.rotate(b);
            c = true
        }
        if (c) {
            b.bbox.transform = 0;
            this.transform(b);
            b.transformations = []
        }
    },
    rotate: function(a) {
        var e, b = a.attr.rotation.degrees,
        d = a.attr.rotation.x,
        c = a.attr.rotation.y;
        if (!Ext.isNumber(d) || !Ext.isNumber(c)) {
            e = this.getBBox(a);
            d = !Ext.isNumber(d) ? e.x + e.width / 2 : d;
            c = !Ext.isNumber(c) ? e.y + e.height / 2 : c
        }
        a.transformations.push({
            type: "rotate",
            degrees: b,
            x: d,
            y: c
        })
    },
    translate: function(b) {
        var a = b.attr.translation.x || 0,
        c = b.attr.translation.y || 0;
        b.transformations.push({
            type: "translate",
            x: a,
            y: c
        })
    },
    scale: function(b) {
        var e, a = b.attr.scaling.x || 1,
        f = b.attr.scaling.y || 1,
        d = b.attr.scaling.centerX,
        c = b.attr.scaling.centerY;
        if (!Ext.isNumber(d) || !Ext.isNumber(c)) {
            e = this.getBBox(b);
            d = !Ext.isNumber(d) ? e.x + e.width / 2 : d;
            c = !Ext.isNumber(c) ? e.y + e.height / 2 : c
        }
        b.transformations.push({
            type: "scale",
            x: a,
            y: f,
            centerX: d,
            centerY: c
        })
    },
    rectPath: function(a, e, b, c, d) {
        if (d) {
            return [["M", a + d, e], ["l", b - d * 2, 0], ["a", d, d, 0, 0, 1, d, d], ["l", 0, c - d * 2], ["a", d, d, 0, 0, 1, -d, d], ["l", d * 2 - b, 0], ["a", d, d, 0, 0, 1, -d, -d], ["l", 0, d * 2 - c], ["a", d, d, 0, 0, 1, d, -d], ["z"]]
        }
        return [["M", a, e], ["l", b, 0], ["l", 0, c], ["l", -b, 0], ["z"]]
    },
    ellipsePath: function(a, d, c, b) {
        if (b == null) {
            b = c
        }
        return [["M", a, d], ["m", 0, -b], ["a", c, b, 0, 1, 1, 0, 2 * b], ["a", c, b, 0, 1, 1, 0, -2 * b], ["z"]]
    },
    getPathpath: function(a) {
        return a.attr.path
    },
    getPathcircle: function(c) {
        var b = c.attr;
        return this.ellipsePath(b.x, b.y, b.radius, b.radius)
    },
    getPathellipse: function(c) {
        var b = c.attr;
        return this.ellipsePath(b.x, b.y, b.radiusX || (b.width / 2) || 0, b.radiusY || (b.height / 2) || 0)
    },
    getPathrect: function(c) {
        var b = c.attr;
        return this.rectPath(b.x, b.y, b.width, b.height, b.r)
    },
    getPathimage: function(c) {
        var b = c.attr;
        return this.rectPath(b.x || 0, b.y || 0, b.width, b.height)
    },
    getPathtext: function(a) {
        var b = this.getBBoxText(a);
        return this.rectPath(b.x, b.y, b.width, b.height)
    },
    createGroup: function(b) {
        var a = this.groups.get(b);
        if (!a) {
            a = Ext.create("Ext.draw.CompositeSprite", {
                surface: this
            });
            a.id = b || Ext.id(null, "ext-surface-group-");
            this.groups.add(a)
        }
        return a
    },
    getGroup: function(b) {
        if (typeof b == "string") {
            var a = this.groups.get(b);
            if (!a) {
                a = this.createGroup(b)
            }
        } else {
            a = b
        }
        return a
    },
    prepareItems: function(a, c) {
        a = [].concat(a);
        var e, b, d;
        for (b = 0, d = a.length; b < d; b++) {
            e = a[b];
            if (! (e instanceof Ext.draw.Sprite)) {
                e.surface = this;
                a[b] = this.createItem(e)
            } else {
                e.surface = this
            }
        }
        return a
    },
    setText: Ext.emptyFn,
    createItem: Ext.emptyFn,
    getId: function() {
        return this.id || (this.id = Ext.id(null, "ext-surface-"))
    },
    destroy: function() {
        delete this.domRef;
        this.removeAll()
    }
});
Ext.define("Ext.draw.Component", {
    alias: "widget.draw",
    extend: "Ext.Component",
    requires: ["Ext.draw.Surface", "Ext.layout.component.Draw"],
    enginePriority: ["Svg", "Vml"],
    baseCls: Ext.baseCSSPrefix + "surface",
    componentLayout: "draw",
    viewBox: true,
    autoSize: false,
    initComponent: function() {
        this.callParent(arguments);
        this.addEvents("mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "click")
    },
    onRender: function() {
        var d = this,
        j = d.viewBox,
        b = d.autoSize,
        g, c, a, h, f, e;
        d.callParent(arguments);
        if (d.createSurface() !== false) {
            c = d.surface.items;
            if (j || b) {
                g = c.getBBox();
                a = g.width;
                h = g.height;
                f = g.x;
                e = g.y;
                if (d.viewBox) {
                    d.surface.setViewBox(f, e, a, h)
                } else {
                    d.autoSizeSurface()
                }
            }
        }
    },
    autoSizeSurface: function() {
        var d = this,
        b = d.surface.items,
        e = b.getBBox(),
        c = e.width,
        a = e.height;
        b.setAttributes({
            translate: {
                x: -e.x,
                y: -e.y + ( + Ext.isOpera)
            }
        },
        true);
        if (d.rendered) {
            d.setSize(c, a);
            d.surface.setSize(c, a)
        } else {
            d.surface.setSize(c, a)
        }
        d.el.setSize(c, a)
    },
    createSurface: function() {
        var a = Ext.draw.Surface.create(Ext.apply({},
        {
            width: this.width,
            height: this.height,
            renderTo: this.el
        },
        this.initialConfig));
        if (!a) {
            return false
        }
        this.surface = a;
        function b(c) {
            return function(d) {
                this.fireEvent(c, d)
            }
        }
        a.on({
            scope: this,
            mouseup: b("mouseup"),
            mousedown: b("mousedown"),
            mousemove: b("mousemove"),
            mouseenter: b("mouseenter"),
            mouseleave: b("mouseleave"),
            click: b("click")
        })
    },
    onDestroy: function() {
        var a = this.surface;
        if (a) {
            a.destroy()
        }
        this.callParent(arguments)
    }
});
Ext.define("Ext.resizer.ResizeTracker", {
    extend: "Ext.dd.DragTracker",
    dynamic: true,
    preserveRatio: false,
    constrainTo: null,
    proxyCls: Ext.baseCSSPrefix + "resizable-proxy",
    constructor: function(b) {
        var d = this;
        if (!b.el) {
            if (b.target.isComponent) {
                d.el = b.target.getEl()
            } else {
                d.el = b.target
            }
        }
        this.callParent(arguments);
        if (d.preserveRatio && d.minWidth && d.minHeight) {
            var c = d.minWidth / d.el.getWidth(),
            a = d.minHeight / d.el.getHeight();
            if (a > c) {
                d.minWidth = d.el.getWidth() * a
            } else {
                d.minHeight = d.el.getHeight() * c
            }
        }
        if (d.throttle) {
            var e = Ext.Function.createThrottled(function() {
                Ext.resizer.ResizeTracker.prototype.resize.apply(d, arguments)
            },
            d.throttle);
            d.resize = function(g, h, f) {
                if (f) {
                    Ext.resizer.ResizeTracker.prototype.resize.apply(d, arguments)
                } else {
                    e.apply(null, arguments)
                }
            }
        }
    },
    onBeforeStart: function(a) {
        this.startBox = this.el.getBox()
    },
    getDynamicTarget: function() {
        var a = this,
        b = a.target;
        if (a.dynamic) {
            return b
        } else {
            if (!a.proxy) {
                a.proxy = a.createProxy(b)
            }
        }
        a.proxy.show();
        return a.proxy
    },
    createProxy: function(c) {
        var b, a = this.proxyCls,
        d;
        if (c.isComponent) {
            b = c.getProxy().addCls(a)
        } else {
            d = Ext.getBody();
            if (Ext.scopeResetCSS) {
                d = Ext.getBody().createChild({
                    cls: Ext.baseCSSPrefix + "reset"
                })
            }
            b = c.createProxy({
                tag: "div",
                cls: a,
                id: c.id + "-rzproxy"
            },
            d)
        }
        b.removeCls(Ext.baseCSSPrefix + "proxy-el");
        return b
    },
    onStart: function(a) {
        this.activeResizeHandle = Ext.getCmp(this.getDragTarget().id);
        if (!this.dynamic) {
            this.resize(this.startBox, {
                horizontal: "none",
                vertical: "none"
            })
        }
    },
    onDrag: function(a) {
        if (this.dynamic || this.proxy) {
            this.updateDimensions(a)
        }
    },
    updateDimensions: function(s, m) {
        var t = this,
        c = t.activeResizeHandle.region,
        f = t.getOffset(t.constrainTo ? "dragTarget": null),
        k = t.startBox,
        g,
        p = 0,
        u = 0,
        j,
        q,
        a = 0,
        w = 0,
        v,
        n = f[0] < 0 ? "right": "left",
        r = f[1] < 0 ? "down": "up",
        h,
        b;
        switch (c) {
        case "south":
            u = f[1];
            b = 2;
            break;
        case "north":
            u = -f[1];
            w = -u;
            b = 2;
            break;
        case "east":
            p = f[0];
            b = 1;
            break;
        case "west":
            p = -f[0];
            a = -p;
            b = 1;
            break;
        case "northeast":
            u = -f[1];
            w = -u;
            p = f[0];
            h = [k.x, k.y + k.height];
            b = 3;
            break;
        case "southeast":
            u = f[1];
            p = f[0];
            h = [k.x, k.y];
            b = 3;
            break;
        case "southwest":
            p = -f[0];
            a = -p;
            u = f[1];
            h = [k.x + k.width, k.y];
            b = 3;
            break;
        case "northwest":
            u = -f[1];
            w = -u;
            p = -f[0];
            a = -p;
            h = [k.x + k.width, k.y + k.height];
            b = 3;
            break
        }
        var d = {
            width: k.width + p,
            height: k.height + u,
            x: k.x + a,
            y: k.y + w
        };
        j = Ext.Number.snap(d.width, t.widthIncrement);
        q = Ext.Number.snap(d.height, t.heightIncrement);
        if (j != d.width || q != d.height) {
            switch (c) {
            case "northeast":
                d.y -= q - d.height;
                break;
            case "north":
                d.y -= q - d.height;
                break;
            case "southwest":
                d.x -= j - d.width;
                break;
            case "west":
                d.x -= j - d.width;
                break;
            case "northwest":
                d.x -= j - d.width;
                d.y -= q - d.height
            }
            d.width = j;
            d.height = q
        }
        if (d.width < t.minWidth || d.width > t.maxWidth) {
            d.width = Ext.Number.constrain(d.width, t.minWidth, t.maxWidth);
            if (a) {
                d.x = k.x + (k.width - d.width)
            }
        } else {
            t.lastX = d.x
        }
        if (d.height < t.minHeight || d.height > t.maxHeight) {
            d.height = Ext.Number.constrain(d.height, t.minHeight, t.maxHeight);
            if (w) {
                d.y = k.y + (k.height - d.height)
            }
        } else {
            t.lastY = d.y
        }
        if (t.preserveRatio || s.shiftKey) {
            var o, l;
            g = t.startBox.width / t.startBox.height;
            o = Math.min(Math.max(t.minHeight, d.width / g), t.maxHeight);
            l = Math.min(Math.max(t.minWidth, d.height * g), t.maxWidth);
            if (b == 1) {
                d.height = o
            } else {
                if (b == 2) {
                    d.width = l
                } else {
                    v = Math.abs(h[0] - this.lastXY[0]) / Math.abs(h[1] - this.lastXY[1]);
                    if (v > g) {
                        d.height = o
                    } else {
                        d.width = l
                    }
                    if (c == "northeast") {
                        d.y = k.y - (d.height - k.height)
                    } else {
                        if (c == "northwest") {
                            d.y = k.y - (d.height - k.height);
                            d.x = k.x - (d.width - k.width)
                        } else {
                            if (c == "southwest") {
                                d.x = k.x - (d.width - k.width)
                            }
                        }
                    }
                }
            }
        }
        if (u === 0) {
            r = "none"
        }
        if (p === 0) {
            n = "none"
        }
        t.resize(d, {
            horizontal: n,
            vertical: r
        },
        m)
    },
    getResizeTarget: function(a) {
        return a ? this.target: this.getDynamicTarget()
    },
    resize: function(b, d, a) {
        var c = this.getResizeTarget(a);
        if (c.isComponent) {
            if (c.floating) {
                c.setPagePosition(b.x, b.y)
            }
            c.setSize(b.width, b.height)
        } else {
            c.setBox(b);
            if (this.originalTarget) {
                this.originalTarget.setBox(b)
            }
        }
    },
    onEnd: function(a) {
        this.updateDimensions(a, true);
        if (this.proxy) {
            this.proxy.hide()
        }
    }
});
Ext.define("Ext.data.reader.Array", {
    extend: "Ext.data.reader.Json",
    alternateClassName: "Ext.data.ArrayReader",
    alias: "reader.array",
    buildExtractors: function() {
        this.callParent(arguments);
        var a = this.model.prototype.fields.items,
        b = 0,
        c = a.length,
        e = [],
        d;
        for (; b < c; b++) {
            d = a[b].mapping;
            e.push(function(f) {
                return function(g) {
                    return g[f]
                }
            } (d !== null ? d: b))
        }
        this.extractorFunctions = e
    }
});
Ext.define("Ext.ShadowPool", {
    singleton: true,
    requires: ["Ext.DomHelper"],
    markup: function() {
        if (Ext.supports.CSS3BoxShadow) {
            return '<div class="' + Ext.baseCSSPrefix + 'css-shadow" role="presentation"></div>'
        } else {
            if (Ext.isIE) {
                return '<div class="' + Ext.baseCSSPrefix + 'ie-shadow" role="presentation"></div>'
            } else {
                return '<div class="' + Ext.baseCSSPrefix + 'frame-shadow" role="presentation"><div class="xst" role="presentation"><div class="xstl" role="presentation"></div><div class="xstc" role="presentation"></div><div class="xstr" role="presentation"></div></div><div class="xsc" role="presentation"><div class="xsml" role="presentation"></div><div class="xsmc" role="presentation"></div><div class="xsmr" role="presentation"></div></div><div class="xsb" role="presentation"><div class="xsbl" role="presentation"></div><div class="xsbc" role="presentation"></div><div class="xsbr" role="presentation"></div></div></div>'
            }
        }
    } (),
    shadows: [],
    pull: function() {
        var a = this.shadows.shift();
        if (!a) {
            a = Ext.get(Ext.DomHelper.insertHtml("beforeBegin", document.body.firstChild, this.markup));
            a.autoBoxAdjust = false
        }
        return a
    },
    push: function(a) {
        this.shadows.push(a)
    },
    reset: function() {
        Ext.Array.each(this.shadows,
        function(a) {
            a.remove()
        });
        this.shadows = []
    }
});
Ext.define("Ext.draw.Matrix", {
    requires: ["Ext.draw.Draw"],
    constructor: function(h, g, m, l, k, j) {
        if (h != null) {
            this.matrix = [[h, m, k], [g, l, j], [0, 0, 1]]
        } else {
            this.matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        }
    },
    add: function(t, q, n, l, j, h) {
        var o = this,
        g = [[], [], []],
        s = [[t, n, j], [q, l, h], [0, 0, 1]],
        r,
        p,
        m,
        k;
        for (r = 0; r < 3; r++) {
            for (p = 0; p < 3; p++) {
                k = 0;
                for (m = 0; m < 3; m++) {
                    k += o.matrix[r][m] * s[m][p]
                }
                g[r][p] = k
            }
        }
        o.matrix = g
    },
    prepend: function(t, q, n, l, j, h) {
        var o = this,
        g = [[], [], []],
        s = [[t, n, j], [q, l, h], [0, 0, 1]],
        r,
        p,
        m,
        k;
        for (r = 0; r < 3; r++) {
            for (p = 0; p < 3; p++) {
                k = 0;
                for (m = 0; m < 3; m++) {
                    k += s[r][m] * o.matrix[m][p]
                }
                g[r][p] = k
            }
        }
        o.matrix = g
    },
    invert: function() {
        var k = this.matrix,
        j = k[0][0],
        h = k[1][0],
        o = k[0][1],
        n = k[1][1],
        m = k[0][2],
        l = k[1][2],
        g = j * n - h * o;
        return new Ext.draw.Matrix(n / g, -h / g, -o / g, j / g, (o * l - n * m) / g, (h * m - j * l) / g)
    },
    clone: function() {
        var j = this.matrix,
        h = j[0][0],
        g = j[1][0],
        n = j[0][1],
        m = j[1][1],
        l = j[0][2],
        k = j[1][2];
        return new Ext.draw.Matrix(h, g, n, m, l, k)
    },
    translate: function(a, b) {
        this.prepend(1, 0, 0, 1, a, b)
    },
    scale: function(b, e, a, d) {
        var c = this;
        if (e == null) {
            e = b
        }
        c.add(1, 0, 0, 1, a, d);
        c.add(b, 0, 0, e, 0, 0);
        c.add(1, 0, 0, 1, -a, -d)
    },
    rotate: function(c, b, g) {
        c = Ext.draw.Draw.rad(c);
        var e = this,
        f = +Math.cos(c).toFixed(9),
        d = +Math.sin(c).toFixed(9);
        e.add(f, d, -d, f, b, g);
        e.add(1, 0, 0, 1, -b, -g)
    },
    x: function(a, c) {
        var b = this.matrix;
        return a * b[0][0] + c * b[0][1] + b[0][2]
    },
    y: function(a, c) {
        var b = this.matrix;
        return a * b[1][0] + c * b[1][1] + b[1][2]
    },
    get: function(b, a) {
        return + this.matrix[b][a].toFixed(4)
    },
    toString: function() {
        var a = this;
        return [a.get(0, 0), a.get(0, 1), a.get(1, 0), a.get(1, 1), 0, 0].join()
    },
    toSvg: function() {
        var a = this;
        return "matrix(" + [a.get(0, 0), a.get(1, 0), a.get(0, 1), a.get(1, 1), a.get(0, 2), a.get(1, 2)].join() + ")"
    },
    toFilter: function() {
        var a = this;
        return "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand',FilterType=bilinear,M11=" + a.get(0, 0) + ", M12=" + a.get(0, 1) + ", M21=" + a.get(1, 0) + ", M22=" + a.get(1, 1) + ", Dx=" + a.get(0, 2) + ", Dy=" + a.get(1, 2) + ")"
    },
    offset: function() {
        var a = this.matrix;
        return [(a[0][2] || 0).toFixed(4), (a[1][2] || 0).toFixed(4)]
    },
    split: function() {
        function d(f) {
            return f[0] * f[0] + f[1] * f[1]
        }
        function b(f) {
            var g = Math.sqrt(d(f));
            f[0] /= g;
            f[1] /= g
        }
        var a = this.matrix,
        c = {
            translateX: a[0][2],
            translateY: a[1][2]
        },
        e;
        e = [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
        c.scaleX = Math.sqrt(d(e[0]));
        b(e[0]);
        c.shear = e[0][0] * e[1][0] + e[0][1] * e[1][1];
        e[1] = [e[1][0] - e[0][0] * c.shear, e[1][1] - e[0][1] * c.shear];
        c.scaleY = Math.sqrt(d(e[1]));
        b(e[1]);
        c.shear /= c.scaleY;
        c.rotate = Math.asin( - e[0][1]);
        c.isSimple = !+c.shear.toFixed(9) && (c.scaleX.toFixed(9) == c.scaleY.toFixed(9) || !c.rotate);
        return c
    }
});
Ext.define("Ext.data.proxy.Client", {
    extend: "Ext.data.proxy.Proxy",
    alternateClassName: "Ext.data.ClientProxy",
    clear: function() {
        Ext.Error.raise("The Ext.data.proxy.Client subclass that you are using has not defined a 'clear' function. See src/data/ClientProxy.js for details.")
    }
});
Ext.define("Ext.draw.SpriteDD", {
    extend: "Ext.dd.DragSource",
    constructor: function(b, a) {
        var d = this,
        c = b.el;
        d.sprite = b;
        d.el = c;
        d.dragData = {
            el: c,
            sprite: b
        };
        d.callParent([c, a]);
        d.sprite.setStyle("cursor", "move")
    },
    showFrame: Ext.emptyFn,
    createFrame: Ext.emptyFn,
    getDragEl: function(a) {
        return this.el
    },
    getRegion: function() {
        var j = this,
        f = j.el,
        m, d, c, o, n, s, a, k, g, q, p;
        p = j.sprite;
        q = p.getBBox();
        try {
            m = Ext.Element.getXY(f)
        } catch(h) {}
        if (!m) {
            return null
        }
        d = m[0];
        c = d + q.width;
        o = m[1];
        n = o + q.height;
        return Ext.create("Ext.util.Region", o, c, n, d)
    },
    startDrag: function(b, d) {
        var c = this,
        a = c.sprite.attr;
        c.prev = c.sprite.surface.transformToViewBox(b, d)
    },
    onDrag: function(h) {
        var g = h.getXY(),
        f = this,
        d = f.sprite,
        a = d.attr,
        c,
        b;
        g = f.sprite.surface.transformToViewBox(g[0], g[1]);
        c = g[0] - f.prev[0];
        b = g[1] - f.prev[1];
        d.setAttributes({
            translate: {
                x: a.translation.x + c,
                y: a.translation.y + b
            }
        },
        true);
        f.prev = g
    },
    setDragElPos: function() {
        return false
    }
});
Ext.define("Ext.Shadow", {
    requires: ["Ext.ShadowPool"],
    constructor: function(b) {
        var c = this,
        d = {
            h: 0
        },
        e,
        a;
        Ext.apply(c, b);
        if (!Ext.isString(c.mode)) {
            c.mode = c.defaultMode
        }
        e = c.offset;
        a = Math.floor(e / 2);
        c.opacity = 50;
        switch (c.mode.toLowerCase()) {
        case "drop":
            if (Ext.supports.CSS3BoxShadow) {
                d.w = d.h = -e;
                d.l = d.t = e
            } else {
                d.w = 0;
                d.l = d.t = e;
                d.t -= 1;
                if (Ext.isIE) {
                    d.l -= e + a;
                    d.t -= e + a;
                    d.w -= a;
                    d.h -= a;
                    d.t += 1
                }
            }
            break;
        case "sides":
            if (Ext.supports.CSS3BoxShadow) {
                d.h -= e;
                d.t = e;
                d.l = d.w = 0
            } else {
                d.w = (e * 2);
                d.l = -e;
                d.t = e - 1;
                if (Ext.isIE) {
                    d.l -= (e - a);
                    d.t -= e + a;
                    d.l += 1;
                    d.w -= (e - a) * 2;
                    d.w -= a + 1;
                    d.h -= 1
                }
            }
            break;
        case "frame":
            if (Ext.supports.CSS3BoxShadow) {
                d.l = d.w = d.t = 0
            } else {
                d.w = d.h = (e * 2);
                d.l = d.t = -e;
                d.t += 1;
                d.h -= 2;
                if (Ext.isIE) {
                    d.l -= (e - a);
                    d.t -= (e - a);
                    d.l += 1;
                    d.w -= (e + a + 1);
                    d.h -= (e + a);
                    d.h += 1
                }
                break
            }
        }
        c.adjusts = d
    },
    offset: 4,
    defaultMode: "drop",
    show: function(c) {
        var b = this,
        a;
        c = Ext.get(c);
        if (!b.el) {
            b.el = Ext.ShadowPool.pull();
            if (b.el.dom.nextSibling != c.dom) {
                b.el.insertBefore(c)
            }
        }
        a = (parseInt(c.getStyle("z-index"), 10) - 1) || 0;
        b.el.setStyle("z-index", b.zIndex || a);
        if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
            b.el.dom.style.filter = "progid:DXImageTransform.Microsoft.alpha(opacity=" + b.opacity + ") progid:DXImageTransform.Microsoft.Blur(pixelradius=" + (b.offset) + ")"
        }
        b.realign(c.getLeft(true), c.getTop(true), c.dom.offsetWidth, c.dom.offsetHeight);
        b.el.dom.style.display = "block"
    },
    isVisible: function() {
        return this.el ? true: false
    },
    realign: function(b, p, m, g) {
        if (!this.el) {
            return
        }
        var a = this.adjusts,
        j = this.el.dom,
        k = j.style,
        c, f, n, e, h, o;
        k.left = (b + a.l) + "px";
        k.top = (p + a.t) + "px";
        c = Math.max(m + a.w, 0);
        f = Math.max(g + a.h, 0);
        h = c + "px";
        o = f + "px";
        if (k.width != h || k.height != o) {
            k.width = h;
            k.height = o;
            if (Ext.supports.CSS3BoxShadow) {
                k.boxShadow = "0 0 " + this.offset + "px 0 #888"
            } else {
                if (!Ext.isIE) {
                    n = j.childNodes;
                    e = Math.max(0, (c - 12)) + "px";
                    n[0].childNodes[1].style.width = e;
                    n[1].childNodes[1].style.width = e;
                    n[2].childNodes[1].style.width = e;
                    n[1].style.height = Math.max(0, (f - 12)) + "px"
                }
            }
        }
    },
    hide: function() {
        var a = this;
        if (a.el) {
            a.el.dom.style.display = "none";
            Ext.ShadowPool.push(a.el);
            delete a.el
        }
    },
    setZIndex: function(a) {
        this.zIndex = a;
        if (this.el) {
            this.el.setStyle("z-index", a)
        }
    },
    setOpacity: function(a) {
        if (this.el) {
            if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
                a = Math.floor(a * 100 / 2) / 100
            }
            this.opacity = a;
            this.el.setOpacity(a)
        }
    }
});
Ext.define("Ext.data.proxy.Memory", {
    extend: "Ext.data.proxy.Client",
    alias: "proxy.memory",
    alternateClassName: "Ext.data.MemoryProxy",
    constructor: function(a) {
        this.callParent([a]);
        this.setReader(this.reader)
    },
    read: function(c, f, d) {
        var e = this,
        b = e.getReader(),
        a = b.read(e.data);
        Ext.apply(c, {
            resultSet: a
        });
        c.setCompleted();
        c.setSuccessful();
        Ext.callback(f, d || e, [c])
    },
    clear: Ext.emptyFn
});
Ext.define("Ext.draw.Sprite", {
    mixins: {
        observable: "Ext.util.Observable",
        animate: "Ext.util.Animate"
    },
    requires: ["Ext.draw.SpriteDD"],
    dirty: false,
    dirtyHidden: false,
    dirtyTransform: false,
    dirtyPath: true,
    dirtyFont: true,
    zIndexDirty: true,
    isSprite: true,
    zIndex: 0,
    fontProperties: ["font", "font-size", "font-weight", "font-style", "font-family", "text-anchor", "text"],
    pathProperties: ["x", "y", "d", "path", "height", "width", "radius", "r", "rx", "ry", "cx", "cy"],
    constructor: function(a) {
        var b = this;
        a = a || {};
        b.id = Ext.id(null, "ext-sprite-");
        b.transformations = [];
        Ext.copyTo(this, a, "surface,group,type,draggable");
        b.bbox = {};
        b.attr = {
            zIndex: 0,
            translation: {
                x: null,
                y: null
            },
            rotation: {
                degrees: null,
                x: null,
                y: null
            },
            scaling: {
                x: null,
                y: null,
                cx: null,
                cy: null
            }
        };
        delete a.surface;
        delete a.group;
        delete a.type;
        delete a.draggable;
        b.setAttributes(a);
        b.addEvents("beforedestroy", "destroy", "render", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "click");
        b.mixins.observable.constructor.apply(this, arguments)
    },
    initDraggable: function() {
        var a = this;
        a.draggable = true;
        if (!a.el) {
            a.surface.createSpriteElement(a)
        }
        a.dd = Ext.create("Ext.draw.SpriteDD", a, Ext.isBoolean(a.draggable) ? null: a.draggable);
        a.on("beforedestroy", a.dd.destroy, a.dd)
    },
    setAttributes: function(j, m) {
        var r = this,
        h = r.fontProperties,
        p = h.length,
        f = r.pathProperties,
        e = f.length,
        q = !!r.surface,
        a = q && r.surface.customAttributes || {},
        b = r.attr,
        k, n, g, c, o, l, s, d;
        j = Ext.apply({},
        j);
        for (k in a) {
            if (j.hasOwnProperty(k) && typeof a[k] == "function") {
                Ext.apply(j, a[k].apply(r, [].concat(j[k])))
            }
        }
        if ( !! j.hidden !== !!b.hidden) {
            r.dirtyHidden = true
        }
        for (n = 0; n < e; n++) {
            k = f[n];
            if (k in j && j[k] !== b[k]) {
                r.dirtyPath = true;
                break
            }
        }
        if ("zIndex" in j) {
            r.zIndexDirty = true
        }
        for (n = 0; n < p; n++) {
            k = h[n];
            if (k in j && j[k] !== b[k]) {
                r.dirtyFont = true;
                break
            }
        }
        g = j.translate;
        c = b.translation;
        if (g) {
            if ((g.x && g.x !== c.x) || (g.y && g.y !== c.y)) {
                Ext.apply(c, g);
                r.dirtyTransform = true
            }
            delete j.translate
        }
        o = j.rotate;
        l = b.rotation;
        if (o) {
            if ((o.x && o.x !== l.x) || (o.y && o.y !== l.y) || (o.degrees && o.degrees !== l.degrees)) {
                Ext.apply(l, o);
                r.dirtyTransform = true
            }
            delete j.rotate
        }
        s = j.scale;
        d = b.scaling;
        if (s) {
            if ((s.x && s.x !== d.x) || (s.y && s.y !== d.y) || (s.cx && s.cx !== d.cx) || (s.cy && s.cy !== d.cy)) {
                Ext.apply(d, s);
                r.dirtyTransform = true
            }
            delete j.scale
        }
        Ext.apply(b, j);
        r.dirty = true;
        if (m === true && q) {
            r.redraw()
        }
        return this
    },
    getBBox: function() {
        return this.surface.getBBox(this)
    },
    setText: function(a) {
        return this.surface.setText(this, a)
    },
    hide: function(a) {
        this.setAttributes({
            hidden: true
        },
        a);
        return this
    },
    show: function(a) {
        this.setAttributes({
            hidden: false
        },
        a);
        return this
    },
    remove: function() {
        if (this.surface) {
            this.surface.remove(this);
            return true
        }
        return false
    },
    onRemove: function() {
        this.surface.onRemove(this)
    },
    destroy: function() {
        var a = this;
        if (a.fireEvent("beforedestroy", a) !== false) {
            a.remove();
            a.surface.onDestroy(a);
            a.clearListeners();
            a.fireEvent("destroy")
        }
    },
    redraw: function() {
        this.surface.renderItem(this);
        return this
    },
    setStyle: function() {
        this.el.setStyle.apply(this.el, arguments);
        return this
    },
    addCls: function(a) {
        this.surface.addCls(this, a);
        return this
    },
    removeCls: function(a) {
        this.surface.removeCls(this, a);
        return this
    }
});
Ext.define("Ext.draw.engine.Vml", {
    extend: "Ext.draw.Surface",
    requires: ["Ext.draw.Draw", "Ext.draw.Color", "Ext.draw.Sprite", "Ext.draw.Matrix", "Ext.Element"],
    engine: "Vml",
    map: {
        M: "m",
        L: "l",
        C: "c",
        Z: "x",
        m: "t",
        l: "r",
        c: "v",
        z: "x"
    },
    bitesRe: /([clmz]),?([^clmz]*)/gi,
    valRe: /-?[^,\s-]+/g,
    fillUrlRe: /^url\(\s*['"]?([^\)]+?)['"]?\s*\)$/i,
    pathlike: /^(path|rect)$/,
    NonVmlPathRe: /[ahqstv]/ig,
    partialPathRe: /[clmz]/g,
    fontFamilyRe: /^['"]+|['"]+$/g,
    baseVmlCls: Ext.baseCSSPrefix + "vml-base",
    vmlGroupCls: Ext.baseCSSPrefix + "vml-group",
    spriteCls: Ext.baseCSSPrefix + "vml-sprite",
    measureSpanCls: Ext.baseCSSPrefix + "vml-measure-span",
    zoom: 21600,
    coordsize: 1000,
    coordorigin: "0 0",
    orderSpritesByZIndex: false,
    path2vml: function(s) {
        var m = this,
        t = m.NonVmlPathRe,
        b = m.map,
        e = m.valRe,
        q = m.zoom,
        d = m.bitesRe,
        f = Ext.Function.bind(Ext.draw.Draw.pathToAbsolute, Ext.draw.Draw),
        l,
        n,
        c,
        a,
        h,
        o,
        g,
        k;
        if (String(s).match(t)) {
            f = Ext.Function.bind(Ext.draw.Draw.path2curve, Ext.draw.Draw)
        } else {
            if (!String(s).match(m.partialPathRe)) {
                l = String(s).replace(d,
                function(u, w, p) {
                    var v = [],
                    j = w.toLowerCase() == "m",
                    r = b[w];
                    p.replace(e,
                    function(x) {
                        if (j && v[length] == 2) {
                            r += v + b[w == "m" ? "l": "L"];
                            v = []
                        }
                        v.push(Math.round(x * q))
                    });
                    return r + v
                });
                return l
            }
        }
        n = f(s);
        l = [];
        for (h = 0, o = n.length; h < o; h++) {
            c = n[h];
            a = n[h][0].toLowerCase();
            if (a == "z") {
                a = "x"
            }
            for (g = 1, k = c.length; g < k; g++) {
                a += Math.round(c[g] * m.zoom) + (g != k - 1 ? ",": "")
            }
            l.push(a)
        }
        return l.join(" ")
    },
    translateAttrs: {
        radius: "r",
        radiusX: "rx",
        radiusY: "ry",
        lineWidth: "stroke-width",
        fillOpacity: "fill-opacity",
        strokeOpacity: "stroke-opacity",
        strokeLinejoin: "stroke-linejoin"
    },
    minDefaults: {
        circle: {
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        ellipse: {
            cx: 0,
            cy: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        rect: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        text: {
            x: 0,
            y: 0,
            "text-anchor": "start",
            font: '10px "Arial"',
            fill: "#000",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        path: {
            d: "M0,0",
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        image: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            preserveAspectRatio: "none",
            opacity: null
        }
    },
    onMouseEnter: function(a) {
        this.fireEvent("mouseenter", a)
    },
    onMouseLeave: function(a) {
        this.fireEvent("mouseleave", a)
    },
    processEvent: function(b, f) {
        var d = f.getTarget(),
        a = this.surface,
        c;
        this.fireEvent(b, f);
        c = this.items.get(d.id);
        if (c) {
            c.fireEvent(b, c, f)
        }
    },
    createSpriteElement: function(g) {
        var e = this,
        d = g.attr,
        f = g.type,
        j = e.zoom,
        b = g.vml || (g.vml = {}),
        k = Math.round,
        c = e.createNode("shape"),
        l,
        h,
        a;
        c.coordsize = j + " " + j;
        c.coordorigin = d.coordorigin || "0 0";
        Ext.get(c).addCls(e.spriteCls);
        if (f == "text") {
            b.path = l = e.createNode("path");
            l.textpathok = true;
            b.textpath = a = e.createNode("textpath");
            a.on = true;
            c.appendChild(a);
            c.appendChild(l)
        }
        c.id = g.id;
        g.el = Ext.get(c);
        e.el.appendChild(c);
        if (f !== "image") {
            h = e.createNode("skew");
            h.on = true;
            c.appendChild(h);
            g.skew = h
        }
        g.matrix = Ext.create("Ext.draw.Matrix");
        g.bbox = {
            plain: null,
            transform: null
        };
        g.fireEvent("render", g);
        return g.el
    },
    getBBox: function(a, b) {
        var c = this["getPath" + a.type](a);
        if (b) {
            a.bbox.plain = a.bbox.plain || Ext.draw.Draw.pathDimensions(c);
            return a.bbox.plain
        }
        a.bbox.transform = a.bbox.transform || Ext.draw.Draw.pathDimensions(Ext.draw.Draw.mapPath(c, a.matrix));
        return a.bbox.transform
    },
    getBBoxText: function(b) {
        var a = b.vml;
        return {
            x: a.X + (a.bbx || 0) - a.W / 2,
            y: a.Y - a.H / 2,
            width: a.W,
            height: a.H
        }
    },
    applyAttrs: function(m) {
        var s = this,
        d = m.vml,
        j = m.group,
        b = m.attr,
        c = m.el,
        o = c.dom,
        p, u, r, n, k, q, l, t, a;
        if (j) {
            r = [].concat(j);
            k = r.length;
            for (n = 0; n < k; n++) {
                j = r[n];
                s.getGroup(j).add(m)
            }
            delete m.group
        }
        q = s.scrubAttrs(m) || {};
        if (m.zIndexDirty) {
            s.setZIndex(m)
        }
        Ext.applyIf(q, s.minDefaults[m.type]);
        if (o.href) {
            o.href = q.href
        }
        if (o.title) {
            o.title = q.title
        }
        if (o.target) {
            o.target = q.target
        }
        if (o.cursor) {
            o.cursor = q.cursor
        }
        if (m.dirtyHidden) { (q.hidden) ? s.hidePrim(m) : s.showPrim(m);
            m.dirtyHidden = false
        }
        if (m.dirtyPath) {
            if (m.type == "circle" || m.type == "ellipse") {
                var f = q.x,
                e = q.y,
                h = q.rx || q.r || 0,
                g = q.ry || q.r || 0;
                o.path = Ext.String.format("ar{0},{1},{2},{3},{4},{1},{4},{1}", Math.round((f - h) * s.zoom), Math.round((e - g) * s.zoom), Math.round((f + h) * s.zoom), Math.round((e + g) * s.zoom), Math.round(f * s.zoom));
                m.dirtyPath = false
            } else {
                if (m.type !== "text") {
                    m.attr.path = q.path = s.setPaths(m, q) || q.path;
                    o.path = s.path2vml(q.path);
                    m.dirtyPath = false
                }
            }
        }
        if ("clip-rect" in q) {
            s.setClip(m, q)
        }
        if (m.type == "text") {
            s.setTextAttributes(m, q)
        }
        if (m.type == "image" || q.opacity || q["fill-opacity"] || q.fill) {
            s.setFill(m, q)
        }
        if (q.stroke || q["stroke-opacity"] || q.fill) {
            s.setStroke(m, q)
        }
        p = b.style;
        if (p) {
            c.setStyle(p)
        }
        m.dirty = false
    },
    setZIndex: function(a) {
        if (a.el) {
            if (a.attr.zIndex != undefined) {
                a.el.setStyle("zIndex", a.attr.zIndex)
            }
            a.zIndexDirty = false
        }
    },
    setPaths: function(b, c) {
        var a = b.attr;
        b.bbox.plain = null;
        b.bbox.transform = null;
        if (b.type == "circle") {
            a.rx = a.ry = c.r;
            return Ext.draw.Draw.ellipsePath(b)
        } else {
            if (b.type == "ellipse") {
                a.rx = c.rx;
                a.ry = c.ry;
                return Ext.draw.Draw.ellipsePath(b)
            } else {
                if (b.type == "rect" || b.type == "image") {
                    a.rx = a.ry = c.r;
                    return Ext.draw.Draw.rectPath(b)
                } else {
                    if (b.type == "path" && a.path) {
                        return Ext.draw.Draw.pathToAbsolute(a.path)
                    }
                }
            }
        }
        return false
    },
    setFill: function(k, d) {
        var g = this,
        b = k.el,
        e = b.dom,
        j = e.getElementsByTagName("fill")[0],
        f,
        h,
        a,
        l,
        c;
        if (j) {
            e.removeChild(j)
        } else {
            j = g.createNode("fill")
        }
        if (Ext.isArray(d.fill)) {
            d.fill = d.fill[0]
        }
        if (k.type == "image") {
            j.on = true;
            j.src = d.src;
            j.type = "tile";
            j.rotate = true
        } else {
            if (d.fill == "none") {
                j.on = false
            } else {
                if (typeof d.opacity == "number") {
                    j.opacity = d.opacity
                }
                if (typeof d["fill-opacity"] == "number") {
                    j.opacity = d["fill-opacity"]
                }
                j.on = true;
                if (typeof d.fill == "string") {
                    a = d.fill.match(g.fillUrlRe);
                    if (a) {
                        a = a[1];
                        if (a.charAt(0) == "#") {
                            h = g.gradientsColl.getByKey(a.substring(1))
                        }
                        if (h) {
                            l = d.rotation;
                            c = -(h.angle + 270 + (l ? l.degrees: 0)) % 360;
                            if (c === 0) {
                                c = 180
                            }
                            j.angle = c;
                            j.type = "gradient";
                            j.method = "sigma";
                            j.colors = h.colors
                        } else {
                            j.src = a;
                            j.type = "tile";
                            j.rotate = true
                        }
                    } else {
                        j.color = Ext.draw.Color.toHex(d.fill) || d.fill;
                        j.src = "";
                        j.type = "solid"
                    }
                }
            }
        }
        e.appendChild(j)
    },
    setStroke: function(b, g) {
        var e = this,
        d = b.el.dom,
        h = b.strokeEl,
        f = false,
        c, a;
        if (!h) {
            h = b.strokeEl = e.createNode("stroke");
            f = true
        }
        if (Ext.isArray(g.stroke)) {
            g.stroke = g.stroke[0]
        }
        if (!g.stroke || g.stroke == "none" || g.stroke == 0 || g["stroke-width"] == 0) {
            h.on = false
        } else {
            h.on = true;
            if (g.stroke && !g.stroke.match(e.fillUrlRe)) {
                h.color = Ext.draw.Color.toHex(g.stroke)
            }
            h.joinstyle = g["stroke-linejoin"];
            h.endcap = g["stroke-linecap"] || "round";
            h.miterlimit = g["stroke-miterlimit"] || 8;
            c = parseFloat(g["stroke-width"] || 1) * 0.75;
            a = g["stroke-opacity"] || 1;
            if (Ext.isNumber(c) && c < 1) {
                h.weight = 1;
                h.opacity = a * c
            } else {
                h.weight = c;
                h.opacity = a
            }
        }
        if (f) {
            d.appendChild(h)
        }
    },
    setClip: function(b, f) {
        var e = this,
        c = b.el,
        a = b.clipEl,
        d = String(f["clip-rect"]).split(e.separatorRe);
        if (!a) {
            a = b.clipEl = e.el.insertFirst(Ext.getDoc().dom.createElement("div"));
            a.addCls(Ext.baseCSSPrefix + "vml-sprite")
        }
        if (d.length == 4) {
            d[2] = +d[2] + ( + d[0]);
            d[3] = +d[3] + ( + d[1]);
            a.setStyle("clip", Ext.String.format("rect({1}px {2}px {3}px {0}px)", d[0], d[1], d[2], d[3]));
            a.setSize(e.el.width, e.el.height)
        } else {
            a.setStyle("clip", "")
        }
    },
    setTextAttributes: function(h, c) {
        var g = this,
        a = h.vml,
        e = a.textpath.style,
        f = g.span.style,
        j = g.zoom,
        k = Math.round,
        l = {
            fontSize: "font-size",
            fontWeight: "font-weight",
            fontStyle: "font-style"
        },
        b,
        d;
        if (h.dirtyFont) {
            if (c.font) {
                e.font = f.font = c.font
            }
            if (c["font-family"]) {
                e.fontFamily = '"' + c["font-family"].split(",")[0].replace(g.fontFamilyRe, "") + '"';
                f.fontFamily = c["font-family"]
            }
            for (b in l) {
                d = c[l[b]];
                if (d) {
                    e[b] = f[b] = d
                }
            }
            g.setText(h, c.text);
            if (a.textpath.string) {
                g.span.innerHTML = String(a.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>")
            }
            a.W = g.span.offsetWidth;
            a.H = g.span.offsetHeight + 2;
            if (c["text-anchor"] == "middle") {
                e["v-text-align"] = "center"
            } else {
                if (c["text-anchor"] == "end") {
                    e["v-text-align"] = "right";
                    a.bbx = -Math.round(a.W / 2)
                } else {
                    e["v-text-align"] = "left";
                    a.bbx = Math.round(a.W / 2)
                }
            }
        }
        a.X = c.x;
        a.Y = c.y;
        a.path.v = Ext.String.format("m{0},{1}l{2},{1}", Math.round(a.X * j), Math.round(a.Y * j), Math.round(a.X * j) + 1);
        h.bbox.plain = null;
        h.bbox.transform = null;
        h.dirtyFont = false
    },
    setText: function(a, b) {
        a.vml.textpath.string = Ext.htmlDecode(b)
    },
    hide: function() {
        this.el.hide()
    },
    show: function() {
        this.el.show()
    },
    hidePrim: function(a) {
        a.el.addCls(Ext.baseCSSPrefix + "hide-visibility")
    },
    showPrim: function(a) {
        a.el.removeCls(Ext.baseCSSPrefix + "hide-visibility")
    },
    setSize: function(b, a) {
        var c = this;
        b = b || c.width;
        a = a || c.height;
        c.width = b;
        c.height = a;
        if (c.el) {
            if (b != undefined) {
                c.el.setWidth(b)
            }
            if (a != undefined) {
                c.el.setHeight(a)
            }
            c.applyViewBox();
            c.callParent(arguments)
        }
    },
    setViewBox: function(b, d, c, a) {
        this.callParent(arguments);
        this.viewBox = {
            x: b,
            y: d,
            width: c,
            height: a
        };
        this.applyViewBox()
    },
    applyViewBox: function() {
        var d = this,
        l = d.viewBox,
        a = d.width,
        g = d.height,
        f, e, j, b, h, c, k;
        if (l && (a || g)) {
            f = l.x;
            e = l.y;
            j = l.width;
            b = l.height;
            h = g / b;
            c = a / j;
            if (j * h < a) {
                f -= (a - j * h) / 2 / h
            }
            if (b * c < g) {
                e -= (g - b * c) / 2 / c
            }
            k = 1 / Math.max(j / a, b / g);
            d.viewBoxShift = {
                dx: -f,
                dy: -e,
                scale: k
            };
            d.items.each(function(m) {
                d.transform(m)
            })
        }
    },
    onAdd: function(a) {
        this.callParent(arguments);
        if (this.el) {
            this.renderItem(a)
        }
    },
    onRemove: function(a) {
        if (a.el) {
            a.el.remove();
            delete a.el
        }
        this.callParent(arguments)
    },
    createNode: (function() {
        try {
            var b = Ext.getDoc().dom;
            if (!b.namespaces.rvml) {
                b.namespaces.add("rvml", "urn:schemas-microsoft-com:vml")
            }
            return function(c) {
                return b.createElement("<rvml:" + c + ' class="rvml">')
            }
        } catch(a) {
            return function(c) {
                return b.createElement("<" + c + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">')
            }
        }
    })(),
    render: function(a) {
        var c = this,
        d = Ext.getDoc().dom;
        if (!c.el) {
            var b = d.createElement("div");
            c.el = Ext.get(b);
            c.el.addCls(c.baseVmlCls);
            c.span = d.createElement("span");
            Ext.get(c.span).addCls(c.measureSpanCls);
            b.appendChild(c.span);
            c.el.setSize(c.width || 10, c.height || 10);
            a.appendChild(b);
            c.el.on({
                scope: c,
                mouseup: c.onMouseUp,
                mousedown: c.onMouseDown,
                mouseover: c.onMouseOver,
                mouseout: c.onMouseOut,
                mousemove: c.onMouseMove,
                mouseenter: c.onMouseEnter,
                mouseleave: c.onMouseLeave,
                click: c.onClick
            })
        }
        c.renderAll()
    },
    renderAll: function() {
        this.items.each(this.renderItem, this)
    },
    redraw: function(a) {
        a.dirty = true;
        this.renderItem(a)
    },
    renderItem: function(a) {
        if (!this.el) {
            return
        }
        if (!a.el) {
            this.createSpriteElement(a)
        }
        if (a.dirty) {
            this.applyAttrs(a);
            if (a.dirtyTransform) {
                this.applyTransformations(a)
            }
        }
    },
    rotationCompensation: function(d, c, a) {
        var b = Ext.create("Ext.draw.Matrix");
        b.rotate( - d, 0.5, 0.5);
        return {
            x: b.x(c, a),
            y: b.y(c, a)
        }
    },
    extractTransform: function(j) {
        var g = this,
        h = Ext.create("Ext.draw.Matrix"),
        e,
        c,
        a,
        d,
        f = 0,
        b = g.viewBoxShift;
        for (c = j.transformations, a = c.length; f < a; f++) {
            d = c[f];
            switch (d.type) {
            case "translate":
                h.translate(d.x, d.y);
                break;
            case "rotate":
                h.rotate(d.degrees, d.x, d.y);
                break;
            case "scale":
                h.scale(d.x || d.scale, d.y || d.scale, d.centerX, d.centerY);
                break
            }
        }
        if (b) {
            h.add(1, 0, 0, 1, b.dx, b.dy);
            h.prepend(b.scale, 0, 0, b.scale, 0, 0)
        }
        return j.matrix = h
    },
    setSimpleCoords: function(n, l, k, q, p, e) {
        var j = this,
        m = n.matrix,
        d = n.el.dom,
        a = d.style,
        c = 1,
        f = "",
        o = d.getElementsByTagName("fill")[0],
        h = j.zoom / l,
        g = j.zoom / k,
        b;
        if (!l || !k) {
            return
        }
        d.coordsize = Math.abs(h) + " " + Math.abs(g);
        a.rotation = e * (l * k < 0 ? -1 : 1);
        if (e) {
            b = j.rotationCompensation(e, q, p);
            q = b.x;
            p = b.y
        }
        if (l < 0) {
            f += "x"
        }
        if (k < 0) {
            f += " y";
            c = -1
        }
        a.flip = f;
        d.coordorigin = (q * -h) + " " + (p * -g);
        if (o) {
            d.removeChild(o);
            b = j.rotationCompensation(e, m.x(n.x, n.y), m.y(n.x, n.y));
            o.position = b.x * c + " " + b.y * c;
            o.size = n.width * Math.abs(l) + " " + n.height * Math.abs(k);
            d.appendChild(o)
        }
    },
    transform: function(m) {
        var j = this,
        b = m.el,
        q = m.skew,
        e = b.dom,
        f = e.style,
        l = j.extractTransform(m).clone(),
        k,
        p = j.zoom,
        o = e.getElementsByTagName("fill")[0],
        a = !String(m.fill).indexOf("url("),
        d,
        h;
        if (m.type != "image" && q && !a) {
            q.matrix = l.toString();
            d = l.offset();
            if (d[0] > 32767) {
                d[0] = 32767
            } else {
                if (d[0] < -32768) {
                    d[0] = -32768
                }
            }
            if (d[1] > 32767) {
                d[1] = 32767
            } else {
                if (d[1] < -32768) {
                    d[1] = -32768
                }
            }
            q.offset = d
        } else {
            if (q) {
                q.matrix = "1 0 0 1";
                q.offset = "0 0"
            }
            k = l.split();
            if (k.isSimple) {
                f.filter = "";
                j.setSimpleCoords(m, k.scaleX, k.scaleY, k.translateX, k.translateY, k.rotate / Math.PI * 180)
            } else {
                f.filter = l.toFilter();
                var g = j.getBBox(m),
                r = g.x - m.x,
                n = g.y - m.y;
                e.coordorigin = (r * -p) + " " + (n * -p);
                if (o) {
                    e.removeChild(o);
                    o.position = r + " " + n;
                    o.size = m.width * m.scale.x + " " + m.height * 1.1;
                    e.appendChild(o)
                }
            }
        }
    },
    createItem: function(a) {
        return Ext.create("Ext.draw.Sprite", a)
    },
    getRegion: function() {
        return this.el.getRegion()
    },
    addCls: function(a, b) {
        if (a && a.el) {
            a.el.addCls(b)
        }
    },
    removeCls: function(a, b) {
        if (a && a.el) {
            a.el.removeCls(b)
        }
    },
    addGradient: function(d) {
        var a = this.gradientsColl || (this.gradientsColl = Ext.create("Ext.util.MixedCollection")),
        b = [],
        c = Ext.create("Ext.util.MixedCollection");
        c.addAll(d.stops);
        c.sortByKey("ASC",
        function(f, e) {
            f = parseInt(f, 10);
            e = parseInt(e, 10);
            return f > e ? 1 : (f < e ? -1 : 0)
        });
        c.eachKey(function(f, e) {
            b.push(f + "% " + e.color)
        });
        a.add(d.id, {
            colors: b.join(","),
            angle: d.angle
        })
    },
    destroy: function() {
        var a = this;
        a.callParent(arguments);
        if (a.el) {
            a.el.remove()
        }
        delete a.el
    }
});
Ext.define("Ext.draw.engine.Svg", {
    extend: "Ext.draw.Surface",
    requires: ["Ext.draw.Draw", "Ext.draw.Sprite", "Ext.draw.Matrix", "Ext.Element"],
    engine: "Svg",
    trimRe: /^\s+|\s+$/g,
    spacesRe: /\s+/,
    xlink: "http://www.w3.org/1999/xlink",
    translateAttrs: {
        radius: "r",
        radiusX: "rx",
        radiusY: "ry",
        path: "d",
        lineWidth: "stroke-width",
        fillOpacity: "fill-opacity",
        strokeOpacity: "stroke-opacity",
        strokeLinejoin: "stroke-linejoin"
    },
    parsers: {},
    minDefaults: {
        circle: {
            cx: 0,
            cy: 0,
            r: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        ellipse: {
            cx: 0,
            cy: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        rect: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        text: {
            x: 0,
            y: 0,
            "text-anchor": "start",
            "font-family": null,
            "font-size": null,
            "font-weight": null,
            "font-style": null,
            fill: "#000",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        path: {
            d: "M0,0",
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        image: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            preserveAspectRatio: "none",
            opacity: null
        }
    },
    createSvgElement: function(d, a) {
        var c = this.domRef.createElementNS("http://www.w3.org/2000/svg", d),
        b;
        if (a) {
            for (b in a) {
                c.setAttribute(b, String(a[b]))
            }
        }
        return c
    },
    createSpriteElement: function(a) {
        var b = this.createSvgElement(a.type);
        b.id = a.id;
        if (b.style) {
            b.style.webkitTapHighlightColor = "rgba(0,0,0,0)"
        }
        a.el = Ext.get(b);
        this.applyZIndex(a);
        a.matrix = Ext.create("Ext.draw.Matrix");
        a.bbox = {
            plain: 0,
            transform: 0
        };
        a.fireEvent("render", a);
        return b
    },
    getBBox: function(a, b) {
        var c = this["getPath" + a.type](a);
        if (b) {
            a.bbox.plain = a.bbox.plain || Ext.draw.Draw.pathDimensions(c);
            return a.bbox.plain
        }
        a.bbox.transform = a.bbox.transform || Ext.draw.Draw.pathDimensions(Ext.draw.Draw.mapPath(c, a.matrix));
        return a.bbox.transform
    },
    getBBoxText: function(h) {
        var j = {},
        f, k, a, c, g, b;
        if (h && h.el) {
            b = h.el.dom;
            try {
                j = b.getBBox();
                return j
            } catch(d) {}
            j = {
                x: j.x,
                y: Infinity,
                width: 0,
                height: 0
            };
            g = b.getNumberOfChars();
            for (c = 0; c < g; c++) {
                f = b.getExtentOfChar(c);
                j.y = Math.min(f.y, j.y);
                k = f.y + f.height - j.y;
                j.height = Math.max(j.height, k);
                a = f.x + f.width - j.x;
                j.width = Math.max(j.width, a)
            }
            return j
        }
    },
    hide: function() {
        Ext.get(this.el).hide()
    },
    show: function() {
        Ext.get(this.el).show()
    },
    hidePrim: function(a) {
        this.addCls(a, Ext.baseCSSPrefix + "hide-visibility")
    },
    showPrim: function(a) {
        this.removeCls(a, Ext.baseCSSPrefix + "hide-visibility")
    },
    getDefs: function() {
        return this._defs || (this._defs = this.createSvgElement("defs"))
    },
    transform: function(d) {
        var g = this,
        a = Ext.create("Ext.draw.Matrix"),
        f = d.transformations,
        h = f.length,
        c = 0,
        b,
        e;
        for (; c < h; c++) {
            b = f[c];
            e = b.type;
            if (e == "translate") {
                a.translate(b.x, b.y)
            } else {
                if (e == "rotate") {
                    a.rotate(b.degrees, b.x, b.y)
                } else {
                    if (e == "scale") {
                        a.scale(b.x, b.y, b.centerX, b.centerY)
                    }
                }
            }
        }
        d.matrix = a;
        d.el.set({
            transform: a.toSvg()
        })
    },
    setSize: function(a, c) {
        var d = this,
        b = d.el;
        a = +a || d.width;
        c = +c || d.height;
        d.width = a;
        d.height = c;
        b.setSize(a, c);
        b.set({
            width: a,
            height: c
        });
        d.callParent([a, c])
    },
    getRegion: function() {
        var e = this.el.getXY(),
        c = this.bgRect.getXY(),
        b = Math.max,
        a = b(e[0], c[0]),
        d = b(e[1], c[1]);
        return {
            left: a,
            top: d,
            right: a + this.width,
            bottom: d + this.height
        }
    },
    onRemove: function(a) {
        if (a.el) {
            a.el.remove();
            delete a.el
        }
        this.callParent(arguments)
    },
    setViewBox: function(b, d, c, a) {
        if (isFinite(b) && isFinite(d) && isFinite(c) && isFinite(a)) {
            this.callParent(arguments);
            this.el.dom.setAttribute("viewBox", [b, d, c, a].join(" "))
        }
    },
    render: function(c) {
        var f = this;
        if (!f.el) {
            var e = f.width || 10,
            b = f.height || 10,
            d = f.createSvgElement("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                version: 1.1,
                width: e,
                height: b
            }),
            a = f.getDefs(),
            g = f.createSvgElement("rect", {
                width: "100%",
                height: "100%",
                fill: "#000",
                stroke: "none",
                opacity: 0
            }),
            h;
            if (Ext.isSafari3) {
                h = f.createSvgElement("rect", {
                    x: -10,
                    y: -10,
                    width: "110%",
                    height: "110%",
                    fill: "none",
                    stroke: "#000"
                })
            }
            d.appendChild(a);
            if (Ext.isSafari3) {
                d.appendChild(h)
            }
            d.appendChild(g);
            c.appendChild(d);
            f.el = Ext.get(d);
            f.bgRect = Ext.get(g);
            if (Ext.isSafari3) {
                f.webkitRect = Ext.get(h);
                f.webkitRect.hide()
            }
            f.el.on({
                scope: f,
                mouseup: f.onMouseUp,
                mousedown: f.onMouseDown,
                mouseover: f.onMouseOver,
                mouseout: f.onMouseOut,
                mousemove: f.onMouseMove,
                mouseenter: f.onMouseEnter,
                mouseleave: f.onMouseLeave,
                click: f.onClick
            })
        }
        f.renderAll()
    },
    onMouseEnter: function(a) {
        if (this.el.parent().getRegion().contains(a.getPoint())) {
            this.fireEvent("mouseenter", a)
        }
    },
    onMouseLeave: function(a) {
        if (!this.el.parent().getRegion().contains(a.getPoint())) {
            this.fireEvent("mouseleave", a)
        }
    },
    processEvent: function(b, f) {
        var d = f.getTarget(),
        a = this.surface,
        c;
        this.fireEvent(b, f);
        if (d.nodeName == "tspan" && d.parentNode) {
            d = d.parentNode
        }
        c = this.items.get(d.id);
        if (c) {
            c.fireEvent(b, c, f)
        }
    },
    tuneText: function(h, j) {
        var a = h.el.dom,
        b = [],
        l,
        g,
        k,
        d,
        e,
        c,
        f;
        if (j.hasOwnProperty("text")) {
            b = this.setText(h, j.text)
        }
        if (b.length) {
            l = this.getBBoxText(h).height;
            for (d = 0, e = b.length; d < e; d++) {
                f = (Ext.isFF3_0 || Ext.isFF3_5) ? 2 : 4;
                b[d].setAttribute("dy", d ? l * 1.2 : l / f)
            }
            h.dirty = true
        }
    },
    setText: function(k, d) {
        var g = this,
        a = k.el.dom,
        j = a.getAttribute("x"),
        b = [],
        m,
        h,
        l,
        e,
        f,
        c;
        while (a.firstChild) {
            a.removeChild(a.firstChild)
        }
        c = String(d).split("\n");
        for (e = 0, f = c.length; e < f; e++) {
            l = c[e];
            if (l) {
                h = g.createSvgElement("tspan");
                h.appendChild(document.createTextNode(Ext.htmlDecode(l)));
                h.setAttribute("x", j);
                a.appendChild(h);
                b[e] = h
            }
        }
        return b
    },
    renderAll: function() {
        this.items.each(this.renderItem, this)
    },
    renderItem: function(a) {
        if (!this.el) {
            return
        }
        if (!a.el) {
            this.createSpriteElement(a)
        }
        if (a.zIndexDirty) {
            this.applyZIndex(a)
        }
        if (a.dirty) {
            this.applyAttrs(a);
            this.applyTransformations(a)
        }
    },
    redraw: function(a) {
        a.dirty = a.zIndexDirty = true;
        this.renderItem(a)
    },
    applyAttrs: function(q) {
        var l = this,
        c = q.el,
        p = q.group,
        h = q.attr,
        r = l.parsers,
        f = l.gradientsMap || {},
        j = Ext.isSafari && !Ext.isStrict,
        e, g, k, o, d, n, b, a, m;
        if (p) {
            e = [].concat(p);
            k = e.length;
            for (g = 0; g < k; g++) {
                p = e[g];
                l.getGroup(p).add(q)
            }
            delete q.group
        }
        o = l.scrubAttrs(q) || {};
        q.bbox.plain = 0;
        q.bbox.transform = 0;
        if (q.type == "circle" || q.type == "ellipse") {
            o.cx = o.cx || o.x;
            o.cy = o.cy || o.y
        } else {
            if (q.type == "rect") {
                o.rx = o.ry = o.r
            } else {
                if (q.type == "path" && o.d) {
                    o.d = Ext.draw.Draw.pathToString(Ext.draw.Draw.pathToAbsolute(o.d))
                }
            }
        }
        q.dirtyPath = false;
        if (o["clip-rect"]) {
            l.setClip(q, o);
            delete o["clip-rect"]
        }
        if (q.type == "text" && o.font && q.dirtyFont) {
            c.set({
                style: "font: " + o.font
            });
            q.dirtyFont = false
        }
        if (q.type == "image") {
            c.dom.setAttributeNS(l.xlink, "href", o.src)
        }
        Ext.applyIf(o, l.minDefaults[q.type]);
        if (q.dirtyHidden) { (h.hidden) ? l.hidePrim(q) : l.showPrim(q);
            q.dirtyHidden = false
        }
        for (n in o) {
            if (o.hasOwnProperty(n) && o[n] != null) {
                if (j && ("color|stroke|fill".indexOf(n) > -1) && (o[n] in f)) {
                    o[n] = f[o[n]]
                }
                if (n in r) {
                    c.dom.setAttribute(n, r[n](o[n], q, l))
                } else {
                    c.dom.setAttribute(n, o[n])
                }
            }
        }
        if (q.type == "text") {
            l.tuneText(q, o)
        }
        b = h.style;
        if (b) {
            c.setStyle(b)
        }
        q.dirty = false;
        if (Ext.isSafari3) {
            l.webkitRect.show();
            setTimeout(function() {
                l.webkitRect.hide()
            })
        }
    },
    setClip: function(b, f) {
        var e = this,
        d = f["clip-rect"],
        a,
        c;
        if (d) {
            if (b.clip) {
                b.clip.parentNode.parentNode.removeChild(b.clip.parentNode)
            }
            a = e.createSvgElement("clipPath");
            c = e.createSvgElement("rect");
            a.id = Ext.id(null, "ext-clip-");
            c.setAttribute("x", d.x);
            c.setAttribute("y", d.y);
            c.setAttribute("width", d.width);
            c.setAttribute("height", d.height);
            a.appendChild(c);
            e.getDefs().appendChild(a);
            b.el.dom.setAttribute("clip-path", "url(#" + a.id + ")");
            b.clip = c
        }
    },
    applyZIndex: function(d) {
        var f = this,
        b = f.items,
        a = b.indexOf(d),
        e = d.el,
        c;
        if (f.el.dom.childNodes[a + 2] !== e.dom) {
            if (a > 0) {
                do {
                    c = b.getAt(--a).el
                } while (! c && a > 0 )
            }
            e.insertAfter(c || f.bgRect)
        }
        d.zIndexDirty = false
    },
    createItem: function(a) {
        var b = Ext.create("Ext.draw.Sprite", a);
        b.surface = this;
        return b
    },
    addGradient: function(g) {
        g = Ext.draw.Draw.parseGradient(g);
        var e = this,
        d = g.stops.length,
        a = g.vector,
        k = Ext.isSafari && !Ext.isStrict,
        h, f, j, c, b;
        b = e.gradientsMap || {};
        if (!k) {
            if (g.type == "linear") {
                h = e.createSvgElement("linearGradient");
                h.setAttribute("x1", a[0]);
                h.setAttribute("y1", a[1]);
                h.setAttribute("x2", a[2]);
                h.setAttribute("y2", a[3])
            } else {
                h = e.createSvgElement("radialGradient");
                h.setAttribute("cx", g.centerX);
                h.setAttribute("cy", g.centerY);
                h.setAttribute("r", g.radius);
                if (Ext.isNumber(g.focalX) && Ext.isNumber(g.focalY)) {
                    h.setAttribute("fx", g.focalX);
                    h.setAttribute("fy", g.focalY)
                }
            }
            h.id = g.id;
            e.getDefs().appendChild(h);
            for (c = 0; c < d; c++) {
                f = g.stops[c];
                j = e.createSvgElement("stop");
                j.setAttribute("offset", f.offset + "%");
                j.setAttribute("stop-color", f.color);
                j.setAttribute("stop-opacity", f.opacity);
                h.appendChild(j)
            }
        } else {
            b["url(#" + g.id + ")"] = g.stops[0].color
        }
        e.gradientsMap = b
    },
    hasCls: function(a, b) {
        return b && (" " + (a.el.dom.getAttribute("class") || "") + " ").indexOf(" " + b + " ") != -1
    },
    addCls: function(e, g) {
        var f = e.el,
        d, a, c, b = [],
        h = f.getAttribute("class") || "";
        if (!Ext.isArray(g)) {
            if (typeof g == "string" && !this.hasCls(e, g)) {
                f.set({
                    "class": h + " " + g
                })
            }
        } else {
            for (d = 0, a = g.length; d < a; d++) {
                c = g[d];
                if (typeof c == "string" && (" " + h + " ").indexOf(" " + c + " ") == -1) {
                    b.push(c)
                }
            }
            if (b.length) {
                f.set({
                    "class": " " + b.join(" ")
                })
            }
        }
    },
    removeCls: function(j, f) {
        var g = this,
        b = j.el,
        d = b.getAttribute("class") || "",
        c,
        h,
        e,
        k,
        a;
        if (!Ext.isArray(f)) {
            f = [f]
        }
        if (d) {
            a = d.replace(g.trimRe, " ").split(g.spacesRe);
            for (c = 0, e = f.length; c < e; c++) {
                k = f[c];
                if (typeof k == "string") {
                    k = k.replace(g.trimRe, "");
                    h = Ext.Array.indexOf(a, k);
                    if (h != -1) {
                        Ext.Array.erase(a, h, 1)
                    }
                }
            }
            b.set({
                "class": a.join(" ")
            })
        }
    },
    destroy: function() {
        var a = this;
        a.callParent();
        if (a.el) {
            a.el.remove()
        }
        delete a.el
    }
});
Ext.define("Trading.controller.Feed", {
    extend: "Ext.app.Controller",
    lsClient: null,
    init: function() {
        this.lsClient = new LightstreamerClient("https://" + Registry.lsHost, "ts");
        this.lsClient.connect();
        this.lsClient.subscribe(this.getQuoteSubscription());
        this.lsClient.subscribe(this.getClockSubscription());
        this.lsClient.subscribe(this.getPayoutSubscription());
        this.lsClient.subscribe(this.getExpiredSubscription());
        this.lsClient.subscribe(this.getCalculatedSubscription());
        if (Registry.userID) {
            this.lsClient.subscribe(this.getTradesSubscription(Registry.practiceMode))
        }
        if (Registry.userID && Registry.practiceMode) {
            this.lsClient.subscribe(this.getPracticeSubscription())
        }
        this.lsClient.subscribe(this.getShortgamesSubscription());
        this.lsClient.subscribe(this.getAssetsSubscription());
        this.lsClient.subscribe(this.getToppicksSubscription());
        this.lsClient.subscribe(this.getManualActiveGamesSubscription());
        this.lsClient.subscribe(this.getActiveGamesSubscription())
    },
    getQuoteSubscription: function() {
        var a = [];
        var b;
        for (b = 1; b <= Registry.lastFeedInstrumentID; b++) {
            a.push("item" + b)
        }
        var c = new Subscription("MERGE", a, ["lastPrice", "time", "bid", "ask"]);
        c.setDataAdapter("quotes");
        c.addListener({
            onItemUpdate: this.handleQuote
        });
        return c
    },
    getClockSubscription: function() {
        var a = new Subscription("MERGE", ["clock"], ["time"]);
        a.setDataAdapter("clock");
        a.addListener({
            onItemUpdate: this.handleClock
        });
        return a
    },
    getPayoutSubscription: function() {
        var a = new Subscription("MERGE", ["site" + Registry.siteID], ["time"]);
        a.setDataAdapter("payouts");
        a.addListener({
            onItemUpdate: this.handlePayouts
        });
        return a
    },
    getExpiredSubscription: function() {
        var a = new Subscription("MERGE", ["expired"], ["time"]);
        a.setDataAdapter("expired");
        a.addListener({
            onItemUpdate: this.handleExpired
        });
        return a
    },
    getCalculatedSubscription: function() {
        var a = new Subscription("MERGE", ["calculated"], ["time"]);
        a.setDataAdapter("calculated");
        a.addListener({
            onItemUpdate: this.handleCalculated
        });
        return a
    },
    getTradesSubscription: function(c) {
        var a = c ? ["practice_trades_" + Registry.userID] : ["trades_" + Registry.userID];
        var b = new Subscription("RAW", a, ["trades", "time"]);
        b.setDataAdapter("trades");
        b.addListener({
            onItemUpdate: this.handleTrades
        });
        return b
    },
    getPracticeSubscription: function() {
        var a = new Subscription("MERGE", ["practice_status_" + Registry.userID], ["time", "status"]);
        a.setDataAdapter("practice");
        a.addListener({
            onItemUpdate: this.handlePracticeMode
        });
        return a
    },
    getShortgamesSubscription: function() {
        var a = new Subscription("MERGE", ["site" + Registry.siteID], ["time"]);
        a.setDataAdapter("shortgames");
        a.addListener({
            onItemUpdate: this.handleShortGames
        });
        return a
    },
    getAssetsSubscription: function() {
        var a = new Subscription("MERGE", ["site" + Registry.siteID], ["time"]);
        a.setDataAdapter("assets");
        a.addListener({
            onItemUpdate: this.handleAssets
        });
        return a
    },
    getToppicksSubscription: function() {
        var a = new Subscription("MERGE", ["site" + Registry.siteID], ["time"]);
        a.setDataAdapter("toppicks");
        a.addListener({
            onItemUpdate: this.handleTopPicks
        });
        return a
    },
    getManualActiveGamesSubscription: function() {
        var a = new Subscription("MERGE", ["site" + Registry.siteID], ["time"]);
        a.setDataAdapter("manualactivegames");
        a.addListener({
            onItemUpdate: this.handleManualActiveGames
        });
        return a
    },
    getActiveGamesSubscription: function() {
        var a = new Subscription("MERGE", ["active_games"], ["active", "time"]);
        a.setDataAdapter("distance");
        a.addListener({
            onItemUpdate: this.handleActiveGames
        });
        return a
    },
    getDistancesSubscription: function(b) {
        var a = [];
        for (var c = 0; c < b.length; c++) {
            a.push("distance_" + b[c])
        }
        var d = new Subscription("MERGE", a, ["distance", "time"]);
        d.setDataAdapter("distance");
        d.addListener({
            onItemUpdate: this.handleDistances
        });
        return d
    },
    getABOrderDistancesSubscription: function(b) {
        var a = [];
        for (var c = 0; c < b.length; c++) {
            a.push("distance_" + b[c])
        }
        var d = new Subscription("MERGE", a, ["distance", "time"]);
        d.setDataAdapter("distance_ab_order");
        d.addListener({
            onItemUpdate: this.handleABOrderDistances
        });
        return d
    },
    getABOrderStartPricesSubscription: function() {
        var a = new Subscription("MERGE", ["start_prices"], ["timestamp", "data"]);
        a.setDataAdapter("ab_order_start");
        a.addListener({
            onItemUpdate: this.handleABOrderStartPrices
        });
        return a
    },
    handleQuote: function(g) {
        var e = g.getItemName();
        var c = parseFloat(g.getValue("lastPrice"));
        var d = g.getValue("time");
        var b = g.getValue("bid");
        var f = g.getValue("ask");
        if (!c) {
            return
        }
        if (Registry.customIndexView) {
            if (typeof(FX1) != "undefined") {
                FX1.quote(e, c, d * 1000)
            }
            return
        }
        var a = Trading.app.getController("Instrument");
        if (a) {
            a.update(e, c, d * 1000, f, b)
        }
    },
    handleClock: function(c) {
        var b = c.getValue("time");
        var a = Trading.app.getController("Clock");
        if (a && b) {
            a.update(b)
        }
    },
    handleExpired: function(c) {
        var b = c.getValue("time");
        var a = Trading.app.getController("Expiry");
        if (a && b) {
            a.expired(b * 1000)
        }
    },
    handleCalculated: function(c) {
        var b = c.getValue("time");
        var a = Trading.app.getController("Expiry");
        if (a && b) {
            a.calculated(b * 1000)
        }
    },
    handlePayouts: function(c) {
        var b = c.getValue("time");
        var a = Trading.app.getController("Instrument");
        if (a && b) {
            a.payouts(b * 1000)
        }
    },
    handleAssets: function(c) {
        var b = c.getValue("time");
        var a = Trading.app.getController("Instrument");
        if (a && b) {
            a.assets(b)
        }
    },
    handleShortGames: function(c) {
        var b = c.getValue("time");
        var a = Trading.app.getController("Instrument");
        if (a && b) {
            a.shortgames(b)
        }
    },
    handleTopPicks: function(c) {
        var b = c.getValue("time");
        var a = Trading.app.getController("Instrument");
        if (a && b) {
            a.toppicks(b)
        }
    },
    handleTrades: function(c) {
        var b = c.getValue("trades");
        b = JSON.parse(b);
        if (typeof(FX1) !== "undefined") {
            FX1.updateTrades(b)
        } else {
            var a = Trading.app.getController("Expiry");
            a.closeTrades(b)
        }
    },
    handleManualActiveGames: function(c) {
        var b = c.getValue("time");
        console.log("LS manual active games data: " + b);
        if (b) {
            var a = Trading.app.getController("Instrument");
            a.updateGameData()
        }
    },
    handleActiveGames: function(b) {
        var a = b.getValue("active");
        if (a) {
            a = JSON.parse(a);
            FinancialPanel.updateActiveGames(a)
        }
    },
    handleRefresh: function(b) {
        var a = Trading.app.getController("Instrument");
        a.updateGameData()
    },
    handleDistances: function(c) {
        var b = c.getItemName();
        var a = c.getValue("distance");
        FinancialPanel.updateDistances(b, a)
    },
    handleABOrderDistances: function(c) {
        var b = c.getItemName();
        var a = c.getValue("distance");
        if (typeof(FX1) !== "undefined") {
            FX1.updateDistances(b, a)
        }
    },
    handleABOrderStartPrices: function(c) {
        var a = c.getValue("data");
        var b = c.getValue("timestamp");
        FX1.updateABOrderInfo(b, a)
    },
    lastPracticeEventUpdate: false,
    handlePracticeMode: function(b) {
        var a = Ext.decode(b.getValue("status"));
        if (this.lastPracticeEventUpdate) {
            if (a.expired) {
                a = "expired"
            } else {
                if (a.reset) {
                    a = "reset"
                }
            }
            User.practicePopUpMessage(a)
        }
        this.lastPracticeEventUpdate = true
    }
});
Ext.define("Trading.controller.Clock", {
    extend: "Ext.app.Controller",
    time: 0,
    date: null,
    minutes: -1,
    task: null,
    started: false,
    init: function() {
        this.time = Registry.time;
        this.date = new Date(this.time)
    },
    update: function(a) {
        a = (a * 1);
        if (a > this.time) {
            this.time = a
        }
        if (!this.task) {
            this.runTask()
        }
    },
    runTask: function() {
        this.task = {
            run: function() {
                var b = 1000;
                var c;
                var g;
                var f = false;
                var e = false;
                var a = false;
                if (!this.started) {
                    b = 0;
                    this.started = true
                }
                this.time = (this.time * 1) + b;
                this.date.setTime(this.time);
                Ext.getDom("clock").innerHTML = this.date.toTimeString();
                c = this.date.getMinutes();
                if (c != this.minutes) {
                    if (this.minutes > -1) {
                        e = true;
                        if (Ext.Array.contains([0, 15, 30, 45], c)) {
                            a = true
                        }
                    }
                    this.minutes = c
                }
                g = this.date.getSeconds();
                if (g == 30) {
                    f = true
                }
                var j = Trading.app.getController("Instrument");
                var h = Trading.app.getController("Game");
                var d = Trading.app.getController("User");
                j.setTime(this.time, a);
                h.setTime(this.time, e, f);
                d.setTime(this.time, e)
            },
            interval: 1000,
            scope: this
        };
        Ext.TaskManager.start(this.task)
    }
});
Ext.define("Trading.controller.Filter", {
    extend: "Ext.app.Controller",
    activeMainTabId: "game-filter-featured",
    activeMainDataFilter: "featured",
    activeSubTabId: null,
    activeSubDataFilter: null,
    init: function() {
        if (Registry.customIndexView) {
            return
        }
        var a = this;
        a.initMainTabs();
        a.initSubTabs();
        a.initSearch();
        a.initWidgets()
    },
    initMainTabs: function() {
        var a = this;
        var c = Ext.query("#game-filter-main-tabs .filter-main-tab");
        var b;
        for (b = 0; b < c.length; b++) {
            Ext.get(c[b]).on("click",
            function(f, e) {
                var d = e.getAttribute("data-filter");
                if (d == "all" || d == "starred") {
                    if (!Trading.app.getController("User").forceLogin()) {
                        return false
                    }
                }
                a.setFilter(d);
                if (d == "all") {
                    a.updateAnalysisWidgetView(d)
                }
            })
        }
    },
    setFilter: function(b) {
        this.activeMainDataFilter = b;
        this.activeMainTabId = "game-filter-" + this.activeMainDataFilter;
        this.activeSubTabId = null;
        this.activeSubDataFilter = null;
        var a = this.filter(this.activeMainDataFilter);
        if (a) {
            this.clearFilter();
            this.setActiveTabs()
        }
    },
    initSubTabs: function() {
        var a = this;
        var c = Ext.query("#game-filter-sub-tabs .filter-sub-tab");
        var b;
        for (b = 0; b < c.length; b++) {
            Ext.get(c[b]).on("click",
            function(e, d) {
                a.activeSubDataFilter = d.getAttribute("data-filter");
                a.activeSubTabId = "game-filter-" + a.activeSubDataFilter;
                a.clearFilter();
                a.setActiveTabs();
                a.filter(a.activeSubDataFilter);
                a.updateAnalysisWidgetView(a.activeSubDataFilter)
            })
        }
    },
    updateAnalysisWidgetView: function(a) {
        if (a == "all") {
            a = 0
        } else {
            if (a > 4) {
                a = 0
            }
        }
        var c = Ext.get("autochartist-iframe");
        if (c) {
            var b = c.dom.src.split("#");
            c.dom.src = b[0] + "#results/" + a
        }
    },
    initSearch: function() {
        var a = this;
        Ext.fly("filter-search-button").on("click",
        function() {
            a.search()
        });
        Ext.fly("filter-search-input").on("keypress",
        function(c, b) {
            if (c.keyCode == 13) {
                a.search()
            }
        })
    },
    initWidgets: function() {
        var b = this;
        if (typeof autochartistUrl !== "undefined") {
            var c = /^(http|https)\:\/\/[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?\//;
            var a = c.exec(autochartistUrl);
            window.addEventListener("message",
            function(f) {
                if ((a !== null) && f.origin + "/" === a[0]) {
                    var g = JSON.parse(f.data);
                    if (typeof(debugAutochartist) !== "undefined") {
                        console.log(g)
                    }
                    if (g.type === "result:select") {
                        var d = g.value;
                        if (d.symbol_group == 0) {
                            b.setFilter("all")
                        } else {
                            if ((Ext.get("game-filter-" + d.symbol_group))) {
                                if (assetAcSymbols[d.symbol]) {
                                    if (typeof(debugAutochartist) !== "undefined") {
                                        console.log("symbol: " + d.symbol)
                                    }
                                    var e = assetAcSymbols[d.symbol];
                                    b.search(e.name, "nameEnglish")
                                }
                            }
                        }
                    }
                }
            },
            false)
        }
    },
    setActiveTabs: function() {
        if (this.activeMainTabId != null) {
            Ext.fly(this.activeMainTabId).addCls("active")
        }
        if (this.activeSubTabId != null) {
            Ext.fly(this.activeSubTabId).addCls("active")
        }
    },
    clearFilter: function() {
        var a = Ext.query(".filter-main-tab");
        var b;
        for (b = 0; b < a.length; b++) {
            Ext.fly(a[b]).removeCls("active")
        }
        a = Ext.query(".filter-sub-tab");
        for (b = 0; b < a.length; b++) {
            Ext.fly(a[b]).removeCls("active")
        }
        Ext.getDom("filter-search-input").value = "";
        Ext.fly("game-filter-search-msg-container").addCls("x-hidden")
    },
    filter: function(d) {
        var b = this;
        var f = Trading.app.getController("Game");
        var a = b.activeMainDataFilter == "all";
        var e = a ? "": b.activeMainDataFilter;
        var c = true;
        if (b.activeSubTabId == null) {
            c = f.filter(e)
        } else {
            if (a) {
                c = f.filter([{
                    property: "type",
                    value: d
                }])
            } else {
                c = f.filter([{
                    property: e,
                    value: true
                },
                {
                    property: "type",
                    value: d
                }])
            }
        }
        return (c != false)
    },
    search: function(f, e) {
        var a = this;
        var g = Trading.app.getController("Game");
        if (f) {
            var d = f
        } else {
            var d = Ext.getDom("filter-search-input").value
        }
        var c = "name";
        if (e) {
            c = e
        }
        a.clearFilter();
        a.activeMainTabId = "game-filter-all";
        a.activeMainDataFilter = "all";
        a.activeSubTabId = null;
        a.activeSubDataFilter = null;
        if (!d) {
            g.filter()
        } else {
            var b = new RegExp(d, "i");
            g.filter([{
                property: c,
                value: b
            }]);
            if ($("#games-wrapper").css("display") === "none") {
                Ext.fly("game-filter-search-msg-container").removeCls("x-hidden");
                Ext.fly("game-filter-search-msg").update(Registry._["game-filter-search-msg-no-results"])
            }
        }
        a.setActiveTabs()
    }
});
Ext.define("Trading.controller.Expiry", {
    extend: "Ext.app.Controller",
    expiries: null,
    expiryPrices: null,
    lastExpiry: 0,
    lastCalculated: [],
    init: function() {
        this.expiries = {};
        this.expiryPrices = {}
    },
    addExpiry: function(a, b) {
        if (!this.expiries[a]) {
            this.expiries[a] = []
        }
        this.expiries[a].push(b)
    },
    expired: function(c) {
        return;
        if ((this.expiries[c]) && (c > this.lastExpiry)) {
            this.lastExpiry = c;
            var a = this;
            var b = Trading.app.getController("User");
            Ext.data.JsonP.request({
                url: Registry.cdn + "/expiries/" + (c / 1000) + ".json",
                callbackName: "expiries",
                scope: this,
                success: function(d) {
                    a.expiryPrices[c] = d;
                    var e;
                    var f;
                    var g;
                    for (e = 0; e < a.expiries[c].length; e++) {
                        f = a.expiries[c][e];
                        g = b.trades.getById(f);
                        if (!g.data.closed) {
                            g.data.expiryPrice = a.expiryPrices[c][g.data.instrumentID];
                            Ext.fly("trade-entry-expiry-" + f).dom.innerHTML = "Price: " + g.data.expiryPrice;
                            if (Ext.fly("fp-trade-entry-expiry-" + f)) {
                                Ext.fly("fp-trade-entry-expiry-" + f).dom.innerHTML = g.data.expiryPrice
                            }
                        }
                    }
                    if (Ext.Array.contains(a.lastCalculated, c)) {
                        a.calcTrades(c)
                    }
                }
            })
        }
    },
    calculated: function(a) {
        if (this.expiries[a] && !Ext.Array.contains(this.lastCalculated, a)) {
            this.lastCalculated.push(a)
        }
        if (this.expiryPrices[a]) {
            this.calcTrades(a)
        }
    },
    calcTrades: function(h) {
        return;
        var j = Trading.app.getController("User");
        var f = j.trades;
        var e = j.wallet;
        var o = this.expiries[h];
        var m;
        var c;
        var q;
        var l;
        var a;
        var d;
        var s;
        var t;
        var p;
        var n;
        var g = true;
        delete this.expiries[h];
        Ext.Array.erase(this.lastCalculated, Ext.Array.indexOf(this.lastCalculated, h), 1);
        for (q = 0; q < o.length; q++) {
            m = o[q];
            c = f.getById(m);
            if (!c.data.closed) {
                a = c.data.strike * 1;
                d = c.data.distance * 1;
                s = c.data.expiryPrice * 1;
                t = c.data.direction;
                l = 0;
                p = c.data.stake;
                n = "at";
                if (c.data.type == 1 || c.data.type == 2) {
                    if (a != s) {
                        if (t == 1) {
                            l = (s > a) ? 1 : -1
                        } else {
                            l = (s < a) ? 1 : -1
                        }
                    }
                } else {
                    if (c.data.type == 3) {
                        if (t == 1) {
                            l = (s > a + d) ? 1 : -1
                        } else {
                            l = (s < a - d) ? 1 : -1
                        }
                    } else {
                        if (c.data.type == 4) {
                            if (t == 1) {
                                l = (s >= a && s <= a + d) ? 1 : -1
                            } else {
                                l = (s >= a - d && s <= a) ? 1 : -1
                            }
                        } else {
                            continue
                        }
                    }
                }
                switch (l) {
                case 1:
                    p = c.data.stake + (c.data.stake * c.data.payout / 100);
                    n = "in";
                    break;
                case - 1 : p = (c.data.stake * c.data.rebate / 100);
                    n = "out";
                    break
                }
                e.reserved -= c.data.stake;
                e.credit += p;
                Ext.fly("trade-entry-indicator-" + m).dom.innerHTML = Registry._["label-return-amount"] + ": " + Registry.baseCurrencySymbol + Ext.util.Format.number(p, "0,0.00");
                if (Ext.fly("fp-trade-entry-indicator-" + m)) {
                    Ext.fly("fp-trade-entry-indicator-" + m).dom.innerHTML = Registry._["label-return-amount"] + ": " + Registry.baseCurrencySymbol + Ext.util.Format.number(p, "0,0.00")
                }
                Ext.fly("trade-" + m + "-close-position").hide();
                Ext.fly("evaluation-message-" + m).hide();
                if (c.data.bonus) {
                    g = false;
                    var r = new Ext.util.DelayedTask(function() {
                        Ext.Ajax.request({
                            url: Registry.uriBase + "/ajax/index/get-wallet-details",
                            success: function(z) {
                                z = Ext.decode(z.responseText);
                                var v = z.wallet;
                                var A = Ext.get("wallet-promotional-bonus-used");
                                A.hide();
                                var y = parseFloat(v.credit);
                                var x = parseFloat(v.reserved);
                                var w = parseFloat(v.bonus.promotional);
                                var B = parseFloat(v.bonus.amount);
                                var C = parseFloat(v.bonus.traded);
                                var D = parseFloat(v.bonus.required);
                                Ext.fly("wallet-credit").dom.innerHTML = Ext.util.Format.number(y, "0,0.00");
                                Ext.fly("wallet-reserved").dom.innerHTML = Ext.util.Format.number(x, "0,0.00");
                                Ext.fly("wallet-balance").dom.innerHTML = Ext.util.Format.number(y + x, "0,0.00");
                                if (w) {
                                    Ext.get("wallet-promotional").dom.innerHTML = Ext.util.Format.number(w, "0,0.00")
                                } else {
                                    Ext.get("wallet-promotional-wrapper").setVisibilityMode(Ext.Element.DISPLAY);
                                    Ext.get("wallet-promotional-wrapper").hide()
                                }
                                Ext.get("wallet-pending-bonus").dom.innerHTML = Ext.util.Format.number(B, "0,0.00");
                                var u = Trading.app.getController("User");
                                u.wallet.credit = y;
                                u.wallet.reserved = x;
                                u.wallet.bonus.amount = B;
                                u.wallet.bonus.promotional = w;
                                u.wallet.bonus.traded = C;
                                u.wallet.bonus.required = D;
                                Registry.wallet = u.wallet;
                                Ext.fly("wallet-loader").removeCls("loading")
                            }
                        })
                    });
                    r.delay(10000)
                }
                new Ext.util.DelayedTask(function(v) {
                    Trading.app.getController("Game").updateTradeMarker(v.trade.data.instrumentID, v.trade);
                    var u = Ext.fly("trade-entry-status-indicator-" + v.tradeID);
                    if (u) {
                        u.removeCls("open");
                        u.addCls(v.status)
                    }
                },
                null, [{
                    trade: c,
                    tradeID: m,
                    status: n
                }]).delay(500)
            }
        }
        var b = parseFloat(e.credit);
        var k = parseFloat(e.reserved);
        Ext.fly("wallet-credit").dom.innerHTML = Ext.util.Format.number(b, "0,0.00");
        Ext.fly("wallet-reserved").dom.innerHTML = Ext.util.Format.number(k, "0,0.00");
        Ext.fly("wallet-balance").dom.innerHTML = Ext.util.Format.number(b + k, "0,0.00");
        if (g) {
            Ext.fly("wallet-loader").removeCls("loading")
        }
    },
    closeTrades: function(h) {
        var c = Trading.app.getController("User");
        var m = c.trades;
        var e = c.wallet;
        var n;
        var a;
        var o;
        var b;
        var j;
        var g = true;
        var f;
        Ext.fly("wallet-loader").addCls("loading");
        for (n in h) {
            a = m.getById(n * 1);
            if (a == null) {
                continue
            }
            f = h[n];
            Trading.app.getController("Game").updatePoint(a.data.instrumentID * 1, a.data.expiry * 1, f.expiryPrice * 1);
            if (!a.data.closed) {
                a.data.expired = true;
                a.data.closed = true;
                a.data.expiryPrice = f.expiryPrice * 1;
                o = f.result;
                b = f.returnedAmount * 1;
                Ext.fly("trade-entry-expiry-" + n).dom.innerHTML = "Price: " + f.expiryPrice;
                if (Ext.fly("fp-trade-entry-expiry-" + n)) {
                    Ext.fly("fp-trade-entry-expiry-" + n).dom.innerHTML = f.expiryPrice
                }
                j = "at";
                switch (o) {
                case 1:
                    j = "in";
                    break;
                case - 1 : j = "out";
                    break
                }
                e.reserved -= a.data.stake * 1;
                e.credit += b * 1;
                var k;
                if (a.data.userCurrency == Registry.baseCurrencyID) {
                    k = Registry._["label-return-amount"] + ": " + Registry.baseCurrencySymbol + Ext.util.Format.number(b, "0,0.00")
                } else {
                    var l;
                    switch (o) {
                    case 1:
                        l = Ext.util.Format.number(a.data.userCurrencyStake * (100 + a.data.payout) / 100, "0,0.00");
                        break;
                    case - 1 : l = Ext.util.Format.number(a.data.userCurrencyStake * a.data.rebate / 100, "0,0.00");
                        break;
                    default:
                        l = Ext.util.Format.number(a.data.userCurrencyStake, "0,0.00");
                        break
                    }
                    k = Registry._["label-return-amount"] + ": " + Registry.currenciesInfo[a.data.userCurrency].currencySymbol + l
                }
                Ext.fly("trade-entry-indicator-" + n).dom.innerHTML = k;
                if (Ext.fly("fp-trade-entry-indicator-" + n)) {
                    Ext.fly("fp-trade-entry-indicator-" + n).dom.innerHTML = k
                }
                Ext.fly("trade-" + n + "-close-position").hide();
                Ext.fly("trade-" + n + "-double-up").hide();
                Ext.fly("trade-" + n + "-hedge").hide();
                Ext.fly("evaluation-message-" + n).hide();
                var c = Trading.app.getController("User");
                if (a.data.bonus) {
                    g = false;
                    var d = new Ext.util.DelayedTask(function() {
                        c.updateWallet()
                    });
                    d.delay(10000)
                }
                new Ext.util.DelayedTask(function(q) {
                    Trading.app.getController("Game").updateTradeMarker(q.trade.data.instrumentID, q.trade);
                    var p = Ext.fly("trade-entry-status-indicator-" + q.tradeID);
                    if (p) {
                        p.removeCls("open");
                        p.addCls(q.status)
                    }
                },
                null, [{
                    trade: a,
                    tradeID: n,
                    status: j
                }]).delay(500)
            }
        }
        c.updateWallet();
        if (g) {
            Ext.fly("wallet-loader").removeCls("loading")
        } else {
            setTimeout(function() {
                Ext.fly("wallet-loader").removeCls("loading")
            },
            10000)
        }
    }
});
Ext.define("Trading.model.Trade", {
    extend: "Ext.data.Model",
    fields: ["tradeID", "type", "instrumentID", "timestamp", "expiry", "stake", "userCurrency", "userCurrencyStake", "strike", "direction", "payout", "rebate", "status", "expired", "expiryPrice", "distance"],
    idProperty: "tradeID"
});
Ext.define("Trading.view.SellbackHelpWindow", {
    extend: "Ext.window.Window",
    alias: "widget.sellbackhelpview",
    width: 640,
    height: 401,
    initComponent: function() {
        this.title = Registry._["sellback-help-window-title"];
        this.html = '<div id="sell-back-description-lightbox-container"><div id="sell-back-description-lightbox"><h2 class="first">' + Registry._["sellback-help-window-how-it-works"] + '</h2><div id="images-how-to"><div class="box-desc">' + Registry._["sellback-help-window-step-one"] + '</div><div class="box-desc">' + Registry._["sellback-help-window-step-two"] + '</div><div class="box-desc">' + Registry._["sellback-help-window-step-three"] + "</div></div><h2>" + Registry._["sellback-help-window-feature-overview-title"] + '</h2><p class="text-decs">' + Registry._["sellback-help-window-feature-overview"] + '</p><p class="notice-desc">* ' + Registry._["sellback-help-window-note-two"] + "</p></div></div>";
        this.callParent(arguments)
    }
});
Ext.define("Trading.view.HedgeHelpWindow", {
    extend: "Ext.window.Window",
    alias: "widget.hedgehelpview",
    width: 560,
    height: 460,
    initComponent: function() {
        this.title = Registry._["hedge-help-window-title"];
        this.html = '<div id="hedge-description-lightbox-container"><div id="hedge-description-lightbox"><h2 class="first">' + Registry._["hedge-help-window-how-it-works"] + '</h2><div id="image-how-to"></div><div id="hedge-one-click-trade-text">' + Registry._["hedge-help-window-one-click-trade"] + "</div><h2>" + Registry._["hedge-help-window-feature-overview-title"] + '</h2><p class="text-decs">' + Registry._["hedge-help-window-feature-overview"] + "</p></div></div>";
        this.callParent(arguments)
    }
});
Ext.define("Trading.view.WeekendOptionHelpWindow", {
    extend: "Ext.window.Window",
    alias: "widget.weekendoptionhelpwindow",
    width: 440,
    height: 220,
    initComponent: function() {
        var d = new Date(Registry.weekendOptionExpiryTimestamp);
        var a = Registry._["day-" + (d.getDay() + 1)];
        var b = Ext.Date.format(d, "H:i");
        var c = Registry._["weekend-option-help-window-feature-overview"].replace("[[[day-of-week]]]", a);
        c = c.replace("[[[time]]]", b);
        this.title = Registry._["weekend-option-help-window-title"];
        this.html = '<div id="weekend-option-description-lightbox-container"><div id="weekend-option-description-lightbox"><h2>' + Registry._["weekend-option-help-window-feature-overview-title"] + '</h2><p class="text-decs">' + c + "</p></div></div>";
        this.callParent(arguments)
    }
});
Ext.define("Ext.data.BelongsToAssociation", {
    extend: "Ext.data.Association",
    alias: "association.belongsto",
    constructor: function(c) {
        this.callParent(arguments);
        var e = this,
        a = e.ownerModel.prototype,
        f = e.associatedName,
        d = e.getterName || "get" + f,
        b = e.setterName || "set" + f;
        Ext.applyIf(e, {
            name: f,
            foreignKey: f.toLowerCase() + "_id",
            instanceName: f + "BelongsToInstance",
            associationKey: f.toLowerCase()
        });
        a[d] = e.createGetter();
        a[b] = e.createSetter()
    },
    createSetter: function() {
        var c = this,
        d = c.ownerModel,
        e = c.associatedModel,
        b = c.foreignKey,
        a = c.primaryKey;
        return function(h, f, g) {
            this.set(b, h);
            if (typeof f == "function") {
                f = {
                    callback: f,
                    scope: g || this
                }
            }
            if (Ext.isObject(f)) {
                return this.save(f)
            }
        }
    },
    createGetter: function() {
        var d = this,
        f = d.ownerModel,
        e = d.associatedName,
        g = d.associatedModel,
        c = d.foreignKey,
        b = d.primaryKey,
        a = d.instanceName;
        return function(l, m) {
            l = l || {};
            var k = this,
            n = k.get(c),
            h,
            j;
            if (k[a] === undefined) {
                h = Ext.ModelManager.create({},
                e);
                h.set(b, n);
                if (typeof l == "function") {
                    l = {
                        callback: l,
                        scope: m || k
                    }
                }
                g.load(n, l);
                k[a] = g;
                return g
            } else {
                h = k[a];
                j = [h];
                m = m || k;
                Ext.callback(l, m, j);
                Ext.callback(l.success, m, j);
                Ext.callback(l.failure, m, j);
                Ext.callback(l.callback, m, j);
                return h
            }
        }
    },
    read: function(b, a, c) {
        b[this.instanceName] = a.read([c]).records[0]
    }
});
Ext.define("Trading.view.RiskOMeterHelpWindow", {
    extend: "Ext.window.Window",
    alias: "widget.riskometerhelpwindow",
    width: 440,
    height: 220,
    initComponent: function() {
        this.title = Registry._["risk-o-meter-help-window-title"];
        this.html = '<div id="risk-o-meter-description-lightbox-container"><div id="risk-o-meter-description-lightbox"><h2>' + Registry._["risk-o-meter-help-window-feature-overview-title"] + '</h2><p class="text-decs">' + Registry._["risk-o-meter-help-window-feature-overview"] + "</p></div></div>";
        this.callParent(arguments)
    }
});
Ext.define("Trading.view.DoubleUpHelpWindow", {
    extend: "Ext.window.Window",
    alias: "widget.doubleuphelpview",
    width: 560,
    height: 440,
    initComponent: function() {
        this.title = Registry._["double-up-help-window-title"];
        this.html = '<div id="double-up-description-lightbox-container"><div id="double-up-description-lightbox"><h2 class="first">' + Registry._["double-up-help-window-how-it-works"] + '</h2><div id="image-how-to"></div><div id="double-up-one-click-trade-text">' + Registry._["double-up-help-window-one-click-trade"] + "</div><h2>" + Registry._["double-up-help-window-feature-overview-title"] + '</h2><p class="text-decs">' + Registry._["double-up-help-window-feature-overview"] + "</p></div></div>";
        this.callParent(arguments)
    }
});
Ext.define("Ext.data.proxy.Rest", {
    extend: "Ext.data.proxy.Ajax",
    alternateClassName: "Ext.data.RestProxy",
    alias: "proxy.rest",
    appendId: true,
    batchActions: false,
    buildUrl: function(f) {
        var e = this,
        c = f.operation,
        b = c.records || [],
        a = b[0],
        g = e.format,
        d = e.getUrl(f),
        h = a ? a.getId() : c.id;
        if (e.appendId && h) {
            if (!d.match(/\/$/)) {
                d += "/"
            }
            d += h
        }
        if (g) {
            if (!d.match(/\.$/)) {
                d += "."
            }
            d += g
        }
        f.url = d;
        return e.callParent(arguments)
    }
},
function() {
    Ext.apply(this.prototype, {
        actionMethods: {
            create: "POST",
            read: "GET",
            update: "PUT",
            destroy: "DELETE"
        }
    })
});
Ext.define("Trading.view.AdvancedChart", {
    extend: "Ext.window.Window",
    alias: "widget.advancedchart",
    instrumentID: 0,
    time: 0,
    width: 600,
    height: 360,
    resizable: false,
    tplContent: null,
    lineChart: null,
    currentMinute: 0,
    lastQuotes: [],
    lastTradeID: 0,
    tplSocialTrade: null,
    initComponent: function() {
        this.style = {
            opacity: 0.93
        };
        this.bodyStyle = {
            "background-color": Registry.chartConfig.colors.background
        };
        this.currentMinute = Math.floor(this.time / 60000) * 60000;
        this.initTemplates();
        this.html = this.tplContent.apply({
            instrumentID: this.instrumentID
        });
        this.callParent(arguments);
        this.renderCharts()
    },
    initTemplates: function() {
        var a = this;
        this.tplContent = new Ext.XTemplate('<div id="advanced-chart-wrapper-{instrumentID}" class="advanced-chart-wrapper">', '<div class="advanced-chart-options-wrapper">', '<input class=\'{[this.isSocialInstrument(values.instrumentID) ? "" : "x-hidden" ]}\' type="radio" id="advanced-chart-radio-social-{instrumentID}" name="advanced-chart-radio-{instrumentID}" onclick="Ext.getCmp(\'advanced-chart-window-{instrumentID}\').selectChart(\'social\')"><label class=\'{[this.isSocialInstrument(values.instrumentID) ? "" : "x-hidden" ]}\' for="advanced-chart-radio-social-{instrumentID}" id="advanced-chart-label-social-{instrumentID}">' + Registry._["advanced-chart-social"] + "</label>", '<input type="radio" id="advanced-chart-radio-line-{instrumentID}" name="advanced-chart-radio-{instrumentID}" onclick="Ext.getCmp(\'advanced-chart-window-{instrumentID}\').selectChart(\'line\')"><label for="advanced-chart-radio-line-{instrumentID}" id="advanced-chart-label-line-{instrumentID}">' + Registry._["advanced-chart-line"] + "</label>", '<input type="radio" id="advanced-chart-radio-candlestick-{instrumentID}" name="advanced-chart-radio-{instrumentID}" checked=\'checked\' onclick="Ext.getCmp(\'advanced-chart-window-{instrumentID}\').selectChart(\'candlestick\')"><label for="advanced-chart-radio-candlestick-{instrumentID}" id="advanced-chart-label-candlestick-{instrumentID}">' + Registry._["advanced-chart-candlestick"] + "</label>", "</div>", '<div id="advanced-chart-line-{instrumentID}" class="advanced-chart x-hidden"></div>', '<div id="advanced-chart-candlestick-{instrumentID}" class="advanced-chart"></div>', '<div id="advanced-chart-social-trades-container-{instrumentID}" class="x-hidden advanced-chart-social-trades-container" onmouseout="Ext.getCmp(\'advanced-chart-window-{instrumentID}\').contractSocialEntry()">', "<span class=\"advanced-legend-info\" onclick=\"Ext.fly('advanced-chart-social-legend-{instrumentID}').removeCls('x-hidden')\">&nbsp;</span>", '<div id="advanced-chart-social-legend-{instrumentID}" class="advanced-chart-social-legend x-hidden">', "<span class=\"advanced-chart-social-legend-x-icon\" onclick=\"Ext.fly('advanced-chart-social-legend-{instrumentID}').addCls('x-hidden')\">&nbsp;</span>", "<ul>", '<span class="border-label">Social Positions</span>', "<li>", '<span class="advanced-chart-social-legend-icon">', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.open.social]}" width="17" height="21" title="Open" alt="Open"/>', "</span>", '<span class="advanced-chart-social-legend-label">{[Registry._["markers-legend-label-open-social"]]}</span>', "</li>", "<li>", '<span class="advanced-chart-social-legend-icon">', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.close.social]}" width="17" height="21" title="Close" alt="Close"/>', "</span>", '<span class="advanced-chart-social-legend-label">{[Registry._["markers-legend-label-close-social"]]}</span>', "</li>", "</ul>", "<ul>", '<span class="border-label">My Positions</span>', "<li>", '<span class="advanced-chart-social-legend-icon">', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.open.call]}" title="Call" alt="Call"/>&nbsp;', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.open.put]}" title="Put" alt="Put"/>', "</span>", '<span class="advanced-chart-social-legend-label">{[Registry._["markers-legend-label-open-position"]]}</span>', "</li>", "<li>", '<span class="advanced-chart-social-legend-icon">', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.inTheMoney.call]}" title="Call" alt="Call"/>&nbsp;', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.inTheMoney.put]}" title="Put" alt="Put"/>', "</span>", '<span class="advanced-chart-social-legend-label">{[Registry._["markers-legend-label-in-the-money-position"]]}</span>', "</li>", "<li>", '<span class="advanced-chart-social-legend-icon">', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.out.call]}" title="Call" alt="Call"/>&nbsp;', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.out.put]}" title="Put" alt="Put"/>', "</span>", '<span class="advanced-chart-social-legend-label">{[Registry._["markers-legend-label-out-of-the-money-position"]]}</span>', "</li>", "<li>", '<span class="advanced-chart-social-legend-icon">', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.at.call]}" title="Call" alt="Call"/>&nbsp;', '<img src="{[Registry.chartConfig.advanced.markers.trades.symbols.at.put]}" title="Put" alt="Put"/>', "</span>", '<span class="advanced-chart-social-legend-label">{[Registry._["markers-legend-label-at-the-money-position"]]}</span>', "</li>", "</ul>", "</div>", '<div class="advanced-chart-social-enable-container {[Registry["socialUser"] ? "x-hidden" : ""]}">', '<div class="advanced-chart-social-enable-mask"></div>', '<div class="advanced-chart-social-enable-msg">', '<a href="' + Registry.socialUrl + '" onclick="return Trading.app.getController(\'User\').forceLogin();">' + Registry._["social-settings-enable-social"] + "</a> " + Registry._["social-enable-social-trades"], "</div>", "</div>", '<div id="advanced-chart-social-trades-panel-{instrumentID}" class="advanced-chart-social-trades-panel empty">', '<span class="advanced-chart-social-trades-empty-label">' + Registry._["social-no-open-trades"] + "</span>", "</div>", "</div>", "</div>", {
            isSocialInstrument: function(b) {
                if (Registry.socialSite && (Registry.socialInstruments.indexOf(b) != -1)) {
                    return true
                }
                return false
            }
        });
        this.tplSocialTrade = new Ext.XTemplate('<div id="advanced-social-trade-{tradeID}" class="advanced-social-trade-entry cf" style="position: relative; display: {[values.isNew ? "none" : "block"]};" onmouseover="Ext.getCmp(\'advanced-chart-window-{instrumentID}\').hoverSocialEntry({tradeID})" onclick="Ext.getCmp(\'advanced-chart-window-{instrumentID}\').selectSocialEntry({tradeID})">', '<div id="trade-entry-status-indicator-{tradeID}" class="trade-entry-status-indicator cf {[this.setIndicatorColor(values)]}">', "<span>&nbsp;</span>", "</div>", '<div class="social-user-img-container"><img id="advanced-social-trade-img-{tradeID}" class="social-user-img" src="{userID:this.setPublicImage}" />', '<img class="social-user-arrow-img" src=\'{[(values.direction == 1) ? "images/small-green-arrow-up-10x11.png" : "images/small-red-arrow-down-10x11.png"]}\' />', "</div>", '<div class="advanced-social-trade-info">', '<span class="advanced-social-trade-info-item">{[this.setInfo(values)]}</span>', "</div>", "</div>", {
            formatDirection: function(b) {
                return (b * 1 == 1) ? "Call": "Put"
            },
            formatStrike: function(b) {
                return b * 1
            },
            formatTime: function(f) {
                var e = new Date();
                var d = new Date(f);
                var g = 60 * 1000;
                var j = g * 60;
                var h = j * 24;
                var c = h * 30;
                var b = h * 365;
                var l = e - d;
                var k;
                if (l < g) {
                    k = Math.round(l / 1000);
                    return (k > 1) ? k + " " + Registry._["short-text-time-seconds-ago"] : k + " " + Registry._["short-text-time-second-ago"]
                } else {
                    if (l < j) {
                        k = Math.round(l / g);
                        return (k > 1) ? k + " " + Registry._["short-text-time-minutes-ago"] : k + " " + Registry._["short-text-time-minute-ago"]
                    } else {
                        if (l < h) {
                            k = Math.round(l / j);
                            return (k > 1) ? k + " " + Registry._["short-text-time-hours-ago"] : k + " " + Registry._["short-text-time-hour-ago"]
                        } else {
                            if (l < c) {
                                return "approximately " + Math.round(l / h) + " " + Registry._["short-text-time-days-ago"]
                            } else {
                                if (l < b) {
                                    return Registry._["short-text-time-approximately"] + " " + Math.round(l / c) + " " + Registry._["short-text-time-months-ago"]
                                } else {
                                    return Registry._["short-text-time-approximately"] + " " + Math.round(l / b) + " " + Registry._["short-text-time-years-ago"]
                                }
                            }
                        }
                    }
                }
            },
            formatInstrument: function(b) {
                return a.title
            },
            setPublicImage: function(b) {
                return Registry.socialImageUrlPattern.replace("[[[userID]]]", b) + "?v=" + Math.floor(new Date().getTime() / 10000)
            },
            getTradeStatus: function(c) {
                var d = {
                    data: c
                };
                var b = Trading.app.getController("Game").getTradeStatus(d, true);
                return b
            },
            setIndicatorColor: function(c) {
                Ext.fly("advanced-chart-social-trades-panel-" + c.instrumentID).removeCls("empty");
                var b = this.getTradeStatus(c);
                return " " + b.status
            },
            setInfo: function(c) {
                var e = this.formatDirection(c.direction);
                var b = this.getTradeStatus(c);
                var d = Registry._["activity-event-open-position"].replace("[[[nickname]]]", "<b>" + c.nickname.trim() + "</b>").replace("[[[option-name]]]", "<b>" + this.formatInstrument(c.instrumentID) + "</b>").replace("[[[option-type]]]", '<span class="' + e.toLowerCase() + '"> ' + Registry._["short-text-binary"] + " " + e + "</span>").replace("[[[expiry]]]", '<span class="' + e.toLowerCase() + '">' + this.formatStrike(c.strike) + "</span>") + '<br /><span id="social-trade-gain-' + c.tradeID + '" class="trade-gain">' + ((b.closed) ? Registry._["short-text-gain"] + ": " + Registry.baseCurrencySymbol + b.payoff + " · ": "") + '</span><span id="social-trade-time-' + c.tradeID + '" class="trade-time">' + this.formatTime(c.timestamp) + '</span> · <a id="like-trade-' + c.tradeID + '" class="loadable like" href="#" onClick="Ext.getCmp(\'advanced-chart-window-' + c.instrumentID + "').like('" + c.tradeID + "','" + c.userID + "'); return false;\">" + Registry._["short-text-like"] + "</a>";
                return d
            }
        })
    },
    like: function(d, a) {
        var b = Ext.fly("like-trade-" + d);
        var c = (b.hasCls("like")) ? "like": "unlike";
        if ((b.hasCls("like"))) {
            b.addCls("loading");
            Ext.Ajax.request({
                url: Registry.uriBase + "/ajax/user/like",
                params: {
                    userID: a,
                    like: c,
                    tradeID: d
                },
                success: function(e) {
                    e = Ext.decode(e.responseText);
                    var f = Ext.fly("like-trade-" + d);
                    f.removeCls("like");
                    f.addCls("liked");
                    f.update("&nbsp;");
                    f.removeCls("loading");
                    e = null
                }
            })
        }
    },
    selectChart: function(a) {
        Ext.fly("advanced-chart-line-" + this.instrumentID).addCls("x-hidden");
        Ext.fly("advanced-chart-candlestick-" + this.instrumentID).addCls("x-hidden");
        if (a == "social") {
            a = "line";
            this.setWidth(860);
            Trading.app.getController("Game").toggleTradesMarkers(true, true, true);
            Ext.fly("advanced-chart-social-trades-container-" + this.instrumentID).removeCls("x-hidden")
        } else {
            this.setWidth(600);
            Trading.app.getController("Game").toggleTradesMarkers(true, true, false);
            Ext.fly("advanced-chart-social-trades-container-" + this.instrumentID).addCls("x-hidden")
        }
        Ext.fly("advanced-chart-" + a + "-" + this.instrumentID).removeCls("x-hidden")
    },
    renderCharts: function() {
        var a = this.instrumentID;
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/instrument/history",
            method: "GET",
            params: {
                instruments: Ext.encode([this.instrumentID])
            },
            success: function(b) {
                b = Ext.decode(b.responseText);
                var c = b[a];
                b = null;
                Ext.Ajax.request({
                    url: Registry.uriBase + "/ajax/instrument/history",
                    method: "GET",
                    params: {
                        instruments: Ext.encode([a]),
                        candlesticks: 1,
                        period: 1
                    },
                    success: function(e) {
                        e = Ext.decode(e.responseText);
                        var d = Ext.getCmp("advanced-chart-window-" + a);
                        d.drawCharts(c, e[a]);
                        d.selectChart("candlestick");
                        e = null
                    }
                })
            }
        })
    },
    drawCharts: function(d, b) {
        var c = this.instrumentID;
        var f = this.currentMinute;
        var g = new Date();
        var e = [];
        for (i = 0; (d) && (i < d.length); i++) {
            if (! (i % 5) || !(d[i][0] % 60000)) {
                e.push(d[i])
            }
        }
        var a = new Highcharts.StockChart({
            xAxis: {
                gridLineWidth: 1,
                gridLineColor: Registry.chartConfig.colors.axisgrid,
                lineColor: Registry.chartConfig.colors.axis,
                tickLength: 0,
                ordinal: false,
                labels: {
                    formatter: function() {
                        g.setTime(this.value);
                        var j = "H:i";
                        var h = this.axis.series[0].data;
                        if (h.length && (h[h.length - 1].x - h[0].x < (5 * 60000))) {
                            j = "H:i:s"
                        }
                        return Ext.Date.format(g, j)
                    }
                }
            },
            yAxis: {
                id: "advanced-chart-line-y-axis-" + c,
                gridLineColor: Registry.chartConfig.colors.axisgrid
            },
            chart: {
                renderTo: "advanced-chart-line-" + c,
                plotBorderWidth: 1,
                backgroundColor: "rgba(255,255,255,0)"
            },
            rangeSelector: {
                enabled: false
            },
            navigator: {
                enabled: false
            },
            scrollbar: {
                enabled: false
            },
            credits: {
                enabled: false
            },
            series: [{
                id: "advanced-chart-line-series-" + c,
                name: "Price",
                data: e
            }],
            plotOptions: {
                line: {
                    lineWidth: 1,
                    color: Registry.chartConfig.advanced.colors.line,
                    dataGrouping: {
                        enabled: false
                    },
                    marker: {
                        states: {
                            hover: {
                                lineColor: Registry.chartConfig.colors.guide,
                                radius: 2
                            }
                        }
                    },
                    events: {
                        click: function(h) {
                            Trading.app.getController("Game").selectClosestTradePoint(h.point)
                        }
                    },
                    allowPointSelect: false
                },
                series: {
                    states: {
                        hover: {
                            lineWidth: 1
                        }
                    }
                }
            },
            tooltip: {
                headerFormat: "<span>{point.key}</span><br/>",
                xDateFormat: "%H:%M:%S",
                pointFormat: "<span>{point.y}</span>",
                borderWidth: 1,
                crosshairs: [{
                    color: Registry.chartConfig.colors.guide,
                    dashStyle: "longdash"
                }],
                formatter: function() {
                    var o = this.points[0].point;
                    var n = "<span>" + Ext.Date.format(new Date(o.x), "H:i:s") + "</span><br/><span>" + o.y + "</span>";
                    if (o.marker && o.marker.keep) {
                        var m = (o.tooltipData.direction == 1) ? Registry._["label-above"] : Registry._["label-below"];
                        n = '<span class="tooltip-label">' + Registry._["game-label-expiry"] + ":</span><span> " + Ext.Date.format(new Date(o.tooltipData.expiry), "H:i:s") + '</span><br/><span class="tooltip-label">' + m + " " + o.y + '</span><br/><span class="tooltip-label">' + Registry._["trade-info-investment"] + ":</span><span> " + Registry.baseCurrencySymbol + o.tooltipData.stake + '</span><br/><span class="tooltip-label">' + Registry._["trade-info-payout"] + ":</span><span> " + o.tooltipData.payout + '%</span><br/><span class="tooltip-label">' + Registry._["label-rebate"] + ":</span><span> " + o.tooltipData.rebate + "%</span>";
                        n += Ext.isEmpty(o.tooltipData.returnedAmount) ? "": '<br/><span class="tooltip-label">' + Registry._["label-return-amount"] + ":</span><span> " + Registry.baseCurrencySymbol + o.tooltipData.returnedAmount + "</span>";
                        if (o.tooltipData.social) {
                            var q = o.tooltipData.social.userID;
                            var h = Registry.socialImageUrlPattern.replace("[[[userID]]]", q) + "?v=" + Math.floor(new Date().getTime() / 10000);
                            var k = o.tooltipData.social.nickname;
                            var l = (o.tooltipData.direction == 1) ? "images/small-green-arrow-up-10x11.png": "images/small-red-arrow-down-10x11.png";
                            var m = (o.tooltipData.direction == 1) ? Registry._["short-text-call"] : Registry._["short-text-put"];
                            var j = Ext.isEmpty(o.tooltipData.returnedAmount) ? Registry._["short-text-opened"] : Registry._["short-text-closed"];
                            var p = Ext.isEmpty(o.tooltipData.returnedAmount) ? "": '<br/><span class="tooltip-gain">' + Registry._["short-text-gain"] + ": " + Registry.baseCurrencySymbol + o.tooltipData.returnedAmount + "</span>";
                            n = '<div id="tooltip-social-container"><div class="social-user-img-container"><img class="social-user-img" src="' + h + '" /><img class="social-user-arrow-img" src="' + l + '">&nbsp;</img></div><div class="advanced-social-trade-info"><span class="tooltip-nickname">' + k + ((Registry.env == "development") ? " (" + o.tooltipData.tradeID + ") ": "") + '</span><br/><span class="tooltip-status">' + j + " " + Registry._["short-text-a-binary"] + " " + m + " option</span>" + p + "</div></div>"
                        }
                    }
                    return '<div class="tooltip-container">' + n + "</div>"
                },
                useHTML: true
            }
        });
        this.lineChart = a;
        this.candlestickChart = Trading.app.getController("Game").drawCandlestickChart(c, "advanced-chart-candlestick-", b, e);
        this.markTrades(c, Trading.app.getController("User").trades.data.items);
        this.markSocialTrades(c)
    },
    markSocialTrades: function(c) {
        var a = this;
        var g = Trading.app.getController("Game").charts[c].socialTrades;
        var e;
        var h;
        var b = 0;
        var f;
        var d;
        for (e in g) {
            h = g[e];
            f = h.data.timestamp;
            b += (d) ? (f - d) / 600 : 0;
            new Ext.util.DelayedTask(function(j) {
                a.addSocialEntry(j.trade)
            },
            null, [{
                trade: h
            }]).delay(b);
            d = f
        }
    },
    addSocialEntry: function(e) {
        var d = e.data;
        var c = d.tradeID;
        var a = this.instrumentID;
        if (this.tradesMarkers && !Ext.isEmpty(this.tradesMarkers[c])) {
            return
        }
        d.isNew = true;
        this.tplSocialTrade.insertFirst("advanced-chart-social-trades-panel-" + a, d);
        Ext.fly("advanced-chart-social-trades-panel-" + a).scrollTo("top", 0, false);
        var b = Ext.get("advanced-social-trade-" + c);
        b.setOpacity(0.25, false);
        b.slideIn("t", {
            duration: 200,
            useDisplay: true,
            easing: "ease",
            callback: function() {
                b.fadeIn({
                    opacity: 1,
                    duration: 1000,
                    callback: function() {
                        b.setHeight("auto");
                        b.setWidth("auto")
                    }
                })
            }
        });
        this.markTrades(a, [e])
    },
    contractSocialEntry: function() {
        if (this.tradesMarkers) {
            var a = true;
            Ext.each(Ext.query(".advanced-social-trade-entry"),
            function(c) {
                Ext.fly(c.id).removeCls("active");
                if (Ext.fly(c.id).hasCls("selected")) {
                    a = false
                }
            });
            if (a) {
                for (var b in this.tradesMarkers) {
                    break
                }
                this.selectTradeMarker(b, false)
            }
        }
    },
    hoverSocialEntry: function(g) {
        var b = this;
        var f = Ext.fly("advanced-social-trade-" + g);
        var c = f.hasCls("active");
        var e = f.hasCls("disabled");
        var d = f.hasCls("selected");
        if (e) {
            return
        }
        if (!c) {
            var a = true;
            Ext.each(Ext.query(".advanced-social-trade-entry"),
            function(h) {
                Ext.fly(h.id).removeCls("active");
                if (Ext.fly(h.id).hasCls("selected")) {
                    a = (false || d)
                }
            });
            Ext.fly("advanced-social-trade-" + g).addCls("active");
            if (a) {
                b.selectTradeMarker(g, true)
            }
        }
    },
    selectSocialEntry: function(e) {
        var a = this;
        var d = Ext.fly("advanced-social-trade-" + e);
        var c = d.hasCls("selected");
        var b = d.hasCls("disabled");
        if (b) {
            return
        }
        if (c) {
            d.removeCls("selected")
        } else {
            Ext.each(Ext.query(".advanced-social-trade-entry.selected"),
            function(f) {
                Ext.fly(f.id).removeCls("selected")
            });
            Ext.fly("advanced-social-trade-" + e).addCls("selected");
            a.selectTradeMarker(e, true)
        }
    },
    removeSocialEntry: function(b, a) {
        if (this.tradesMarkers[b.data.tradeID]) {
            this.tradesMarkers[b.data.tradeID].marker = {
                enabled: false
            }
        }
        if (a) {
            Ext.fly("advanced-social-trade-" + b.data.tradeID).addCls("disabled")
        } else {
            Ext.get("advanced-social-trade-" + b.data.tradeID).remove()
        }
    },
    updateSocialEntry: function(c) {
        var b = c.data.tradeID;
        var d = Trading.app.getController("Game");
        var a = d.getTradeStatus(c, true);
        if (a.closed) {
            Ext.fly("trade-entry-status-indicator-" + b).addCls(a.status);
            if (Ext.fly("social-trade-gain-" + b)) {
                Ext.fly("social-trade-gain-" + b).update(Registry._["short-text-gain"] + ": " + Registry.baseCurrencySymbol + a.payoff + " · ")
            }
        }
    },
    updateSocialEntryTimes: function() {
        var a = this;
        var d = Trading.app.getController("Game").charts[a.instrumentID].socialTrades;
        var b;
        var e;
        var c;
        for (b in d) {
            e = d[b];
            c = e.data.timestamp;
            if (Ext.fly("social-trade-time-" + b)) {
                Ext.fly("social-trade-time-" + b).update(a.tplSocialTrade.formatTime(c))
            }
        }
    },
    quote: function(j, m, h, n) {
        m = m * 1;
        var g = Trading.app.getController("Game");
        var f = this.instrumentID;
        if (this.lastQuotes[f] && (j - this.lastQuotes[f] < Registry.chartUpdateFrequency)) {
            return
        }
        this.lastQuotes[f] = j;
        var d = Registry.chartConfig.colors.line;
        var e;
        var l;
        var c = false;
        var a = this.lineChart;
        var k = this.candlestickChart;
        if (h == 1) {
            d = Registry.chartConfig.colors.up
        } else {
            if (h == -1) {
                d = Registry.chartConfig.colors.down
            }
        }
        e = a.get("advanced-chart-line-series-" + f);
        if (e.data.length) {
            l = e.data[e.data.length - 1];
            if (l.marker && !l.marker.keep) {
                l.marker = {
                    enabled: false
                };
                e.data[e.data.length - 1].update(l)
            }
            c = ((j - e.data[0].x) > 3600000)
        }
        l = {
            x: j,
            y: m,
            marker: {
                enabled: true,
                fillColor: d,
                lineColor: Registry.chartConfig.colors.guide,
                lineWidth: 1,
                keep: false
            }
        };
        if (n > this.lastTradeID) {
            var b = g.charts[f].tradesMarkers;
            l.x = b[n].x;
            l.y = b[n].y;
            l.marker = b[n].marker;
            l.tooltipData = b[n].tooltipData;
            l.events = {
                click: function() {
                    this.select(true);
                    return false
                },
                select: function() {
                    a.tooltip.refresh([this])
                },
                unselect: function() {
                    a.tooltip.hide()
                }
            }
        }
        e.addPoint(l, true, c);
        a.get("advanced-chart-line-y-axis-" + f).removePlotLine("advanced-chart-line-guide-" + f);
        a.get("advanced-chart-line-y-axis-" + f).addPlotLine({
            id: "advanced-chart-line-guide-" + f,
            value: m,
            color: Registry.chartConfig.colors.guide,
            width: 1,
            dashStyle: "longdash"
        });
        if (n > this.lastTradeID) {
            if (!this.tradesMarkers) {
                this.tradesMarkers = {}
            }
            this.tradesMarkers[n] = e.data[e.data.length - 1];
            Ext.each(Ext.query("#advanced-chart-line-" + f + " image"),
            function(o) {
                if (Ext.isEmpty(o.id)) {
                    var p = Ext.getDom("advanced-trade-marker-symbol-" + n);
                    if (!p) {
                        o.id = "advanced-trade-marker-symbol-" + n
                    }
                    return false
                }
            });
            g.fixTradesMarkersPosition(true);
            g.setTradesMarkersVisibility(g.showTradesMarkers.myTrades, false, true);
            g.setTradesMarkersVisibility((this.width == 860), true, true);
            this.lastTradeID = n
        }
        Trading.app.getController("Game").addPointToCandlestickChart(f, k, j, m)
    },
    markTrades: function(g, m) {
        var j = this;
        var h = Trading.app.getController("Game");
        var a = j.lineChart;
        var e = a.get("advanced-chart-line-series-" + g);
        var b = h.charts[g].tradesMarkers;
        var f;
        var l;
        var c;
        var k;
        var n;
        var d;
        if (b) {
            Ext.each(m,
            function(o) {
                n = o.data.tradeID;
                if (o.data.instrumentID == g) {
                    for (f = e.data.length - 1; f >= 0; f--) {
                        if ((o.data.timestamp > e.data[f].x) && (b[n])) {
                            d = h.getTradeStatus(o, true);
                            c = d.symbol;
                            k = b[n].marker;
                            l = {
                                x: e.data[f].x,
                                y: o.data.strike * 1,
                                marker: {
                                    symbol: "url(" + c + ")",
                                    keep: k.keep,
                                    states: k.states,
                                    enabled: k.enabled,
                                    fillColor: k.fillColor,
                                    lineColor: k.lineColor,
                                    lineWidth: k.lineWidth,
                                    radius: k.radius
                                },
                                tooltipData: b[n].tooltipData,
                                events: {
                                    click: function() {
                                        this.select(true);
                                        return false
                                    },
                                    select: function() {
                                        a.tooltip.refresh([this])
                                    },
                                    unselect: function() {
                                        a.tooltip.hide()
                                    }
                                }
                            };
                            e.data[f].update(l);
                            if (!j.tradesMarkers) {
                                j.tradesMarkers = {}
                            }
                            j.tradesMarkers[n] = e.data[f];
                            break
                        }
                    }
                    Ext.each(Ext.query("#advanced-chart-line-" + g + " image"),
                    function(p) {
                        if (Ext.isEmpty(p.id)) {
                            var q = Ext.getDom("advanced-trade-marker-symbol-" + n);
                            if (!q) {
                                p.id = "advanced-trade-marker-symbol-" + n
                            }
                        }
                    })
                }
            });
            h.fixTradesMarkersPosition(true);
            h.setTradesMarkersVisibility(h.showTradesMarkers.myTrades, false, true);
            h.setTradesMarkersVisibility((this.width == 860), true, true)
        }
    },
    selectTradeMarker: function(c, b) {
        if (this.tradesMarkers) {
            var a = this.tradesMarkers[c];
            if (a && a.marker) {
                a.select(b, true)
            }
        }
    },
    updateTradeMarker: function(c) {
        var d = Trading.app.getController("Game");
        var b = c.data.tradeID;
        var a = d.getTradeStatus(c, true);
        if (Ext.fly("advanced-trade-marker-symbol-" + b)) {
            Ext.fly("advanced-trade-marker-symbol-" + b).dom.setAttribute("href", a.symbol)
        }
    }
});
Ext.define("Ext.util.Inflector", {
    singleton: true,
    plurals: [[(/(quiz)$/i), "$1zes"], [(/^(ox)$/i), "$1en"], [(/([m|l])ouse$/i), "$1ice"], [(/(matr|vert|ind)ix|ex$/i), "$1ices"], [(/(x|ch|ss|sh)$/i), "$1es"], [(/([^aeiouy]|qu)y$/i), "$1ies"], [(/(hive)$/i), "$1s"], [(/(?:([^f])fe|([lr])f)$/i), "$1$2ves"], [(/sis$/i), "ses"], [(/([ti])um$/i), "$1a"], [(/(buffal|tomat|potat)o$/i), "$1oes"], [(/(bu)s$/i), "$1ses"], [(/(alias|status|sex)$/i), "$1es"], [(/(octop|vir)us$/i), "$1i"], [(/(ax|test)is$/i), "$1es"], [(/^person$/), "people"], [(/^man$/), "men"], [(/^(child)$/), "$1ren"], [(/s$/i), "s"], [(/$/), "s"]],
    singulars: [[(/(quiz)zes$/i), "$1"], [(/(matr)ices$/i), "$1ix"], [(/(vert|ind)ices$/i), "$1ex"], [(/^(ox)en/i), "$1"], [(/(alias|status)es$/i), "$1"], [(/(octop|vir)i$/i), "$1us"], [(/(cris|ax|test)es$/i), "$1is"], [(/(shoe)s$/i), "$1"], [(/(o)es$/i), "$1"], [(/(bus)es$/i), "$1"], [(/([m|l])ice$/i), "$1ouse"], [(/(x|ch|ss|sh)es$/i), "$1"], [(/(m)ovies$/i), "$1ovie"], [(/(s)eries$/i), "$1eries"], [(/([^aeiouy]|qu)ies$/i), "$1y"], [(/([lr])ves$/i), "$1f"], [(/(tive)s$/i), "$1"], [(/(hive)s$/i), "$1"], [(/([^f])ves$/i), "$1fe"], [(/(^analy)ses$/i), "$1sis"], [(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i), "$1$2sis"], [(/([ti])a$/i), "$1um"], [(/(n)ews$/i), "$1ews"], [(/people$/i), "person"], [(/s$/i), ""]],
    uncountable: ["sheep", "fish", "series", "species", "money", "rice", "information", "equipment", "grass", "mud", "offspring", "deer", "means"],
    singular: function(b, a) {
        this.singulars.unshift([b, a])
    },
    plural: function(b, a) {
        this.plurals.unshift([b, a])
    },
    clearSingulars: function() {
        this.singulars = []
    },
    clearPlurals: function() {
        this.plurals = []
    },
    isTransnumeral: function(a) {
        return Ext.Array.indexOf(this.uncountable, a) != -1
    },
    pluralize: function(f) {
        if (this.isTransnumeral(f)) {
            return f
        }
        var e = this.plurals,
        d = e.length,
        a, c, b;
        for (b = 0; b < d; b++) {
            a = e[b];
            c = a[0];
            if (c == f || (c.test && c.test(f))) {
                return f.replace(c, a[1])
            }
        }
        return f
    },
    singularize: function(f) {
        if (this.isTransnumeral(f)) {
            return f
        }
        var e = this.singulars,
        d = e.length,
        a, c, b;
        for (b = 0; b < d; b++) {
            a = e[b];
            c = a[0];
            if (c == f || (c.test && c.test(f))) {
                return f.replace(c, a[1])
            }
        }
        return f
    },
    classify: function(a) {
        return Ext.String.capitalize(this.singularize(a))
    },
    ordinalize: function(d) {
        var b = parseInt(d, 10),
        c = b % 10,
        a = b % 100;
        if (11 <= a && a <= 13) {
            return d + "th"
        } else {
            switch (c) {
            case 1:
                return d + "st";
            case 2:
                return d + "nd";
            case 3:
                return d + "rd";
            default:
                return d + "th"
            }
        }
    }
},
function() {
    var b = {
        alumnus: "alumni",
        cactus: "cacti",
        focus: "foci",
        nucleus: "nuclei",
        radius: "radii",
        stimulus: "stimuli",
        ellipsis: "ellipses",
        paralysis: "paralyses",
        oasis: "oases",
        appendix: "appendices",
        index: "indexes",
        beau: "beaux",
        bureau: "bureaux",
        tableau: "tableaux",
        woman: "women",
        child: "children",
        man: "men",
        corpus: "corpora",
        criterion: "criteria",
        curriculum: "curricula",
        genus: "genera",
        memorandum: "memoranda",
        phenomenon: "phenomena",
        foot: "feet",
        goose: "geese",
        tooth: "teeth",
        antenna: "antennae",
        formula: "formulae",
        nebula: "nebulae",
        vertebra: "vertebrae",
        vita: "vitae"
    },
    a;
    for (a in b) {
        this.plural(a, b[a]);
        this.singular(b[a], a)
    }
});
Ext.define("Trading.controller.User", {
    extend: "Ext.app.Controller",
    models: ["Trade"],
    wallet: null,
    trades: null,
    tplTrade: null,
    tplTrades: null,
    tplTradeOperation: null,
    tplBonus: null,
    tplBonuses: null,
    loggedIn: false,
    instruments: null,
    time: 0,
    isTradeEntryVisible: true,
    isBonusInfoVisible: false,
    pendingBonusExpiryDate: null,
    practiceMode: null,
    practiceExpired: null,
    views: ["SellbackHelpWindow", "DoubleUpHelpWindow", "HedgeHelpWindow", "WeekendOptionHelpWindow", "RiskOMeterHelpWindow"],
    init: function() {
        this.time = Registry.time;
        this.initTemplates();
        this.loggedIn = Registry.loggedIn;
        this.wallet = Registry.wallet;
        this.trades = Ext.create("Ext.data.Store", {
            model: "Trading.model.Trade",
            data: Registry.trades
        });
        if (Registry.showLogin == 1) {
            this.forceLogin()
        } else {
            if (Registry.showLogin == 2) {
                this.showFirstLogin()
            } else {
                if (Registry.isFirstTimeLead == 1) {
                    this.showGameBoxDemo(1)
                }
            }
        }
        var b = this;
        $(document).ready(function() {
            b.blinkTradeStatus(b)
        });
        var a = Registry.wallet;
        if (a.pendingBonusDetails && a.pendingBonusDetails.expiryDate) {
            if (!a.pendingBonusDetails.releasable) {
                this.pendingBonusExpiryDate = a.pendingBonusDetails.expiryDate
            } else {
                this.pendingBonusExpiryDate = -1
            }
        }
        if (Registry.userID) {
            this.updateBonusInfo(false)
        }
        $.widget("ui.tooltip", $.ui.tooltip, {
            options: {
                content: function() {
                    return $(this).attr("tooltip-content")
                }
            }
        });
        $(document).tooltip({
            position: {
                my: "left-10 top",
                at: "right top+18",
                collision: "flip"
            },
            items: "[tooltip-content]"
        });
        this.practiceMode = Registry.practiceMode;
        this.practiceExpirationDate = Registry.practiceWallet.expirationDate
    },
    updatePracticeExpiryStatus: function() {
        var b = $("#practice-wallet-exipry-status");
        if (!this.practiceMode || !this.practiceExpirationDate) {
            return
        }
        var a = Utils.gmtToLocal(this.practiceExpirationDate);
        if (a.getTime() < this.time) {
            User.practicePopUpMessage("expired");
            return
        }
        var c = Utils.calculateTimer(this.time, this.practiceExpirationDate);
        b.html('<span id="pending-bonus-status-title-text">' + Registry._["bonus-pending-active-time-remaining"] + ': </span><span id="pending-bonus-status-text"><span id="bonus-pending-icon"></span>' + c.daysRemaining + " " + Registry._["bonus-pending-active-days"] + " " + c.hoursRemaining + ":" + c.minutesRemaining + ":" + c.secondsRemaining + "</span>")
    },
    updatePendingBonusStatus: function() {
        var a = $("#wallet-pending-bonus-status");
        if (this.pendingBonusExpiryDate === null || this.pendingBonusExpiryDate === -2) {
            return
        }
        if (this.pendingBonusExpiryDate === -1) {
            a.html('<span id="bonus-pending-releasable-text" data-qclass="wallet-tooltip" data-qtip="' + Registry._["bonus-pending-releasable-tooltip"] + '">' + Registry._["bonus-pending-releasable"] + "</span>");
            this.pendingBonusExpiryDate = -2;
            return
        }
        var b = Utils.calculateTimer(this.time, this.pendingBonusExpiryDate);
        a.html('<span id="pending-bonus-status-title-text">' + Registry._["bonus-pending-active-time-remaining"] + ': </span><span id="pending-bonus-status-text" data-qclass="wallet-tooltip" data-qtip="' + Registry._["bonus-pending-active-tooltip"] + '"><span id="bonus-pending-icon"></span>' + b.daysRemaining + " " + Registry._["bonus-pending-active-days"] + " " + b.hoursRemaining + ":" + b.minutesRemaining + ":" + b.secondsRemaining + "</span>")
    },
    blinkTradeStatus: function(b) {
        var a;
        if (b.isTradeEntryVisible) {
            a = "visible";
            b.isTradeEntryVisible = false
        } else {
            a = "hidden";
            b.isTradeEntryVisible = true
        }
        $(".trade-entry-indicator").each(function() {
            if ($(this).has("span").length && !$(this).find("span").hasClass("loadable")) {
                $(this).css("visibility", a)
            } else {
                $(this).css("visibility", "visible")
            }
        });
        setTimeout(function() {
            b.blinkTradeStatus(b)
        },
        1000)
    },
    initTemplates: function() {
        var a = this;
        this.tplTrade = new Ext.XTemplate('<div id="trade-{tradeID}" class="trade-entry cf" data-quote="{strike}" style="position: relative; display: {[values.isNew ? "none" : "block"]};" onclick="Trading.app.getController(\'User\').expandTradeEntry({tradeID}, false);">', '<div id="trade-entry-status-indicator-{tradeID}" class="trade-entry-status-indicator cf {expired:this.setStatus}">', "<span>&nbsp;</span>", "</div>", '<div class="cf" style="position: relative;">', '<div class="trade-details-cell trade-details-cell-left">', '<div class="trade-entry-basic-trade-details option-type option-type-above-below direction-{[this.formatDirection(values.direction).toLowerCase()]}">{instrumentID:this.formatInstrument} - {[this.formatAmount(values.stake, values.userCurrency, values.userCurrencyStake)]}</div>', "<div>{[this.formatDirectionIcon(values.direction, values.type)]} {[this.formatStrike(values.strike, values.direction, values.type, values.distance, values.instrumentID)]}</div>", "</div>", '<div class="trade-details-cell trade-details-cell-right">', '<div id="trade-entry-expiry-{tradeID}" class="trade-entry-expiry cf">{expiry:this.formatExpiry}</div>', '<div id="trade-entry-indicator-{tradeID}" class="trade-entry-indicator">{expired:this.showLoader}</div>', "</div>", "</div>", '<div class="trade-entry-info cf" id="trade-entry-info-{tradeID}">', '<div class="trade-details-cell trade-details-cell-left">', '<table width="100%">', '<tr><td class="trade-label">' + Registry._["trade-info-trade-number"] + ' #:</td><td class="trade-attribute">{tradeID}</td></tr>', '<tr><td class="trade-label">' + Registry._["in-the-money"] + ':</td><td class="trade-attribute">{[this.formatReturnAmount(values.stake, values.payout+100, values.payout, values.userCurrency, values.userCurrencyStake)]}</td></tr>', '<tr><td class="trade-label">' + Registry._["out-the-money"] + ':</td><td class="trade-attribute">{[this.formatReturnAmount(values.stake, values.rebate, values.rebate, values.userCurrency, values.userCurrencyStake)]}</td></tr>', '<tr><td class="trade-label">' + Registry._["trade-info-created"] + ':</td><td class="trade-attribute" data-qtip="{timestamp:this.formatCreated}">{timestamp:this.formatExpiry}</td></tr>', '<tr id="trade-entry-info-expired-{tradeID}"  class="{[!values.expired ? "x-hidden" : ""]}"><td class="trade-label">' + Registry._["trade-info-expired"] + ':</td><td class="trade-attribute">{expiry:this.formatExpiry}</td></tr>', '<tr id="trade-entry-info-current-price-{tradeID}" class="{[values.expired ? "x-hidden" : ""]}"><td class="trade-label">' + Registry._["trade-info-current-price"] + ':</td><td class="trade-attribute spot-{instrumentID}"></td></tr>', '<tr id="trade-entry-info-closing-{tradeID}" class="x-hidden"><td class="trade-label">Closed:</td><td class="trade-attribute" id="trade-entry-info-closing-time-{tradeID}"></td></tr>', '<tr><td></td><td><span id="trade-entry-info-loading-{tradeID}" class="loadable x-hidden">&nbsp;</span></td></tr>', "</table>", "</div>", '<div class="trade-details-cell trade-details-cell-right">', '<div class="message-container evaluation-message" style="display: none;" id="evaluation-message-{tradeID}"></div>', '<div class="message-container evaluation-message" style="display: none;" id="evaluation-error-message-{tradeID}"></div>', '<div style="display: none;" id="evaluation-loader-{tradeID}"></div>', '<div class="trade-action-button trade-action-button-close-position" id="trade-{tradeID}-close-position">', '<div class="trade-action-button-container">', '<a href="#" id="trade-{tradeID}-close-position-button" title="' + Registry._["trade-action-sell-back-tip"] + "\" onclick=\"Trading.app.getController('User').getEvaluation({tradeID}, 'sellback'); return false;\">" + Registry._["trade-action-sell-back"] + "</a>", "</div>", '<div class="trade-action-help-link">', '<img src="../images/help-16x16.png" onclick="Trading.app.getController(\'User\').showSellbackHelp(); return false;" >', "</div>", "</div>", '<div class="trade-action-button trade-action-button-roll-over x-hidden"><a href="#" id="trade-{tradeID}-roll-over" onclick="return false;">' + Registry._["trade-action-roll-over"] + "</a></div>", '<div class="trade-action-button trade-action-button-double-up {[this.formatHidden(values.instrumentID, values.type)]}"  id="trade-{tradeID}-double-up">', '<div class="trade-action-button-container">', '<a href="#" id="trade-{tradeID}-double-up-button" onclick="Trading.app.getController(\'User\').doubleUp({tradeID}); return false;">' + Registry._["trade-action-double-up"] + "</a>", "</div>", '<div class="trade-action-help-link">', '<img src="../images/help-16x16.png" onclick="Trading.app.getController(\'User\').showDoubleUpHelp(); return false;" >', "</div>", "</div>", '<div class="trade-action-button trade-action-button-double-up {[this.formatHidden(values.instrumentID, values.type)]}"  id="trade-{tradeID}-hedge">', '<div class="trade-action-button-container">', '<a href="#" id="trade-{tradeID}-hedge-button" onclick="Trading.app.getController(\'User\').hedge({tradeID}); return false;">' + Registry._["trade-action-hedge"] + "</a>", "</div>", '<div class="trade-action-help-link">', '<img src="../images/help-16x16.png" onclick="Trading.app.getController(\'User\').showHedgeHelp(); return false;" >', "</div>", "</div>", "</div>", '<div class="trade-entry-confirmation-message message-container" id="trade-entry-confirmation-message-{tradeID}" style="display: none;"></div>', "</div>", "</div>", {
            formatInstrument: function(b) {
                var c = a.instruments.getById(b);
                return c.data.name
            },
            formatAmount: function(b, d, c) {
                if (d == Registry.baseCurrencyID) {
                    return Registry.baseCurrencySymbol + Ext.util.Format.number(b, "0,0.00")
                } else {
                    var e = Registry.currenciesInfo[d];
                    return e.currencySymbol + Ext.util.Format.number(c, "0,0.00") + " (" + Registry.baseCurrencySymbol + Ext.util.Format.number(b, "0,0.00") + ")"
                }
            },
            formatCreated: function(c) {
                var b = new Date(c * 1);
                return Ext.Date.format(b, "d-M-Y H:i:s")
            },
            formatExpiry: function(c) {
                var b = new Date(c * 1);
                return Ext.Date.format(b, "d-M H:i")
            },
            formatDirection: function(b) {
                return (b == "-1") ? Registry._["label-below"] : Registry._["label-above"]
            },
            formatDirectionIcon: function(d, c) {
                var b;
                if (c == 1 || c == 2 || c == 7 || c == 11) {
                    b = (d == "-1") ? '<span class="put-small-icon trade-entry-direction-icon"></span>': '<span class="call-small-icon trade-entry-direction-icon"></span>'
                } else {
                    if (c == 3) {
                        b = (d == "1") ? "Above": "Below"
                    } else {
                        if (c == 4) {
                            b = (d == "1") ? "Range Up": "Range Down"
                        } else {
                            if (c == 5) {
                                b = (d == "1") ? "Touch Up": "Touch Down"
                            } else {
                                if (c == 6) {
                                    b = (d == "1") ? "No Touch Up": "No Touch Down"
                                }
                            }
                        }
                    }
                }
                return b
            },
            formatStrike: function(f, d, c, e, b) {
                return FinancialPanel.formatStrike(f, d, c, e, b)
            },
            formatReturnAmount: function(c, g, f, e, d) {
                var b;
                if (e === Registry.baseCurrencyID) {
                    b = Registry.baseCurrencySymbol + Ext.util.Format.number(c * g / 100, "0,000.00")
                } else {
                    var h = Registry.currenciesInfo[e];
                    b = h.currencySymbol + Ext.util.Format.number(d * g / 100, "0,000.00")
                }
                b += " (" + f + "%)";
                return b
            },
            showLoader: function(b) {
                return (b) ? '<span class="loadable loading">&nbsp;</span>': ""
            },
            setStatus: function(b) {
                return (b) ? "": " open"
            },
            formatHidden: function(c, b) {
                var d = Trading.app.getController("Game");
                if (d.isGameDoubleUp(c, b)) {
                    return ""
                } else {
                    return "x-hidden"
                }
            }
        });
        this.tplTrades = new Ext.XTemplate('<tpl for=".">', '<div class="{[(xindex == 1) ? "first" : ""]} {[(xcount == xindex) ? "last" : ""]}">{[this.renderTrade(values)]}</div>', "</tpl>", {
            renderTrade: function(b) {
                return a.tplTrade.apply(b.data)
            }
        });
        this.tplTradeOperation = new Ext.XTemplate('<div class="trade-action-estimate-wrapper">', "<div>" + Registry._["trade-action-estimate-sell-back"] + "</div>", '<div class="trade-action-estimate-amount in-the-money">{[this.formatAmount(values.estimatedReturn, values.stake, values.userCurrencyStake)]}</div>', "<div>" + Registry._["trade-action-estimate-return"] + "</div>", "<div><a href=\"#\" onclick=\"Trading.app.getController('User').performOperation('{tradeID}', '{operationType}', '{estimatedReturn}'); return false;\" class=\"button-trade-small button\" id=\"apply-operation-{tradeID}\">", Registry._["trade-action-estimate-confirm"] + '<span id="operation-timer-{tradeID}" class="trade-action-estimate-timer">{timeLeft}</span></a></div>', "</div>", {
            formatAmount: function(f, b, c) {
                if (Registry.userCurrency == Registry.baseCurrencyID) {
                    return Registry.baseCurrencySymbol + Ext.util.Format.number(f, "0,0.00")
                } else {
                    var g = Trading.app.getController("Game");
                    var e = g.getUserCurrencyInfo();
                    var d = e.currencySymbol;
                    return d + Ext.util.Format.number(c * f / b, "0,0.00")
                }
            }
        });
        this.tplBonus = new Ext.XTemplate('<div tooltip-content="{[this.formatTooltip(values)]}" class="bonus-info-option {[this.formatChecked(values.active)]} " onclick="Trading.app.getController(\'User\').selectBonusInfoOption(this);">', '<input type="radio" name="active-bonus" tooltip-content-value="{[this.formatTooltip(values)]}" {[this.formatChecked(values.active)]} class="bonus-info-radio-button" onchange="Trading.app.getController(\'User\').selectBonus({bonusID}, {typeID});">', '<div class="bonus-info-container">', '<div class="bonus-info-bonus-name">{[this.formatBonusName(values)]}:&nbsp;</div>', '<div class="bonus-info-active-bonus">{[this.formatAmount(values.activeAmount)]}</div>', '<div class="bonus-meter cf bonus-info-meter">', '<span style="width: {[this.calculatePercentage(values)]}%" class="meter-bar bonus-info-meter-bar"></span>', '<div class="bonus-info-meter-traded">{[this.calculatePercentage(values)]}%</div>', '<div class="bonus-info-meter-missing-volume">{[this.formatMissingVolume(values)]}</div>', "</div>", "</div>", "</div>", {
            formatTooltip: function(b) {
                return a.formatTooltip(b)
            },
            formatChecked: function(b) {
                return b ? "checked": ""
            },
            calculatePercentage: function(c) {
                var b = Math.round(100 * c.volumeTraded / c.volumeRequired);
                if (b > 100) {
                    b = 100
                }
                return b
            },
            formatMissingVolume: function(b) {
                return a.formatAmount(b.volumeTraded) + " / " + a.formatAmount(b.volumeRequired)
            },
            formatAmount: function(b) {
                return a.formatAmount(b)
            },
            formatBonusName: function(b) {
                return b.name
            }
        });
        this.tplBonuses = new Ext.XTemplate('<tpl for=".">', "<div>{[this.renderBonus(values)]}</div>", "</tpl>", {
            renderBonus: function(b) {
                return a.tplBonus.apply(b)
            }
        })
    },
    formatTooltip: function(a) {
        var b = "<div class='bonus-info-tooltip-bonus-name'>" + a.name + "</div><div><span class='bonus-info-tooltip-detail-name'>" + Registry._["bonus-info-tooltip-detail-available-bonus"] + ":</span><span class='bonus-info-tooltip-detail-val'>" + this.formatAmount(a.activeAmount) + "</span></div><div><span class='bonus-info-tooltip-detail-name'>" + Registry._["bonus-info-tooltip-detail-released-bonus"] + ":</span><span class='bonus-info-tooltip-detail-val'>" + this.formatAmount(a.releasedAmount) + "</span></div><div><span class='bonus-info-tooltip-detail-name'>" + Registry._["bonus-info-tooltip-detail-original-bonus"] + ":</span><span class='bonus-info-tooltip-detail-val'>" + this.formatAmount(a.originalAmount) + "</span></div><div><span class='bonus-info-tooltip-detail-name'>" + Registry._["bonus-info-tooltip-detail-volume-traded"] + ":</span><span class='bonus-info-tooltip-detail-val'>" + this.formatAmount(a.volumeTraded) + "</span></div><div><span class='bonus-info-tooltip-detail-name'>" + Registry._["bonus-info-tooltip-detail-volume-required"] + ":</span><span class='bonus-info-tooltip-detail-val'>" + this.formatAmount(a.volumeRequired) + "</span></div>" + (a.deposit ? ("<div><span class='bonus-info-tooltip-detail-name'>" + Registry._["bonus-info-tooltip-detail-related-deposit"] + ":</span><span class='bonus-info-tooltip-detail-val'>" + this.formatAmount(a.deposit) + "</span></div>") : "") + (a.pnl ? ("<div><span class='bonus-info-tooltip-detail-name'>" + Registry._["bonus-info-tooltip-detail-related-pnl"] + ":</span><span class='bonus-info-tooltip-detail-val'>" + this.formatAmount(a.pnl) + "</span></div>") : "");
        return b
    },
    forceLogin: function() {
        if (!this.loggedIn) {
            Ext.WindowMgr.each(function(a) {
                a.close()
            });
            if (Registry.blockRegistrationWidget == 1) {
                location.href = Registry.urlBaseSecure + "/login"
            } else {
                if (Registry.customRegistrationWidgetUrl) {
                    Utils.mask("registration-widget-iframe", "iframe", {
                        src: Registry.customRegistrationWidgetUrl,
                        scrolling: "no"
                    })
                } else {
                    Utils.mask("registration-widget-iframe", "iframe", {
                        src: Registry.scheme + "://widgets." + Registry.domain + "/" + Registry.lang + "/widget/registration?placeholder=0&fb=1&login=1&openPassword=1",
                        scrolling: "no"
                    })
                }
            }
        }
        return this.loggedIn
    },
    showFirstLogin: function() {
        if (!this.loggedIn) {
            Ext.WindowMgr.each(function(a) {
                a.close()
            });
            Utils.mask("quick-login-widget-iframe", "iframe", {
                src: Registry.scheme + "://widgets." + Registry.domain + "/" + Registry.lang + "/widget/quick-login?firstLogin=1&email=" + Registry.email,
                scrolling: "no",
                width: "400"
            });
            Ext.fly("mask-item-x-icon").addCls("x-hidden")
        }
        return this.loggedIn
    },
    showGameBoxDemo: function(a) {
        Ext.WindowMgr.each(function(b) {
            b.close()
        });
        if (Registry.gameBoxDemoWidgetRedirectUrl) {
            Utils.mask("quick-login-widget-iframe", "iframe", {
                src: Registry.scheme + "://widgets." + Registry.domain + "/" + Registry.lang + "/widget/gamebox-demo?walkthrough=1&isPopup=1&isLoggedIn=" + a + "&redirectUrl=" + Registry.gameBoxDemoWidgetRedirectUrl,
                scrolling: "no",
                width: "660",
                height: "300"
            })
        } else {
            Utils.mask("quick-login-widget-iframe", "iframe", {
                src: Registry.scheme + "://widgets." + Registry.domain + "/" + Registry.lang + "/widget/gamebox-demo?walkthrough=1&isPopup=1&isLoggedIn=" + a,
                scrolling: "no",
                width: "660",
                height: "300"
            })
        }
    },
    renderTrades: function() {
        var a = this;
        var b = Trading.app.getController("Expiry");
        if (!this.loggedIn) {
            return
        }
        this.instruments = Trading.app.getController("Instrument").instruments;
        if (this.trades.data.items.length) {
            this.trades.each(function(d) {
                var c = (a.time >= d.data.expiry);
                d.data.expired = c;
                b.addExpiry(d.data.expiry, d.data.tradeID)
            });
            this.tplTrades.overwrite("positions-container", this.trades.data.items);
            a.updateDoubleUpButtonStatuses();
            FinancialPanel.addTrades(this.trades);
            if (Registry.customIndexView) {
                if (typeof(FX1) != "undefined") {
                    FX1.addTrades(this.trades)
                }
            }
            this.trades.each(function(c) {
                Ext.fly("trade-" + c.data.tradeID + "-close-position").on("click",
                function(e, d) {
                    e.stopPropagation()
                });
                Ext.fly("trade-" + c.data.tradeID + "-roll-over").on("click",
                function(e, d) {
                    e.stopPropagation()
                });
                Ext.fly("trade-" + c.data.tradeID + "-double-up").on("click",
                function(e, d) {
                    e.stopPropagation()
                });
                Ext.fly("trade-" + c.data.tradeID + "-hedge").on("click",
                function(e, d) {
                    e.stopPropagation()
                });
                if (!c.data.allowClosePosition) {
                    Ext.fly("trade-" + c.data.tradeID + "-close-position").addCls("x-hidden")
                }
                if (c.data.bonus) {
                    Ext.fly("wallet-promotional-wrapper").setVisibilityMode(Ext.Element.DISPLAY);
                    Ext.fly("wallet-promotional-wrapper").hide()
                }
            });
            Ext.fly("positions-wrapper").removeCls("empty");
            Ext.fly("positions-header").removeCls("x-hidden")
        } else {
            Ext.fly("positions-container").dom.innerHTML = '<span class="none-open">' + Registry._["no-open-positions"] + "</span>"
        }
    },
    updateDoubleUpButtonStatuses: function() {
        var a = this;
        this.trades.each(function(b) {
            a.updateDoubleUpButtonStatus(b)
        })
    },
    updateDoubleUpButtonStatus: function(d) {
        var a = d.data.type;
        var b = d.data.expiry;
        if (!Trading.app.getController("Game").isValidExpiry(a, b)) {
            var c = d.data.tradeID;
            $("#trade-" + c + "-double-up-button, #trade-" + c + "-hedge-button").addClass("x-item-disabled").attr("onclick", "return false;")
        }
    },
    trade: function(g) {
        var f = Trading.app.getController("Expiry");
        this.wallet.credit -= g.data.stake;
        this.wallet.reserved += g.data.stake;
        this.trades.add(g);
        if (Registry.wallet.bonus.required) {
            Registry.wallet.bonus.traded += g.data.stake;
            if (Registry.wallet.bonus.traded > Registry.wallet.bonus.required) {
                Registry.wallet.bonus.traded = Registry.wallet.bonus.required
            }
            var b = Ext.util.Format.round((Registry.wallet.bonus.traded / Registry.wallet.bonus.required) * 100, 0);
            b = b + "%";
            Ext.fly("pending-bonus-meter-bar").dom.innerHTML = b;
            Ext.fly("pending-bonus-meter-bar").setWidth(b);
            var d = new Ext.XTemplate(Registry._["bonus-meter-required"] + ": {required:this.format}<br>", Registry._["bonus-meter-traded"] + ": {traded:this.format}<br>", Registry._["bonus-meter-missing"] + ": {[this.missing(values)]}<br>", {
                format: function(j) {
                    return Trading.app.getController("User").getFormattedAmount(j)
                },
                missing: function(j) {
                    return Trading.app.getController("User").getFormattedAmount(j.required - j.traded)
                }
            });
            Ext.fly("pending-bonus-meter").dom.setAttribute("data-qtip", d.apply(Registry.wallet.bonus))
        }
        f.addExpiry(g.data.expiry, g.data.tradeID);
        this.updateWallet();
        var a = Ext.get("wallet-promotional-bonus-used");
        var h = Ext.get("wallet-promotional-wrapper");
        if (a != null && !a.isVisible() && h != null && h.isVisible()) {
            a.show()
        }
        var e = g.data;
        e.isNew = true;
        if (this.trades.data.items.length == 1) {
            Ext.fly("positions-container").dom.innerHTML = "";
            Ext.fly("positions-wrapper").removeCls("empty");
            Ext.fly("positions-header").removeCls("x-hidden")
        }
        this.tplTrade.insertFirst("positions-container", e);
        Ext.fly("trade-" + g.data.tradeID + "-close-position").on("click",
        function(k, j) {
            k.stopPropagation()
        });
        Ext.fly("trade-" + g.data.tradeID + "-roll-over").on("click",
        function(k, j) {
            k.stopPropagation()
        });
        Ext.fly("trade-" + g.data.tradeID + "-double-up").on("click",
        function(k, j) {
            k.stopPropagation()
        });
        Ext.fly("trade-" + g.data.tradeID + "-hedge").on("click",
        function(k, j) {
            k.stopPropagation()
        });
        if (!g.data.allowClosePosition) {
            Ext.fly("trade-" + g.data.tradeID + "-close-position").addCls("x-hidden")
        }
        this.updateDoubleUpButtonStatus(g);
        Ext.fly("positions-container").scrollTo("top", 0, false);
        var c = Ext.get("trade-" + e.tradeID);
        c.setOpacity(0.25, false);
        c.slideIn("t", {
            duration: 200,
            useDisplay: true,
            easing: "ease",
            callback: function() {
                c.fadeIn({
                    opacity: 1,
                    duration: 1000,
                    callback: function() {
                        c.setHeight("auto");
                        c.setWidth("auto");
                        Trading.app.getController("User").expandTradeEntry(e.tradeID, true)
                    }
                })
            }
        })
    },
    setTime: function(c, l) {
        c = Math.floor(c / 1000) * 1000;
        this.time = c;
        this.updatePendingBonusStatus();
        this.updatePracticeExpiryStatus();
        var j = Trading.app.getController("Expiry");
        var d = j.expiries;
        var m;
        var b;
        var f;
        var h;
        var k;
        var e;
        var a;
        var g = this;
        if (l) {
            if (d[c]) {
                Ext.fly("wallet-loader").addCls("loading");
                for (f = 0; f < d[c].length; f++) {
                    m = d[c][f];
                    b = this.trades.getById(m);
                    b.data.expired = true;
                    if (!b.data.closed) {
                        Ext.fly("trade-entry-indicator-" + m).dom.innerHTML = '<span class="loadable loading">&nbsp;</span>';
                        Ext.fly("trade-entry-info-current-price-" + m).addCls("x-hidden");
                        Ext.fly("trade-entry-info-expired-" + m).removeCls("x-hidden");
                        if (Ext.fly("fp-trade-entry-indicator-" + m)) {
                            Ext.fly("fp-trade-entry-indicator-" + m).dom.innerHTML = '<span class="loadable loading">&nbsp;</span>'
                        }
                    }
                }
            }
        }
        Ext.Object.each(d,
        function(p, n) {
            if (p >= c) {
                h = (p - c) / 1000;
                for (f = 0; f < n.length; f++) {
                    m = n[f];
                    if (Ext.get("evaluation-message-" + m) && Ext.get("evaluation-message-" + m).dom.style.display == "") {
                        g.advanceOperationTimer(m)
                    }
                }
                if (h <= 300) {
                    k = Math.floor(h / 60);
                    e = (h % 60);
                    if (e < 10) {
                        e = "0" + e
                    }
                    a = k + ":" + e;
                    for (f = 0; f < n.length; f++) {
                        m = n[f];
                        b = g.trades.getById(m);
                        if (!b.data.expired) {
                            Ext.fly("trade-entry-expiry-" + m).dom.innerHTML = '<span class="trade-entry-expiry-counter">' + a + "</span>"
                        }
                    }
                }
                if (h <= parseInt(Registry.tradeOperationsConfig.sellbackDeadPeriod)) {
                    for (f = 0; f < n.length; f++) {
                        m = n[f];
                        var o = Ext.get("trade-" + m + "-close-position-button");
                        if (o) {
                            o.addCls("x-item-disabled");
                            o.dom.onclick = function() {};
                            o.dom.title = Registry._["sellback-help-window-note-two"]
                        }
                    }
                }
            }
        })
    },
    expandTradeEntry: function(c, f) {
        var b = "trade-" + c;
        var a = "trade-entry-info-" + c;
        var d = {
            duration: 200,
            useDisplay: true,
            easing: "ease"
        };
        var e = this.trades.getById(c);
        if (f && Ext.fly(b).hasCls("expanded")) {
            return
        }
        if (Ext.fly(b).hasCls("expanded")) {
            Ext.fly(b).removeCls("expanded");
            Ext.get(a).slideOut("t", d);
            Trading.app.getController("Game").selectTradeMarker(e.data.instrumentID, c, false)
        } else {
            Ext.fly(b).addCls("expanded");
            Ext.get(a).slideIn("t", d);
            Trading.app.getController("Game").selectTradeMarker(e.data.instrumentID, c, true)
        }
        new Ext.util.DelayedTask(function() {
            Ext.fly(a).setWidth("auto");
            Ext.fly(a).setHeight("auto")
        }).delay(300)
    },
    quote: function(c, d) {
        var b;
        var e;
        var g;
        var f;
        var a = this;
        d = d * 1;
        this.trades.each(function(h) {
            if (h.data.instrumentID == c && (h.data.expiry > a.time) && !h.data.expired) {
                b = "at-the-money";
                g = h.data.strike * 1;
                f = h.data.distance * 1;
                if (h.data.type == 1 || h.data.type == 2 || h.data.type == 7 || h.data.type == 11) {
                    if (h.data.direction == 1) {
                        if (d > g) {
                            b = "in-the-money"
                        } else {
                            if (d < g) {
                                b = "out-the-money"
                            }
                        }
                    } else {
                        if (d > g) {
                            b = "out-the-money"
                        } else {
                            if (d < g) {
                                b = "in-the-money"
                            }
                        }
                    }
                } else {
                    if (h.data.type == 3) {
                        if (h.data.direction == 1) {
                            if (d > g + f) {
                                b = "in-the-money"
                            } else {
                                b = "out-the-money"
                            }
                        } else {
                            if (d < g - f) {
                                b = "in-the-money"
                            } else {
                                b = "out-the-money"
                            }
                        }
                    } else {
                        if (h.data.type == 4) {
                            if (h.data.direction == 1) {
                                if (d > g && d < g + f) {
                                    b = "in-the-money"
                                } else {
                                    b = "out-the-money"
                                }
                            } else {
                                if (d > g - f && d < g) {
                                    b = "in-the-money"
                                } else {
                                    b = "out-the-money"
                                }
                            }
                        } else {
                            if (h.data.type == 5) {
                                b = "out-the-money"
                            } else {
                                if (h.data.type == 6) {
                                    b = "in-the-money"
                                }
                            }
                        }
                    }
                }
                e = Registry._[b];
                Ext.fly("trade-entry-indicator-" + h.data.tradeID).dom.innerHTML = '<span class="' + b + '">' + e + "</span>";
                if (Ext.fly("fp-trade-entry-indicator-" + h.data.tradeID)) {
                    Ext.fly("fp-trade-entry-indicator-" + h.data.tradeID).dom.innerHTML = '<span class="' + b + '">' + e + "</span>"
                }
                $("#trade-" + h.data.tradeID).attr("data-quote", d)
            }
        })
    },
    getEvaluation: function(c, b) {
        var a = this;
        Ext.fly("trade-" + c + "-close-position").hide();
        Ext.fly("evaluation-loader-" + c).dom.innerHTML = '<span class="loadable loading">&nbsp;</span>';
        Ext.fly("evaluation-loader-" + c).show();
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/user/get-sellback-amount",
            scope: this,
            params: {
                trade: c,
                operationType: b
            },
            success: function(d, e) {
                Ext.fly("evaluation-loader-" + c).hide();
                d = Ext.decode(d.responseText);
                var g;
                if (d.success) {
                    d.estimatedReturn = d.amount;
                    Ext.fly("trade-" + c + "-close-position").hide();
                    var j = a.trades.getById(c);
                    var h = {
                        timeLeft: "",
                        estimatedReturn: d.estimatedReturn,
                        stake: j.data.stake,
                        userCurrencyStake: j.data.userCurrencyStake,
                        tradeID: c,
                        operationType: b
                    };
                    g = Ext.get("evaluation-message-" + c);
                    var f = this.tplTradeOperation.apply(h);
                    g.setVisibilityMode(Ext.Element.DISPLAY);
                    g.dom.innerHTML = f;
                    g.show();
                    Ext.fly("apply-operation-" + c).on("click",
                    function(l, k) {
                        l.stopPropagation()
                    })
                } else {
                    a.displayOperationError(c, d.errorMessage)
                }
            },
            failure: function(d) {
                Ext.fly("evaluation-loader-" + c).hide();
                a.displayOperationError(c, "Unable to process your request.<br>Please try again.")
            }
        })
    },
    doubleUp: function(a) {
        this.duplicateTrade(a, false)
    },
    hedge: function(a) {
        this.duplicateTrade(a, true)
    },
    duplicateTrade: function(b, a) {
        b = parseInt(b);
        var d = this.trades.getById(b);
        var e = Trading.app.getController("Game");
        if (!e.isGameDoubleUp(d.data.instrumentID, d.data.type)) {
            return
        }
        var c = {};
        c.instrumentID = d.data.instrumentID;
        c.payout = d.data.payout * 1;
        c.rebate = d.data.rebate * 1;
        c.direction = d.data.direction * 1;
        if (a) {
            c.direction *= -1
        }
        c.expiry = d.data.expiry * 1;
        c.stake = d.data.stake;
        c.userCurrency = d.data.userCurrency;
        c.userCurrencyStake = d.data.userCurrencyStake;
        c.strike = $("#trade-" + b).attr("data-quote");
        c.gameType = d.data.type;
        e.trade(d.data.instrumentID, c, true, b)
    },
    advanceOperationTimer: function(b) {
        if (!Ext.get("operation-timer-" + b)) {
            return
        }
        var a = Ext.get("operation-timer-" + b).dom.innerHTML;
        if (a == "") {
            a = parseInt(Registry.tradeOperationsConfig.timeout) + 1
        } else {
            a = parseInt(a);
            if (isNaN(a) || a <= 1) {
                Ext.get("operation-timer-" + b).dom.innerHTML = "";
                Ext.get("evaluation-message-" + b).hide();
                Ext.fly("trade-" + b + "-close-position").show();
                return
            }
        }
        a--;
        Ext.get("operation-timer-" + b).dom.innerHTML = a.toString()
    },
    performOperation: function(c, b, e) {
        var a = this;
        var d = this.trades.getById(parseInt(c));
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/user/sellback",
            scope: this,
            params: {
                trade: c,
                operationType: b,
                amount: e,
                stake: d.data.stake
            },
            success: function(f, g) {
                f = Ext.decode(f.responseText);
                Ext.get("evaluation-message-" + c).hide();
                Ext.fly("trade-" + c + "-close-position").hide();
                Ext.fly("trade-" + c + "-double-up").hide();
                Ext.fly("trade-" + c + "-hedge").hide();
                if (f.success) {
                    Ext.fly("wallet-loader").addCls("loading");
                    new Ext.util.DelayedTask(a.onPerformOperationSuccess, null, [{
                        tradeID: c,
                        status: "at",
                        timestamp: f.timestamp,
                        estimatedReturn: e
                    }]).delay(500)
                } else {
                    a.displayOperationError(c, f.errorMessage)
                }
            },
            failure: function(f) {
                Ext.get("evaluation-message-" + c).hide();
                Ext.fly("trade-" + c + "-close-position").hide();
                a.displayOperationError(c, "Unable to process your request.<br>Please try again.")
            }
        })
    },
    onPerformOperationSuccess: function(j) {
        var f = Trading.app.getController("User");
        var k = j.tradeID;
        var b = f.trades.getById(parseInt(k));
        var c = j.isCanceled ? b.data.stake: j.estimatedReturn;
        var h = j.isCanceled ? b.data.timestamp: j.timestamp;
        b.data.expired = true;
        b.data.closed = true;
        Trading.app.getController("Game").updateTradeMarker(b.data.instrumentID, b, true);
        Ext.fly("trade-entry-expiry-" + k).dom.innerHTML = j.isCanceled ? Registry._["Trade cancelled"] : Registry._["Trade closed"];
        if (Registry.userCurrency == Registry.baseCurrencyID) {
            Ext.fly("trade-entry-indicator-" + k).dom.innerHTML = Registry._["label-return-amount"] + ": " + Registry.baseCurrencySymbol + Ext.util.Format.number(c, "0,0.00")
        } else {
            var e = Trading.app.getController("Game");
            var d = e.getUserCurrencyInfo();
            var g = d.currencySymbol;
            Ext.fly("trade-entry-indicator-" + k).dom.innerHTML = Registry._["label-return-amount"] + ": " + g + Ext.util.Format.number(b.data.userCurrencyStake * c / b.data.stake, "0,0.00")
        }
        Ext.fly("trade-entry-info-current-price-" + k).addCls("x-hidden");
        Ext.fly("trade-entry-info-closing-time-" + k).dom.innerHTML = Ext.Date.format(new Date(h * 1), "d-M H:i");
        Ext.fly("trade-entry-info-closing-" + k).removeCls("x-hidden");
        var a = Ext.fly("trade-entry-status-indicator-" + k);
        if (a) {
            a.removeCls("open");
            a.addCls(j.status)
        }
        f.updateWallet()
    },
    displayOperationError: function(c, d) {
        Ext.fly("evaluation-loader-" + c).addCls("x-hidden");
        var b = Ext.get("evaluation-error-message-" + c);
        b.setVisibilityMode(Ext.Element.DISPLAY);
        b.dom.innerHTML = d;
        b.show();
        var a = new Ext.util.DelayedTask(function() {
            Ext.get("evaluation-error-message-" + c).hide();
            Ext.fly("trade-" + c + "-close-position").show()
        });
        a.delay(5000)
    },
    showSellbackHelp: function() {
        var b = "sellback-help-window";
        var a = Ext.WindowMgr.get(b);
        if (!a) {
            a = Ext.create("Trading.view.SellbackHelpWindow", {
                id: b
            })
        }
        a.show()
    },
    showDoubleUpHelp: function() {
        var b = "double-up-help-window";
        var a = Ext.WindowMgr.get(b);
        if (!a) {
            a = Ext.create("Trading.view.DoubleUpHelpWindow", {
                id: b
            })
        }
        a.show()
    },
    showHedgeHelp: function() {
        var b = "hedge-help-window";
        var a = Ext.WindowMgr.get(b);
        if (!a) {
            a = Ext.create("Trading.view.HedgeHelpWindow", {
                id: b
            })
        }
        a.show()
    },
    showWeekendOptionHelp: function() {
        var b = "weekend-option-help-window";
        var a = Ext.WindowMgr.get(b);
        if (!a) {
            a = Ext.create("Trading.view.WeekendOptionHelpWindow", {
                id: b
            })
        }
        a.show()
    },
    showFrozenAccountWindow: function() {
        var b = "frozen-account-window";
        var a = Ext.WindowMgr.get(b);
        if (!a) {
            a = Ext.create("Trading.view.FrozenAccountWindow", {
                id: b
            })
        }
        a.show()
    },
    showRiskOMeterHelp: function() {
        var b = "risk-o-meter-help-window";
        var a = Ext.WindowMgr.get(b);
        if (!a) {
            a = Ext.create("Trading.view.RiskOMeterHelpWindow", {
                id: b
            })
        }
        a.show()
    },
    updateWallet: function() {
        var a = this;
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/index/get-wallet-details",
            success: function(g) {
                g = Ext.decode(g.responseText);
                var b = g.wallet;
                var h = Ext.get("wallet-promotional-bonus-used");
                if (h) {
                    h.hide()
                }
                var e = parseFloat(b.available);
                var f = parseFloat(b.credit);
                var d = parseFloat(b.reserved);
                var k = parseFloat(b.bonus.tradeable);
                var c = parseFloat(b.bonus.promotional);
                var j = parseFloat(b.bonus.pending);
                var l = parseFloat(b.bonus.traded);
                var m = parseFloat(b.bonus.required);
                Ext.fly("wallet-credit").dom.innerHTML = a.getFormattedAmount(e, true);
                Ext.fly("wallet-reserved").dom.innerHTML = a.getFormattedAmount(d, true);
                Ext.fly("wallet-balance").dom.innerHTML = a.getFormattedAmount(f, true);
                if (!Registry.practiceMode) {
                    Ext.get("wallet-available-bonus").dom.innerHTML = a.getFormattedAmount(k, true);
                    if (c) {
                        Ext.get("wallet-promotional").dom.innerHTML = a.getFormattedAmount(c, true);
                        Ext.get("wallet-promotional-wrapper").setVisibilityMode(Ext.Element.DISPLAY);
                        Ext.get("wallet-promotional-wrapper").show()
                    } else {
                        if (Ext.get("wallet-promotional-wrapper")) {
                            Ext.get("wallet-promotional-wrapper").setVisibilityMode(Ext.Element.DISPLAY);
                            Ext.get("wallet-promotional-wrapper").hide()
                        }
                    }
                    Ext.get("wallet-pending-bonus").dom.innerHTML = a.getFormattedAmount(j, true)
                }
                a.wallet.credit = f;
                a.wallet.reserved = d;
                a.wallet.bonus.amount = j;
                a.wallet.bonus.promotional = c;
                a.wallet.bonus.traded = l;
                a.wallet.bonus.required = m;
                Registry.wallet = a.wallet;
                Ext.fly("wallet-loader").removeCls("loading");
                a.updateBonusInfo(false);
                if (!Registry.practiceMode && b.pendingBonusDetails.expiryDate) {
                    if (!b.pendingBonusDetails.releasable) {
                        a.pendingBonusExpiryDate = b.pendingBonusDetails.expiryDate
                    } else {
                        a.pendingBonusExpiryDate = -1
                    }
                }
            },
            failure: function(b) {
                Ext.fly("wallet-loader").removeCls("loading")
            }
        })
    },
    getFormattedAmount: function(c, e) {
        if (Registry.userCurrency === Registry.baseCurrencyID) {
            return Registry.baseCurrencySymbol + Ext.util.Format.number(c, "0,0.00")
        } else {
            var f = Trading.app.getController("Game");
            var d = f.getUserCurrencyInfo();
            var b = d.currencySymbol;
            var a = d.conversionRate;
            return b + Ext.util.Format.number(c / a, "0,0.00") + " " + (e ? '<span class="wallet-small">': "") + "(" + Registry.baseCurrencySymbol + Ext.util.Format.number(c, "0,0.00") + ")" + (e ? "</span>": "")
        }
    },
    formatAmount: function(c) {
        if (Registry.userCurrency === Registry.baseCurrencyID) {
            return Registry.baseCurrencySymbol + Ext.util.Format.number(c, "0,0")
        } else {
            var e = Trading.app.getController("Game");
            var d = e.getUserCurrencyInfo();
            var b = d.currencySymbol;
            var a = d.conversionRate;
            return b + Ext.util.Format.number(c / a, "0,0")
        }
    },
    toggleBonusInfo: function() {
        if (this.isBonusInfoVisible) {
            $("#bonus-info").hide()
        } else {
            this.updateBonusInfo(true)
        }
        this.isBonusInfoVisible = !this.isBonusInfoVisible
    },
    updateBonusInfo: function(b) {
        var a = this;
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/user/get-bonuses",
            success: function(c) {
                c = Ext.decode(c.responseText);
                var d = c.data;
                if (d.length) {
                    a.tplBonuses.overwrite("bonus-info-bonuses", d);
                    a.updateActiveBonus();
                    if (b) {
                        $("#bonus-info").css("top", $("#bonus-info-link").position().top - 157);
                        $("#bonus-info").show()
                    }
                } else {
                    a.isBonusInfoVisible = false
                }
            }
        })
    },
    selectBonus: function(b, a) {
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/user/select-bonus-for-volume",
            params: {
                bonusID: b,
                typeID: a
            },
            success: function(c) {}
        });
        this.updateActiveBonus()
    },
    updateActiveBonus: function() {
        var d = $(".bonus-info-radio-button:checked");
        if (!d.length) {
            d = $(".bonus-info-radio-button");
            if (!d.length) {
                return
            }
            d = $(d[0])
        }
        var c = d.siblings(".bonus-info-container").children(".bonus-info-bonus-name").html().replace("&nbsp;", "");
        var e = d.siblings(".bonus-info-container").children(".bonus-info-active-bonus").html();
        var b = d.siblings(".bonus-info-container").find(".bonus-info-meter-traded").html();
        $("#balance-progress-bar-container .balance-bonus-info-option .balance-bonus-info-bonus-name").html(c);
        $("#balance-progress-bar-container .balance-bonus-info-option .balance-bonus-info-active-bonus").html(e);
        $("#balance-progress-bar-container .balance-bonus-info-option .bonus-info-meter .bonus-info-meter-bar").css("width", b);
        $("#balance-progress-bar-container .balance-bonus-info-option .bonus-info-meter .bonus-info-meter-traded").html(b);
        var a = d.attr("tooltip-content-value");
        $("#balance-bonus-info-container").attr("tooltip-content", a)
    },
    selectBonusInfoOption: function(a) {
        $(".bonus-info-option").removeClass("checked");
        a = $(a);
        a.addClass("checked");
        a.find(".bonus-info-radio-button").attr("checked", true).change()
    }
});
Ext.define("Trading.model.TradingHourRanges", {
    extend: "Ext.data.Model",
    fields: ["from", "to"],
    belongsTo: {
        model: "Trading.model.TradingHours",
        name: "tradingHours"
    }
});
Ext.define("Trading.model.PayoutRanges", {
    extend: "Ext.data.Model",
    fields: ["payout", "rebate", "chance"],
    belongsTo: {
        model: "Trading.model.Payouts",
        name: "payouts"
    }
});
Ext.define("Trading.controller.Game", {
    extend: "Ext.app.Controller",
    time: 0,
    instruments: null,
    page: 1,
    pageSize: 4,
    numOfPages: 1,
    gameTemplateFunctions: null,
    tplGame: null,
    tplGameClosed: null,
    tplSmallGame: null,
    tplSmallGameClosed: null,
    tplFinancialView: null,
    tplGames: null,
    tplInvoice: null,
    tplSixtySecondsInvoice: null,
    tplPayouts: null,
    tplMore: null,
    tplSentiment: null,
    tplProgressBar: null,
    tplPagination: null,
    selectedGameTemplate: null,
    selectedGameID: null,
    selectedChartType: null,
    chartTypeCookieKey: "financialViewChartType",
    firstLoading: true,
    firstRendering: true,
    dateHelperExpiry: null,
    currentFilter: "featured",
    counters: null,
    selectedExpiries: null,
    progressUpdates: null,
    locked: null,
    charts: null,
    candlestickCharts: null,
    chartUpdater: null,
    sentiment: null,
    lastQuotes: [],
    featured: null,
    starred: null,
    showTradesMarkers: {
        myTrades: true,
        social: true
    },
    instrumentInvestmentLimits: {},
    expiryData: {},
    selectedShortExpiryOption: {},
    selectedGameTypes: {},
    zoomLevels: [60, 30, 15],
    regularZoomLevels: [60, 30, 15],
    weekendZoomLevels: [120, 60, 30],
    zoomLevelIndex: 0,
    currentMinute: 0,
    chartsRendered: false,
    instrumentHideConfirmationTasks: {},
    tradeHideConfirmationTasks: {},
    views: ["AdvancedChart"],
    practiceMode: null,
    showGameInfo: null,
    init: function() {
        var b = "gameTemplate";
        var c = Utils.getCookie(b);
        this.practiceMode = Registry.practiceMode ? 1 : 0;
        this.showGameInfo = Registry.displayGameInfo;
        if (!c || (c === "financial" && !(Registry.financialViewConfig.enabled * 1)) || ["small", "regular", "financial"].indexOf(c) === -1) {
            this.selectedGameTemplate = Registry.defaultGameTemplate
        } else {
            this.selectedGameTemplate = c
        }
        var d = Utils.getCookie(this.chartTypeCookieKey);
        if (!d || ["line", "candelstick"].indexOf(d) === -1) {
            this.selectedChartType = Registry.financialViewConfig.defaultChartType
        } else {
            this.selectedChartType = d
        }
        this.time = Registry.time;
        this.dateHelperExpiry = new Date(this.time);
        this.currentMinute = Math.floor(this.time / 60000) * 60000;
        this.initTemplates();
        Highcharts.setOptions({
            global: {
                useUTC: false
            }
        });
        this.showTradesMarkers.myTrades = Registry.chartConfig.markers.myTrades.show;
        this.showTradesMarkers.social = Registry.chartConfig.markers.social.show;
        var a = this;
        $(".tpl-select-option").click(function() {
            $(".tpl-select-option").removeClass("active"),
            $(this).addClass("active");
            a.selectedGameTemplate = $(this).attr("game-tpl");
            Utils.setCookie(b, a.selectedGameTemplate, 365, "/");
            a.renderGames()
        });
        $('.tpl-select-option[game-tpl="' + this.selectedGameTemplate + '"]').addClass("active")
    },
    render: function() {
        this.selectedExpiries = {};
        this.progressUpdates = {};
        this.locked = {};
        this.charts = {};
        this.candlestickCharts = {};
        if (!this.instruments) {
            this.instruments = Ext.create("Ext.data.Store", {
                model: "Trading.model.Instrument"
            })
        }
        this.instruments.loadData(Trading.app.getController("Instrument").instruments.data.items);
        var a = false;
        if (this.instruments.data.items.length == 0) {
            this.instruments = Ext.create("Ext.data.Store", {
                model: "Trading.model.Instrument"
            });
            this.instruments.loadData(Trading.app.getController("Instrument").instruments.data.items);
            a = true
        }
        this.instruments.each(function(d) {
            var c = d.data.instrumentID;
            d.data.featured = Ext.Array.contains(Registry.featured, c);
            d.data.starred = Ext.Array.contains(Registry.starred, c)
        });
        if (a) {
            var b = (Ext.isArray(this.currentFilter)) ? this.currentFilter: [{
                property: this.currentFilter,
                value: true
            }];
            this.instruments.filter(b)
        }
        if (this.firstLoading) {
            this.instruments.filter([{
                property: "featured",
                value: true
            }]);
            this.firstLoading = false
        }
        if (this.currentFilter) {
            this.instruments.sort([{
                property: "isOpen",
                direction: "DESC"
            },
            {
                property: "order",
                direction: "ASC"
            },
            {
                property: "name",
                direction: "ASC"
            }])
        } else {
            this.instruments.sort([{
                property: "isOpen",
                direction: "DESC"
            },
            {
                property: "name",
                direction: "ASC"
            }])
        }
        this.calcNumOfPages();
        this.renderPagination();
        this.renderGames();
        this.firstRendering = false
    },
    renderGames: function() {
        var b = Registry.featured.slice(0);
        var d = Registry.starred.slice(0);
        var m;
        var h = [];
        var k = [];
        var j;
        var e;
        this.featured = [];
        this.starred = [];
        if (this.currentFilter == "featured") {
            for (j in b) {
                m = this.instruments.getById(b[j]);
                if (m) {
                    if (m.data.isOpen) {
                        h.push(b[j])
                    } else {
                        k.push(b[j])
                    }
                }
            }
            this.featured = h.concat(k)
        } else {
            if (this.currentFilter == "starred") {
                this.starred = [];
                for (e in d) {
                    m = this.instruments.getById(d[e]);
                    if (m) {
                        this.starred.push(d[e])
                    }
                }
            }
        }
        var f = this.getGames();
        if (!f.length) {
            $("#games-wrapper").hide();
            return
        } else {
            $("#games-wrapper").show()
        }
        if (this.selectedGameTemplate == "regular") {
            this.tplGames.overwrite("games-wrapper", f);
            $("#pagination-wrapper").css("display", "block")
        } else {
            if (this.selectedGameTemplate == "small") {
                var c = [];
                for (var g = 0; g < f.length; g++) {
                    if (!c.length || c[c.length - 1].length == 2) {
                        c.push([])
                    }
                    c[c.length - 1].push(f[g])
                }
                this.tplSmallGameContainers.overwrite("games-wrapper", c);
                $("#pagination-wrapper").css("display", "block")
            } else {
                if (this.selectedGameTemplate == "financial") {
                    this.tplFinancialView.overwrite("games-wrapper", f);
                    if (!f.length) {
                        $("#expiry-container").hide();
                        $("#chart-container").hide();
                        $("#closed-game-container").hide()
                    } else {
                        this.selectedGameID = f[0].data.instrumentID;
                        if (!f[0].data.isOpen) {
                            $("#expiry-container").hide();
                            $("#chart-container").hide();
                            $("#closed-game-container").show()
                        }
                        $(".nano").nanoScroller();
                        var l = {
                            header: "ui-icon-circle-plus",
                            activeHeader: "ui-icon-circle-minus"
                        };
                        $("#accordion").accordion({
                            collapsible: true,
                            heightStyle: "content",
                            icons: l,
                            beforeActivate: function(q, r) {
                                if (!r.newHeader.attr("id")) {
                                    return
                                }
                                var p = r.newHeader.attr("id").substr(5);
                                var s = Trading.app.getController("Game");
                                var o = null;
                                var n = s.getGameType(p);
                                s.instruments.getById(p).payouts().each(function(t) {
                                    if (n == t.data.gameType) {
                                        o = t.data.payout + "-" + t.data.rebate
                                    }
                                });
                                s.selectPayout(p, o, true);
                                if (s.showGameInfo) {
                                    $(".instrument-desc").removeAttr("tooltip-content")
                                }
                            },
                            activate: function(q, s) {
                                if (!s.newHeader.attr("id")) {
                                    return
                                }
                                var p = s.newHeader.attr("id").substr(5);
                                var u = Trading.app.getController("Game");
                                u.selectedGameID = p;
                                var n = u.instruments.getById(p);
                                var o = u.tplFinancialViewChartWrapper;
                                o.overwrite("chart-wrapper", n.data);
                                u.renderCharts([n]);
                                var t = u.tplFinancialViewGameExpiry;
                                t.overwrite("financial-game-expiry-wrapper", n.data);
                                u.renderExpiryBoxes(p);
                                u.renderSentiment();
                                if (!n.data.isOpen) {
                                    var r = u.tplFinancialViewGameClosed;
                                    r.overwrite("closed-game-wrapper", n.data);
                                    $("#expiry-container").hide();
                                    $("#chart-container").hide();
                                    $("#closed-game-container").show()
                                } else {
                                    $("#closed-game-container").hide();
                                    $("#expiry-container").show();
                                    $("#chart-container").show()
                                }
                                if (u.showGameInfo) {
                                    $(".instrument-desc").tooltip({
                                        position: {
                                            my: "left-50 top+15",
                                            collision: "none"
                                        },
                                        items: "[tooltip-content]",
                                        tooltipClass: "game-tooltip instrument-desc-tooltip"
                                    });
                                    $(".ask-bid-desc").tooltip({
                                        position: {
                                            my: "right+80 bottom-30",
                                            collision: "none"
                                        },
                                        items: "[tooltip-content]",
                                        tooltipClass: "game-tooltip ask-bid-desc-tooltip"
                                    })
                                }
                            }
                        });
                        $(".sortable-list").sortable({
                            stop: function(p, q) {
                                if (Trading.app.getController("Game").currentFilter != "starred") {
                                    return
                                }
                                var n = [];
                                var r = $("#accordion > li > h3");
                                for (var o = 0; o < r.length; o++) {
                                    n.push($(r[o]).attr("id").substr(5))
                                }
                                Registry.starred = n;
                                n = n.join();
                                Ext.Ajax.request({
                                    url: Registry.uriBase + "/ajax/user/set-favorites",
                                    method: "GET",
                                    params: {
                                        instrumentIDs: n
                                    },
                                    success: function(s) {
                                        s = Ext.decode(s.responseText)
                                    }
                                })
                            }
                        });
                        f = [f[0]];
                        $("#pagination-wrapper").css("display", "none")
                    }
                }
            }
        }
        if (f.length > 1) {
            this.renderExpiryBoxes()
        } else {
            this.renderExpiryBoxes(f[0].data.instrumentID)
        }
        var a = new Ext.util.DelayedTask(function() {
            Trading.app.getController("Game").renderCharts(f)
        });
        a.delay(50);
        this.renderSentiment();
        if (this.showGameInfo) {
            $(".instrument-desc").tooltip({
                position: {
                    my: "left-50 top+15",
                    collision: "none"
                },
                items: "[tooltip-content]",
                tooltipClass: "game-tooltip instrument-desc-tooltip"
            });
            $(".ask-bid-desc").tooltip({
                position: {
                    my: "right+130 bottom-30",
                    collision: "none"
                },
                items: "[tooltip-content]",
                tooltipClass: "game-tooltip ask-bid-desc-tooltip"
            })
        }
    },
    renderGamesLite: function() {
        var d = this.getGames();
        var a = [];
        var c = this;
        if (this.selectedGameTemplate === "financial") {
            var b = false;
            Ext.each(d,
            function(e) {
                var h = "game-container-" + e.data.instrumentID;
                if (!Ext.fly(h)) {
                    console.log("Error: Object with id " + h + " doesn't exist");
                    return
                }
                var g = e.data.isOpen;
                var f = Ext.fly(h).dom.getAttribute("data-state");
                if ((g && (f != "open")) || (!g && (f != "closed"))) {
                    b = true
                }
            });
            if (b) {
                this.render()
            }
            this.renderExpiryBoxes()
        } else {
            Ext.each(d,
            function(e) {
                var l = "game-container-" + e.data.instrumentID;
                if (!Ext.fly(l)) {
                    console.log("Error: Object with id " + l + " doesn't exist");
                    return
                }
                var g;
                var k = false;
                var h = e.data.isOpen;
                var f = Ext.fly(l).dom.getAttribute("data-state");
                var j;
                k = ((h && (f != "open")) || (!h && (f != "closed")));
                if (k) {
                    if (c.selectedGameTemplate == "regular") {
                        g = (h) ? c.tplGame: c.tplGameClosed
                    } else {
                        if (c.selectedGameTemplate == "small") {
                            g = (h) ? c.tplSmallGame: c.tplSmallGameClosed
                        } else {
                            if (c.selectedGameTemplate == "financial") {
                                g = (h) ? c.tplFinancialViewGame: c.tplFinancialViewGameClosed;
                                g = c.tplFinancialViewGame
                            }
                        }
                    }
                    g.overwrite(l, e.data);
                    j = Ext.getDom(l);
                    if (j) {
                        j.setAttribute("data-state", (h) ? "open": "closed");
                        j.removeAttribute("data-disabled")
                    }
                    if (Ext.fly(l)) {
                        Ext.fly(l).removeCls("disabled")
                    }
                    if (h) {
                        a.push(e)
                    }
                }
            });
            this.renderExpiryBoxes();
            if (a.length) {
                this.renderCharts(a)
            }
        }
    },
    getGames: function() {
        var f = ((this.page - 1) * this.pageSize);
        var e = f + this.pageSize - 1;
        var d = [];
        var a;
        if (this.currentFilter == "featured") {
            if (this.selectedGameTemplate == "regular" || this.selectedGameTemplate == "small") {
                var c = this.featured.slice(f, e + 1)
            } else {
                var c = this.featured
            }
            var b;
            for (b in c) {
                a = this.instruments.getById(c[b]);
                if (a) {
                    d.push(a)
                }
            }
        } else {
            if (this.currentFilter == "starred") {
                if (this.selectedGameTemplate == "regular" || this.selectedGameTemplate == "small") {
                    var c = this.starred.slice(f, e + 1)
                } else {
                    var c = this.starred
                }
                var b;
                for (b in c) {
                    a = this.instruments.getById(c[b]);
                    if (a) {
                        d.push(a)
                    }
                }
            } else {
                if (this.selectedGameTemplate == "regular" || this.selectedGameTemplate == "small") {
                    d = this.instruments.getRange(f, e)
                } else {
                    d = this.instruments.getRange()
                }
            }
        }
        return d
    },
    renderExpiryBoxes: function(g) {
        var e = this.time;
        var f = (g) ? [this.instruments.getById(g)] : this.getGames();
        var b = (2 * 60000);
        var c = (15 * 60000);
        var l = (10 * 60000);
        var n = e - (e % c);
        var m = this.firstRendering;
        var k = -1;
        if ((n + c - e) < l) {
            k = n + c;
            n += c
        } else {
            if (e - n < b) {
                k = n
            }
        }
        var o = this.formatExpiry(n);
        var d;
        var a;
        var h;
        var j = Trading.app.getController("Game");
        Ext.each(f,
        function(L) {
            var C = Trading.app.getController("Game");
            var H = "game-expiry-box-" + L.data.instrumentID;
            var t = [];
            var z;
            var p;
            var D;
            var E;
            var y = false;
            var B;
            var G = C.getGameType(L.data.instrumentID);
            if (G == "11") {
                G = "1"
            }
            var u = 0;
            var I = null;
            var s;
            var K = C.selectedShortExpiryOption[L.data.instrumentID];
            if (typeof(K) === "undefined") {
                K = 1;
                C.selectedShortExpiryOption[L.data.instrumentID] = K
            }
            var x = Registry.longTermGames.indexOf(L.data.instrumentID + "") > -1;
            switch (G) {
            case "2":
                if (Registry.instrumentExpiries[L.data.instrumentID] && Registry.instrumentExpiries[L.data.instrumentID]["expiry_sixty_second"]) {
                    I = Registry.instrumentExpiries[L.data.instrumentID]["expiry_sixty_second"]
                } else {
                    I = Registry.expiries.expiry_sixty_second
                }
                break;
            case "7":
                d = [Registry.weekendOptionExpiryTimestamp];
                break;
            default:
                if (Registry.instrumentExpiries[L.data.instrumentID] && Registry.instrumentExpiries[L.data.instrumentID]["expiry_high_low"]) {
                    I = Registry.instrumentExpiries[L.data.instrumentID]["expiry_high_low"]
                } else {
                    I = Registry.expiries.expiry_high_low
                }
                break
            }
            if (G == "2") {
                $("#game-expiry-box-" + L.data.instrumentID).hide();
                $("#game-expiry-label-" + L.data.instrumentID).hide();
                $("#game-short-expiry-options-" + L.data.instrumentID).show();
                $("#game-short-expiry-tooltip-" + L.data.instrumentID).show();
                $("#game-short-expiry-tooltip-arrow-" + L.data.instrumentID).show()
            } else {
                $("#game-short-expiry-options-" + L.data.instrumentID).hide();
                $("#game-short-expiry-tooltip-" + L.data.instrumentID).hide();
                $("#game-short-expiry-tooltip-arrow-" + L.data.instrumentID).hide();
                $("#game-expiry-box-" + L.data.instrumentID).show();
                $("#game-expiry-label-" + L.data.instrumentID).show()
            }
            j.expiryData[L.data.instrumentID] = {};
            var q = $("#game-short-expiry-options-" + L.data.instrumentID);
            q.empty();
            var w;
            var v;
            if (I) {
                d = [];
                for (h = 0; h < I.length; h++) {
                    n = e - e % (I[h].round * 1000);
                    s = n + I[h].expiry * 1000;
                    if (s - e > I[h].deadPeriod * 1000 || G == "2") {
                        if ($.inArray(s, d) == -1) {
                            d.push(s);
                            j.expiryData[L.data.instrumentID][s] = {
                                expiry: I[h].expiry * 1000,
                                deadPeriod: I[h].deadPeriod * 1000
                            }
                        }
                    }
                    if (G == "2") {
                        v = I[h].deadPeriod;
                        if (v * 1 <= 60) {
                            v += "Sec"
                        } else {
                            v /= 60;
                            v += "min"
                        }
                        q.append('<li class="short-expiry-option-' + h + '" ><div class="short-expiry-text" onclick="Trading.app.getController(\'Game\').selectShortExpiryOption(' + L.data.instrumentID + ", " + s + ", " + h + ');">' + v + "</div></li>");
                        if (h == K) {
                            w = s
                        }
                    }
                }
            }
            if (G == "2") {
                C.selectShortExpiryOption(L.data.instrumentID, w, K)
            }
            if (G == "1" && x) {
                d.push("long-term-divider");
                d.push.apply(d, Registry.longTermOptionExpiryTimestamps)
            }
            a = [];
            for (h = 0; h < d.length; h++) {
                if (d[h] == "long-term-divider") {
                    d[h] = "";
                    var r = " " + Registry._["long-term"] + " ";
                    var J = (23 - r.length) / 2;
                    var F;
                    for (F = 0; F < J; F++) {
                        r = "-" + r + "-"
                    }
                    a[h] = r
                } else {
                    a[h] = C.formatExpiry(d[h])
                }
            }
            if (Ext.fly(H)) {
                D = Ext.fly(H).getValue();
                if (G == "2") {
                    D = w
                }
                u = $("#" + H)[0].options.length;
                E = D;
                for (h = 0; h < d.length; h++) {
                    z = d[h];
                    p = a[h];
                    B = false;
                    if (G == 2) {
                        G = 1
                    }
                    if (G == 7 || z == "") {
                        B = true
                    } else {
                        if (Registry.longTermOptionExpiryTimestamps.indexOf(z) > -1) {
                            if (z - j.time > 7200000) {
                                B = true
                            }
                        } else {
                            L.tradingHours().each(function(M) {
                                if (M.data.gameType == G) {
                                    M.tradingHourRanges().each(function(O) {
                                        var Q = O.data.from;
                                        var P = O.data.to;
                                        var N = false;
                                        if (z <= Q) {
                                            N = true
                                        } else {
                                            if (z > Q && z <= P) {
                                                B = true;
                                                N = true
                                            }
                                        }
                                        return ! N
                                    })
                                }
                            })
                        }
                    }
                    if (B) {
                        if ((D == "") || ((!y) && (D < z) && Registry.longTermOptionExpiryTimestamps.indexOf(D * 1) == -1)) {
                            D = z
                        }
                        if (D == z) {
                            y = true
                        }
                        t.push({
                            timestamp: z,
                            expiry: p,
                            selected: (D == z)
                        })
                    }
                }
                if (Ext.isEmpty(t)) {
                    t.push({
                        timestamp: n,
                        expiry: o,
                        selected: true
                    });
                    C.disableGame(L.data.instrumentID)
                }
                var A = Ext.get(H).dom;
                A.options.length = 0;
                y = false;
                for (h = 0; h < t.length; h++) {
                    if (t[h].selected) {
                        y = true;
                        break
                    }
                }
                for (h = 0; h < t.length; h++) {
                    if ((m) && (!y) && ((t[h].timestamp - e) > 120000)) {
                        t[h].selected = true;
                        y = true
                    }
                    A.options[h] = new Option(t[h].expiry, t[h].timestamp, t[h].selected, t[h].selected);
                    if (t[h].timestamp == "") {
                        A.options[h].setAttribute("disabled", "disabled")
                    }
                }
                C.selectExpiry(L.data.instrumentID, Ext.fly(H).getValue(), Registry.chartConfig.leftToRight * 1 && E && (D != E || u != A.options.length))
            }
        })
    },
    isValidExpiry: function(a, e) {
        a *= 1;
        e *= 1;
        var d;
        var g = this.time;
        var c;
        var f;
        var b;
        if (a === 1) {
            b = Registry.expiries.expiry_high_low
        } else {
            b = Registry.expiries.expiry_sixty_second
        }
        for (d = 0; d < b.length; d++) {
            c = g - g % (b[d].round * 1000);
            f = c + b[d].expiry * 1000;
            if (e === f && f - g > b[d].deadPeriod * 1000) {
                return true
            }
        }
        return false
    },
    selectShortExpiryOption: function(e, d, h) {
        var c = $("#game-expiry-box-" + e);
        if (!c.length) {
            return
        }
        c.val(d);
        this.selectedShortExpiryOption[e] = h;
        var f = $("#game-short-expiry-options-" + e + " > li");
        f.removeClass("active");
        $("#game-short-expiry-options-" + e + " > .short-expiry-option-" + h).addClass("active");
        var j = this.expiryData[e][d].deadPeriod / 1000;
        if (j * 1 <= 60) {
            j = Registry._["game-type-name-60-sec"].replace("60", j)
        } else {
            j /= 60;
            j += " min"
        }
        $("#game-type-" + e + "-2 > a > strong").html(j);
        var k = $("#game-short-expiry-tooltip-" + e);
        k.html(this.formatExpiry(d));
        var g = $("#game-short-expiry-options-" + e).width();
        k.css("margin-left", -g + "px");
        k.width(g);
        var b = $("#game-short-expiry-tooltip-arrow-" + e);
        var a = -g + $("#game-short-expiry-options-" + e + " .short-expiry-option-" + h).offset().left - $("#game-short-expiry-options-" + e + " .short-expiry-option-0").offset().left - (12 - $("#game-short-expiry-options-" + e + " .short-expiry-option-" + h).width()) / 2;
        b.css("margin-left", a);
        this.selectExpiry(e + "", d, false)
    },
    isWeekendOptionEnabled: function(a) {
        if (Registry.weekendGames.indexOf(a.data.instrumentID) == -1) {
            return false
        }
        var b = false;
        var c = this.time;
        a.tradingHours().each(function(d) {
            if (d.data.gameType == "7") {
                d.tradingHourRanges().each(function(e) {
                    var g = e.data.from;
                    var f = e.data.to;
                    if (c > g && c <= f) {
                        b = true
                    }
                })
            }
        });
        return b
    },
    selectExpiry: function(f, d, k) {
        var h = Trading.app.getController("Game");
        var r = this.getGameType(f);
        var m;
        if (r == 1 || r == 11) {
            if (Registry.longTermOptionExpiryTimestamps.indexOf(d * 1) > -1) {
                m = 11
            } else {
                m = 1
            }
            if (r != m) {
                r = m;
                this.setGameType(f, r, true)
            }
        }
        this.selectedExpiries[f] = d;
        var o = false;
        var c;
        var e;
        if (h.expiryData[f] && h.expiryData[f][d]) {
            o = true;
            c = d - h.expiryData[f][d].expiry;
            e = d - h.expiryData[f][d].deadPeriod
        }
        if (o && this.time >= c && this.time < e) {
            if (this.progressUpdates[f]) {
                delete this.progressUpdates[f]
            }
            Ext.fly("progress-bar-text-" + f + "-top").dom.innerHTML = "";
            Ext.fly("progress-bar-text-" + f + "-bottom").dom.innerHTML = "";
            Ext.fly("progress-bar-" + f + "-value").setWidth(0);
            Ext.fly("closing-progress-bar-container-" + f).removeCls("x-hidden");
            if (Ext.fly("time-to-trade-label-" + f)) {
                Ext.fly("time-to-trade-label-" + f).removeCls("x-hidden")
            }
            this.progressUpdates[f] = {
                from: c,
                to: e
            };
            this.updateProgress();
            Ext.getDom("game-" + f).setAttribute("enabled", "true")
        } else {
            Ext.fly("closing-progress-bar-container-" + f).addCls("x-hidden");
            if (Ext.fly("time-to-trade-label-" + f)) {
                Ext.fly("time-to-trade-label-" + f).addCls("x-hidden")
            }
            delete this.progressUpdates[f];
            if (this.getGameType(f) != "7" && this.getGameType(f) != "11") {
                Ext.getDom("game-" + f).setAttribute("enabled", "false")
            } else {
                Ext.getDom("game-" + f).setAttribute("enabled", "true")
            }
        }
        if (Ext.fly("invoice-" + f).dom.getAttribute("data-active") == "true") {
            if (Ext.fly("game-" + f).dom.getAttribute("data-expiry") != d) {
                this.showInvoice(f)
            }
        }
        if (this.selectedGameTemplate === "financial") {
            var l = null;
            this.instruments.getById(f).payouts().each(function(s) {
                if (r == s.data.gameType) {
                    l = s.data.payout + "-" + s.data.rebate
                }
            });
            this.selectPayout(f, l)
        } else {
            var j = Ext.get("payouts-" + f).dom;
            var a = j.selectedIndex;
            var q = j.options[j.selectedIndex].value;
            var b = j.options[a].value;
            var n = -1;
            var p = -1;
            while (j.options.length) {
                j.options.remove(0)
            }
            this.instruments.getById(f).payouts().each(function(s) {
                if (r == s.data.gameType) {
                    s.payoutRanges().each(function(t) {
                        j.options.add(new Option(t.data.payout + "% / " + t.data.rebate + "%", t.data.payout + "-" + t.data.rebate));
                        if (s.data.payout == t.data.payout && s.data.rebate == t.data.rebate) {
                            p = t.data.payout + "-" + t.data.rebate
                        }
                    })
                }
            });
            if (j.options.length && j.options.length > a && q == j.options[a].value) {
                j.selectedIndex = a
            } else {
                var g;
                for (g = 0; g < j.options.length; g++) {
                    if (b == j.options[g].value) {
                        n = g;
                        break
                    }
                }
                if (n > -1) {
                    j.selectedIndex = n
                } else {
                    for (g = 0; g < j.options.length; g++) {
                        if (p == j.options[g].value) {
                            n = g;
                            break
                        }
                    }
                    j.selectedIndex = n
                }
            }
            this.selectPayout(f, j.options[j.selectedIndex].value)
        }
        if (k) {
            this.updateChartRange(f)
        }
    },
    updateChartZoomRange: function(b) {
        var d = this.charts[b];
        var f = "chart-series-" + b;
        var c = d.get(f);
        var e = d.get("chart-x-axis-" + b);
        if (!c || !c.data.length) {
            return
        }
        var a = c.data[c.data.length - 1].x;
        if (a - c.data[0].x < (this.zoomLevels[this.zoomLevelIndex] - 5) * 60000) {
            return
        }
        e.setExtremes(a - this.zoomLevels[this.zoomLevelIndex] * 60000, null);
        this.stretchCharts(b);
        this.moveChartIndicator(b);
        this.colorBackground(b);
        d = this.candlestickCharts[b];
        if (!d) {
            return
        }
        f = "advanced-chart-candlestick-series-" + b;
        c = d.get(f);
        e = d.get("advanced-chart-candlestick-x-axis-" + b);
        if (!c || !c.data.length) {
            return
        }
        a = c.data[c.data.length - 1].x;
        e.setExtremes(a - this.zoomLevels[this.zoomLevelIndex] * 60000, null);
        this.stretchCharts(b);
        this.moveChartIndicator(b);
        this.colorBackground(b)
    },
    updateChartRange: function(a) {
        var c = this.charts[a];
        if (!c) {
            return
        }
        var e = c.get("chart-x-axis-" + a);
        e.removePlotLine("chart-dead-period-line-" + a);
        e.removePlotLine("chart-expiry-line-" + a);
        if (Registry.chartConfig.leftToRight * 1 && this.getGameType(a) == 1) {
            var d = "game-expiry-box-" + a;
            var b = Ext.fly(d).getValue() * 1;
            e.addPlotLine({
                id: "chart-dead-period-line-" + a,
                value: b - (10 * 60000),
                color: Registry.chartConfig.colors.guide,
                width: 1,
                dashStyle: "shortdash",
                label: {
                    text: "Time To Invest"
                },
                zIndex: 1
            });
            e.addPlotLine({
                id: "chart-expiry-line-" + a,
                value: b,
                color: Registry.chartConfig.colors.guide,
                width: 1,
                label: {
                    text: "Expiration"
                },
                zIndex: 1
            });
            e.setExtremes(null, b + 10 * 60000)
        } else {
            e.setExtremes(null, null)
        }
    },
    updateProgress: function() {
        var d;
        var l;
        var m;
        var e;
        var b;
        var a;
        var g;
        var j = 148;
        var f;
        var h;
        var c;
        var k;
        for (d in this.progressUpdates) {
            l = this.progressUpdates[d]["from"];
            m = this.progressUpdates[d]["to"];
            g = m - l;
            if (this.time >= l && this.time < m) {
                b = (this.time - l);
                e = (m - this.time) + 1000;
                var n = Ext.fly("progress-bar-" + d);
                if (!n) {
                    return
                }
                j = n.getWidth() - 6;
                a = Math.ceil(b * j / g);
                e = Math.floor(e / 1000);
                c = Math.floor(e / 60);
                if (c < 60) {
                    k = e % 60;
                    if (c < 10) {
                        c = "0" + c
                    }
                    if (k < 10) {
                        k = "0" + k
                    }
                    f = c + ":" + k
                } else {
                    h = Math.floor(c / 60);
                    c = c % 60;
                    if (h < 10) {
                        h = "0" + h
                    }
                    if (c < 10) {
                        c = "0" + c
                    }
                    f = h + ":" + c
                }
                Ext.fly("progress-bar-text-" + d + "-top").dom.innerHTML = f;
                Ext.fly("progress-bar-text-" + d + "-bottom").dom.innerHTML = f;
                Ext.fly("progress-bar-" + d + "-value").setWidth(a)
            } else {
                if (this.time >= m) {
                    delete this.progressUpdates[d]
                }
            }
        }
    },
    drawCandlestickChart: function(c, j, b, a) {
        var g = [];
        var f = {};
        var d = new Date();
        var e = this;
        Ext.Array.each(b,
        function(l) {
            g.push([l[0], l[1], l[2], l[3], l[4]])
        });
        var k = b[b.length - 1][0];
        Ext.Array.each(a,
        function(m) {
            var l = Math.floor((m[0] - 1000) / 60000) * 60000;
            if (l > k) {
                if (!f[l]) {
                    f[l] = []
                }
                f[l].push(m[1])
            }
        });
        Ext.Object.each(f,
        function(q, m) {
            var n = m[0];
            var p = m[m.length - 1];
            var o = Ext.Array.max(m);
            var l = Ext.Array.min(m);
            g.push([q * 1, n, o, l, p])
        });
        var h = new Highcharts.StockChart({
            xAxis: {
                id: "advanced-chart-candlestick-x-axis-" + c,
                gridLineWidth: 1,
                gridLineColor: Registry.chartConfig.colors.axisgrid,
                lineColor: Registry.chartConfig.colors.axis,
                tickLength: 0,
                ordinal: false,
                labels: {
                    formatter: function() {
                        d.setTime(this.value);
                        return Ext.Date.format(d, "H:i")
                    }
                }
            },
            yAxis: {
                id: "advanced-chart-candlestick-y-axis-" + c,
                gridLineColor: Registry.chartConfig.colors.axisgrid,
                labels: {
                    formatter: function() {
                        return e.getFixedQuote(c, this.value)
                    }
                }
            },
            chart: {
                renderTo: j + c,
                plotBorderWidth: 1,
                backgroundColor: "rgba(255,255,255,0)"
            },
            rangeSelector: {
                enabled: false
            },
            navigator: {
                enabled: false
            },
            scrollbar: {
                enabled: false
            },
            credits: {
                enabled: false
            },
            series: [{
                name: " ",
                id: "advanced-chart-candlestick-series-" + c,
                type: "candlestick",
                data: g
            }],
            plotOptions: {
                candlestick: {
                    color: Registry.chartConfig.candlestick.colors.down,
                    upColor: Registry.chartConfig.candlestick.colors.up,
                    lineColor: Registry.chartConfig.candlestick.colors.line,
                    dataGrouping: {
                        enabled: false
                    }
                },
                series: {
                    states: {
                        hover: {
                            lineWidth: 1
                        }
                    }
                }
            },
            tooltip: {
                headerFormat: "<span>{point.key}</span><br/>",
                xDateFormat: "%H:%M",
                pointFormat: "<span>{point.y}</span>",
                borderWidth: 1,
                borderColor: Registry.chartConfig.colors.line,
                crosshairs: [{
                    color: Registry.chartConfig.colors.guide,
                    dashStyle: "longdash"
                }]
            }
        });
        return h
    },
    addPointToCandlestickChart: function(d, c, h, f) {
        c.get("advanced-chart-candlestick-y-axis-" + d).removePlotLine("advanced-chart-candlestick-guide-" + d);
        c.get("advanced-chart-candlestick-y-axis-" + d).addPlotLine({
            id: "advanced-chart-candlestick-guide-" + d,
            value: f,
            color: Registry.chartConfig.colors.guide,
            width: 1,
            dashStyle: "longdash"
        });
        var g = Math.floor((h - 1000) / 60000) * 60000;
        var e = c.get("advanced-chart-candlestick-series-" + d);
        var a;
        var b = false;
        if (e.data.length) {
            b = ((h - e.data[0].x) > 3600000)
        }
        if ((g === this.currentMinute) && e.data.length) {
            a = e.data[e.data.length - 1];
            a.close = f;
            if (f > a.high) {
                a.high = f
            }
            if (f < a.low) {
                a.low = f
            }
            e.data[e.data.length - 1].update(a)
        } else {
            this.currentMinute = g;
            a = {
                x: g * 1,
                open: f,
                high: f,
                low: f,
                close: f
            };
            e.addPoint(a, true, b)
        }
    },
    renderCharts: function(b) {
        this.chartsRendered = false;
        this.charts = {};
        this.candlestickCharts = {};
        var a = [];
        Ext.each(b,
        function(c) {
            if (c.data.isOpen) {
                a.push(c.data.instrumentID)
            }
        });
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/instrument/history",
            method: "GET",
            params: {
                instruments: Ext.encode(a)
            },
            success: function(c) {
                c = Ext.decode(c.responseText);
                var d = Trading.app.getController("Game");
                d.drawCharts(b, c);
                d.startChartUpdater();
                if (Registry.socialSite) {
                    d.startSocialObserver()
                }
                d.chartsRendered = true;
                c = null;
                d = null
            }
        })
    },
    drawCharts: function(h, d) {
        var f = new Date();
        var b = "";
        var g = {};
        var e = Registry.chartConfig.colors.line;
        if (Registry.chartConfig.colors.fillColor.top && Registry.chartConfig.colors.fillColor.bottom) {
            b = "areaspline";
            g = {
                linearGradient: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 1
                },
                stops: [[0, Registry.chartConfig.colors.fillColor.top], [1, Registry.chartConfig.colors.fillColor.bottom]]
            }
        }
        var a = Registry.chartConfig.colors.axisLabel ? {
            color: Registry.chartConfig.colors.axisLabel
        }: {};
        var c;
        if (Registry.chartConfig.colors.plotBackgroundGradient.top && Registry.chartConfig.colors.plotBackgroundGradient.bottom) {
            c = {
                linearGradient: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 1
                },
                stops: [[0, Registry.chartConfig.colors.plotBackgroundGradient.top], [1, Registry.chartConfig.colors.plotBackgroundGradient.bottom]]
            }
        } else {
            c = Registry.chartConfig.colors.plotBackground
        }
        Ext.each(h,
        function(w) {
            var r = Trading.app.getController("Game");
            var k;
            var t;
            var o = [];
            var p;
            var q;
            var v;
            if (w.data.isOpen) {
                q = w.data.instrumentID;
                var s = r.isWeekendOptionEnabled(w);
                if (s) {
                    r.zoomLevels = r.weekendZoomLevels;
                    r.zoomLevelIndex = 1;
                    if (d[q].length > 10) {
                        for (p = d[q].length - 1; p > 0 && d[q][p][1] === d[q][p - 1][1]; p--) {}
                        d[q] = d[q].slice(0, p + 1);
                        for (p = d[q].length - 1; p > 0 && d[q][d[q].length - 1][0] - d[q][p][0] < 7200000; p--) {}
                        d[q] = d[q].slice(p)
                    }
                    v = d[q][d[q].length - 1][1];
                    w.data.last = v;
                    $("#game-" + q).attr("data-spot", v);
                    r.updateFormattedSpot(q);
                    var j = Ext.query(".spot-" + q);
                    for (p = 0; p < j.length; p++) {
                        Ext.fly(j[p]).dom.innerHTML = r.getFixedQuote(q, v)
                    }
                } else {
                    r.zoomLevels = r.regularZoomLevels
                }
                k = "chart-wrapper-" + w.data.instrumentID;
                for (p = 0; (d[w.data.instrumentID]) && (p < d[w.data.instrumentID].length); p++) {
                    if (! (p % 5) || !(d[w.data.instrumentID][p][0] % 60000)) {
                        o.push(d[w.data.instrumentID][p])
                    }
                }
                t = new Highcharts.StockChart({
                    xAxis: {
                        id: "chart-x-axis-" + w.data.instrumentID,
                        gridLineWidth: 1,
                        gridLineColor: Registry.chartConfig.colors.axisgrid,
                        lineColor: Registry.chartConfig.colors.axis,
                        tickLength: 0,
                        ordinal: false,
                        labels: {
                            formatter: function() {
                                f.setTime(this.value);
                                var y = "H:i";
                                var x = this.axis.series[0].data;
                                if (x.length && (x[x.length - 1].x - x[0].x < (5 * 60000))) {
                                    y = "H:i:s"
                                }
                                return Ext.Date.format(f, y)
                            },
                            style: a
                        }
                    },
                    yAxis: {
                        id: "chart-y-axis-" + w.data.instrumentID,
                        gridLineColor: Registry.chartConfig.colors.axisgrid,
                        labels: {
                            formatter: function() {
                                return r.getFixedQuote(q, this.value)
                            },
                            style: a
                        }
                    },
                    chart: {
                        renderTo: k,
                        plotBorderColor: Registry.chartConfig.colors.plotBorder,
                        plotBorderWidth: 1,
                        backgroundColor: "rgba(255,255,255,0)",
                        plotBackgroundColor: c
                    },
                    rangeSelector: {
                        enabled: false
                    },
                    navigator: {
                        enabled: false
                    },
                    scrollbar: {
                        enabled: false
                    },
                    credits: {
                        enabled: false
                    },
                    series: [{
                        id: "chart-series-" + w.data.instrumentID,
                        name: "Price",
                        data: o,
                        type: b,
                        threshold: null,
                        fillColor: g
                    }],
                    plotOptions: {
                        line: {
                            lineWidth: 1,
                            color: Registry.chartConfig.colors.line,
                            dataGrouping: {
                                enabled: false
                            },
                            allowPointSelect: false,
                            marker: {
                                states: {
                                    hover: {
                                        radius: 2
                                    }
                                }
                            },
                            events: {
                                click: function(x) {
                                    Trading.app.getController("Game").selectClosestTradePoint(x.point)
                                }
                            }
                        },
                        areaspline: {
                            lineWidth: 1,
                            color: Registry.chartConfig.colors.line,
                            dataGrouping: {
                                enabled: false
                            },
                            allowPointSelect: false,
                            marker: {
                                states: {
                                    hover: {
                                        radius: 2
                                    }
                                }
                            },
                            events: {
                                click: function(x) {
                                    Trading.app.getController("Game").selectClosestTradePoint(x.point)
                                }
                            }
                        },
                        series: {
                            color: e,
                            states: {
                                hover: {
                                    lineWidth: 1,
                                    color: Registry.chartConfig.colors.line
                                }
                            }
                        }
                    },
                    tooltip: {
                        headerFormat: "<span>{point.key}</span><br/>",
                        xDateFormat: "%H:%M:%S",
                        pointFormat: "<span>{point.y}</span>",
                        borderWidth: 1,
                        crosshairs: [{
                            color: Registry.chartConfig.colors.guide,
                            dashStyle: "longdash"
                        }],
                        formatter: function() {
                            var D = this.points[0].point;
                            var C = "<span>" + Ext.Date.format(new Date(D.x), "H:i:s") + "</span><br/><span>" + D.y + "</span>";
                            if (D.marker && D.marker.keep) {
                                var B = (D.tooltipData.direction == 1) ? Registry._["label-above"] : Registry._["label-below"];
                                C = '<span class="tooltip-label">' + Registry._["game-label-expiry"] + ":</span><span> " + Ext.Date.format(new Date(D.tooltipData.expiry), "H:i:s") + '</span><br/><span class="tooltip-label">' + B + " " + D.y + '</span><br/><span class="tooltip-label">' + Registry._["trade-info-investment"] + ":</span><span> " + Trading.app.getController("Game").getUserCurrencyInfo().currencySymbol + D.tooltipData.stake + '</span><br/><span class="tooltip-label">' + Registry._["trade-info-payout"] + ":</span><span> " + D.tooltipData.payout + '%</span><br/><span class="tooltip-label">' + Registry._["label-rebate"] + ":</span><span> " + D.tooltipData.rebate + "%</span>";
                                C += Ext.isEmpty(D.tooltipData.returnedAmount) ? "": '<br/><span class="tooltip-label">' + Registry._["label-return-amount"] + ":</span><span> " + Registry.baseCurrencySymbol + D.tooltipData.returnedAmount + "</span>";
                                if (D.tooltipData.social) {
                                    var F = D.tooltipData.social.userID;
                                    var x = Registry.socialImageUrlPattern.replace("[[[userID]]]", F) + "?v=" + Math.floor(new Date().getTime() / 10000);
                                    var z = D.tooltipData.social.nickname;
                                    var A = (D.tooltipData.direction == 1) ? "images/small-green-arrow-up-10x11.png": "images/small-red-arrow-down-10x11.png";
                                    var B = (D.tooltipData.direction == 1) ? Registry._["short-text-call"] : Registry._["short-text-put"];
                                    var y = Ext.isEmpty(D.tooltipData.returnedAmount) ? Registry._["short-text-opened"] : Registry._["short-text-closed"];
                                    var E = Ext.isEmpty(D.tooltipData.returnedAmount) ? "": '<br/><span class="tooltip-gain">' + Registry._["short-text-gain"] + ": " + Registry.baseCurrencySymbol + D.tooltipData.returnedAmount + "</span>";
                                    C = '<div id="tooltip-social-container"><div class="social-user-img-container"><img class="social-user-img" src="' + x + '" /><img class="social-user-arrow-img" src="' + A + '">&nbsp;</img></div><div class="advanced-social-trade-info"><span class="tooltip-nickname">' + z + ((Registry.env == "development") ? " (" + D.tooltipData.tradeID + ") ": "") + '</span><br/><span class="tooltip-status">' + y + " " + Registry._["short-text-a-binary"] + " " + B + " " + Registry._["short-text-option"] + "</span>" + E + "</div></div>"
                                }
                            }
                            return '<div class="tooltip-container">' + C + "</div>"
                        },
                        useHTML: true
                    }
                });
                if (s) {
                    var l = "chart-series-" + q;
                    var n = t.get(l);
                    var u = {
                        x: n.data[n.data.length - 1].x,
                        y: n.data[n.data.length - 1].y,
                        marker: {
                            enabled: true,
                            fillColor: Registry.chartConfig.colors.line,
                            lineColor: Registry.chartConfig.colors.guide,
                            lineWidth: 1,
                            keep: false
                        }
                    };
                    n.data[n.data.length - 1].update(u)
                }
                r.charts[q] = t;
                if (r.selectedGameTemplate === "financial") {
                    var m = o;
                    Ext.Ajax.request({
                        url: Registry.uriBase + "/ajax/instrument/history",
                        method: "GET",
                        params: {
                            instruments: Ext.encode([q]),
                            candlesticks: 1
                        },
                        success: function(x) {
                            x = Ext.decode(x.responseText);
                            r.candlestickCharts[q] = r.drawCandlestickChart(q, "chart-candlestick-wrapper-", x[q], m);
                            r.updateChartZoomRange(q);
                            if (r.selectedChartType === "line") {
                                r.showFinancialViewLineChart()
                            } else {
                                r.showFinancialViewCandleStickChart()
                            }
                            m = null
                        }
                    })
                } else {
                    r.updateChartRange(q)
                }
                r.markTrades(q, o);
                o = null;
                t = null
            }
        });
        h = null;
        d = null
    },
    moveChartIndicator: function(c) {
        if (! (Registry.chartConfig.indicator * 1) || !this.charts[c] || !$("#game-" + c).attr("data-spot")) {
            return
        }
        var f = this.charts[c];
        var g = "chart-series-" + c;
        var d = f.get(g);
        var e = d.data[d.data.length - 1].y;
        if (this.selectedGameTemplate === "financial" && this.selectedChartType === "candlestick" && this.candlestickCharts[c]) {
            f = this.candlestickCharts[c];
            g = "advanced-chart-candlestick-series-" + c
        }
        d = f.get(g);
        if (!d.data.length) {
            return
        }
        var b = (e - f.axes[1].min) / (f.axes[1].max - f.axes[1].min) * f.plotHeight;
        var a = f.plotTop + f.plotHeight - b;
        var h = $("#chart-indicator-" + c);
        if (this.selectedGameTemplate == "financial") {
            if (a < 40) {
                h.addClass("chart-indicator-bottom")
            } else {
                h.removeClass("chart-indicator-bottom")
            }
        }
        h.css("top", a + "px");
        h.html(this.getFixedQuote(c, $("#game-" + c).attr("data-spot")));
        h.css("display", "block")
    },
    stretchCharts: function(a) {
        var b = this.charts[a];
        var c = "chart-series-" + a;
        this.stretchChart(b, c);
        if (this.candlestickCharts[a]) {
            b = this.candlestickCharts[a];
            c = "advanced-chart-candlestick-series-" + a;
            this.stretchCandlestickChart(b, c)
        }
    },
    stretchChart: function(h, b) {
        var d = h.get(b);
        if (!d.data.length) {
            return
        }
        var c = d.data[0].y;
        var j = d.data[0].y;
        var g;
        var e;
        var a = d.data[d.data.length - 1].x;
        var f = a - this.zoomLevels[this.zoomLevelIndex] * 60000;
        for (e = d.data.length - 1; e > 0 && d.data[e].x >= f; e--) {
            g = d.data[e].y;
            if (g < c) {
                c = g
            }
            if (g > j) {
                j = g
            }
        }
        h.axes[1].setExtremes(c, j)
    },
    stretchCandlestickChart: function(f, h) {
        var d = f.get(h);
        if (!d.data.length) {
            return
        }
        var g = d.data[0].low;
        var e = d.data[0].high;
        var c;
        var b = d.data[d.data.length - 1].x;
        var a = b - this.zoomLevels[this.zoomLevelIndex] * 60000;
        for (c = d.data.length - 1; c > 0 && d.data[c].x >= a; c--) {
            if (d.data[c].low < g) {
                g = d.data[c].low
            }
            if (d.data[c].high > e) {
                e = d.data[c].high
            }
        }
        f.axes[1].setExtremes(g, e)
    },
    selectClosestTradePoint: function(a) {
        return;
        var f = a.series.chart;
        var h;
        var g;
        var e;
        var d = null;
        var b;
        var c = 90000;
        if (f.tradesMarkers) {
            for (g in f.tradesMarkers) {
                h = f.tradesMarkers[g];
                e = Math.abs(a.x - h.x);
                if ((d == null) || e < d) {
                    d = e;
                    b = h
                }
            }
            if (b && d < c) {
                if (!b.selected) {
                    f.tooltip.refresh([b])
                }
            } else {}
        }
    },
    startSocialObserver: function() {
        if (!Trading.app.getController("User").loggedIn) {
            return
        }
        var b = 30000;
        if (Registry.socialObserver) {
            Ext.TaskManager.stop(Registry.socialObserver)
        } else {
            Registry.socialObserver = {
                run: function() {
                    var g = Trading.app.getController("Game");
                    var f = g.getGames();
                    var e;
                    var c = [];
                    var d;
                    Ext.each(f,
                    function(h) {
                        if (h.data.isOpen) {
                            e = h.data.last;
                            if (e > 0 && (Registry.socialInstruments.indexOf(h.data.instrumentID) != -1)) {
                                c.push(h.data.instrumentID);
                                d = Ext.WindowMgr.get("advanced-chart-window-" + h.data.instrumentID);
                                if (d) {
                                    d.updateSocialEntryTimes()
                                }
                                g.updateSocialEntryTimes()
                            }
                        }
                    });
                    if (!Ext.isEmpty(c)) {
                        Ext.Ajax.request({
                            url: Registry.uriBase + "/ajax/instrument/social-positions",
                            method: "GET",
                            params: {
                                instrumentIDs: Ext.encode(c)
                            },
                            success: function(h) {
                                var n = Trading.app.getController("Game");
                                var j;
                                var l;
                                var k;
                                var m;
                                h = Ext.decode(h.responseText);
                                if ($.isEmptyObject(h)) {
                                    Registry.socialSite = false;
                                    Ext.TaskManager.stop(Registry.socialObserver);
                                    return
                                }
                                for (j in h) {
                                    m = h[j];
                                    l = n.charts[j];
                                    k = (l) ? l.get("chart-series-" + j) : null;
                                    if (k && k.data.length) {
                                        n.markSocialTrades(j, k.data, m)
                                    }
                                }
                                h = null;
                                n = null
                            }
                        })
                    }
                },
                interval: b
            }
        }
        var a = new Ext.util.DelayedTask(function() {
            Ext.TaskManager.start(Registry.socialObserver)
        });
        a.delay(b)
    },
    startChartUpdater: function() {
        var c;
        var b = 15000;
        if (Registry.chartUpdater) {
            Ext.TaskManager.stop(Registry.chartUpdater)
        } else {
            Registry.chartUpdater = {
                run: function() {
                    Trading.app.getController("Instrument").instruments.each(function(p) {
                        var k = Trading.app.getController("Game");
                        var l = k.isWeekendOptionEnabled(p);
                        if (l) {
                            return
                        }
                        var j;
                        var m;
                        var o;
                        j = p.data.instrumentID;
                        o = p.data.last;
                        m = k.charts[j];
                        if (o > 0) {
                            if (m) {
                                var f = "chart-series-" + j;
                                var h;
                                var n;
                                var e;
                                h = m.get(f);
                                if (h.data.length) {
                                    n = h.data[h.data.length - 1];
                                    if (n.marker && !n.marker.keep) {
                                        n.marker = {
                                            enabled: false
                                        };
                                        h.data[h.data.length - 1].update(n)
                                    }
                                    n = {
                                        x: k.time,
                                        y: o * 1,
                                        marker: {
                                            enabled: true,
                                            fillColor: Registry.chartConfig.colors.line,
                                            lineColor: Registry.chartConfig.colors.guide,
                                            lineWidth: 1,
                                            keep: false
                                        }
                                    };
                                    e = (!(Registry.chartConfig.leftToRight * 1 && k.getGameType(j) == 1) && (k.time - h.data[0].x) > 3600000);
                                    h.addPoint(n, true, e);
                                    k.colorBackground(j);
                                    var d = Ext.query(".game .spot-" + j);
                                    var g;
                                    for (g = 0; g < d.length; g++) {
                                        if (Ext.fly(d[g]).hasCls("highlight")) {
                                            Ext.fly(d[g]).highlight()
                                        }
                                    }
                                    k.moveChartIndicator(j);
                                    if (k.selectedGameTemplate === "financial") {
                                        k.updateChartZoomRange(j)
                                    }
                                }
                            }
                        }
                    })
                },
                interval: b
            }
        }
        var a = new Ext.util.DelayedTask(function() {
            Ext.TaskManager.start(Registry.chartUpdater)
        });
        a.delay(2000)
    },
    disableGame: function(a) {
        var b = "game-container-" + a;
        Ext.fly(b).addCls("disabled");
        Ext.fly(b).dom.setAttribute("data-disabled", "1");
        this.hideInvoice(a);
        this.hideConfirmation(a)
    },
    formatExpiry: function(d) {
        this.dateHelperExpiry.setTime(this.time);
        var c = this.dateHelperExpiry.getDate();
        var g = this.dateHelperExpiry.getMonth();
        this.dateHelperExpiry.setTime(d);
        var a = this.dateHelperExpiry.getDate();
        var f = this.dateHelperExpiry.getMonth();
        if ((a == c || a == c + 1) && (g == f)) {
            var b = (a == c) ? Registry._.today: Registry._.tomorrow;
            var e = Ext.Date.format(this.dateHelperExpiry, "H:i");
            return b + " " + e
        } else {
            switch (f) {
            case 0:
                g = Registry._.January;
                break;
            case 1:
                g = Registry._.February;
                break;
            case 2:
                g = Registry._.March;
                break;
            case 3:
                g = Registry._.April;
                break;
            case 4:
                g = Registry._.May;
                break;
            case 5:
                g = Registry._.June;
                break;
            case 6:
                g = Registry._.July;
                break;
            case 7:
                g = Registry._.August;
                break;
            case 8:
                g = Registry._.September;
                break;
            case 9:
                g = Registry._.October;
                break;
            case 10:
                g = Registry._.November;
                break;
            case 11:
                g = Registry._.December;
                break
            }
            return g + Ext.Date.format(this.dateHelperExpiry, " d, H:i")
        }
    },
    renderPagination: function() {
        var a = [];
        var b;
        if (this.numOfPages > 1) {
            for (b = 1; b <= this.numOfPages; b++) {
                a.push({
                    label: b,
                    page: b,
                    pressed: (b == this.page)
                })
            }
            if (this.page > 1) {
                Ext.Array.insert(a, 0, [{
                    label: "<",
                    page: (this.page - 1),
                    pressed: false
                }])
            }
            if (this.page < this.numOfPages) {
                a.push({
                    label: ">",
                    page: (this.page + 1),
                    pressed: false
                })
            }
        }
        this.tplPagination.overwrite("pagination-wrapper", a)
    },
    setTime: function(d, e, c) {
        this.time = d;
        if (Registry.customIndexView) {
            if (typeof(FX1) != "undefined") {
                FX1.setTime(d, e)
            }
            return
        }
        this.updateProgress();
        FinancialPanel.updateProgress();
        if (e || c) {
            this.renderGamesLite();
            FinancialPanel.updateExpirySelect();
            Trading.app.getController("User").updateDoubleUpButtonStatuses();
            var b = new Date(this.time);
            if (! ((Ext.Date.format(b, "i") * 1) % 7)) {
                var a = new Ext.util.DelayedTask(function() {
                    Trading.app.getController("Game").downloadSentiment()
                });
                a.delay(20000)
            }
        }
    },
    calcNumOfPages: function() {
        this.numOfPages = Math.floor((this.instruments.count() - 1) / this.pageSize) + 1;
        if (this.page > this.numOfPages) {
            this.page = this.numOfPages
        }
    },
    loadPage: function(b) {
        var a = this;
        scroll(0, 0);
        a.page = b;
        a.render()
    },
    filter: function(a, b) {
        this.currentFilter = a;
        if (this.instruments) {
            this.instruments.clearFilter()
        }
        if (a) {
            var c = (Ext.isArray(a)) ? a: [{
                property: a,
                value: true
            }];
            this.instruments.filter(c)
        }
        if (!b) {
            this.page = 1
        }
        this.render()
    },
    selectInstrumentByName: function(b) {
        $("#filter-search-input").val(b);
        var a = Trading.app.getController("Filter");
        a.search();
        $("html, body").animate({
            scrollTop: $("#game-filter").offset().top
        },
        "fast")
    },
    star: function(a) {
        var d = (Ext.Array.contains(Registry.starred, a)) ? "unstar": "star";
        var c = this.instruments.getById(a);
        if (!Trading.app.getController("User").forceLogin()) {
            return
        }
        if (d == "star") {
            Registry.starred.push(a);
            Ext.fly("instrument-name-" + a).addCls("starred")
        } else {
            Ext.Array.remove(Registry.starred, a);
            Ext.fly("instrument-name-" + a).removeCls("starred")
        }
        c.data.starred = (d == "star");
        if (d != "star") {
            if (this.currentFilter == "starred") {
                if (this.selectedGameTemplate == "financial" && !Registry.starred.length) {
                    var b = Trading.app.getController("Filter");
                    b.setFilter("featured")
                } else {
                    this.filter("starred", true)
                }
            }
        }
        User.star(a, (d == "unstar"))
    },
    direction: function(a, b) {
        if (Ext.getDom("game-" + a)) {
            Ext.getDom("game-" + a).setAttribute("data-direction", b)
        }
        this.setChartBackground(a, b);
        if ($("#confirmation-message-" + a).css("display") !== "none") {
            return
        }
        this.showInvoice(a)
    },
    setChartBackground: function(a, d, c) {
        var b = this.charts[a];
        if (c) {
            if (Ext.fly("invoice-" + a).dom.getAttribute("data-active") == "true") {
                return
            }
        }
        if (b) {
            this.charts[a].colorBackgroundDirection = d;
            this.colorBackground(a)
        }
    },
    colorBackground: function(e) {
        var j = this.charts[e].colorBackgroundDirection;
        if ((Ext.fly("chart-top-bg-" + e)) && (Ext.fly("chart-bottom-bg-" + e))) {
            if (j) {
                var g = this.charts[e];
                var c = "chart-series-" + e;
                var d = g.get(c);
                var k = d.data[d.data.length - 1].y;
                if (this.selectedGameTemplate === "financial" && this.selectedChartType === "candlestick" && this.candlestickCharts[e]) {
                    g = this.candlestickCharts[e];
                    c = "advanced-chart-candlestick-series-" + e
                }
                if (d.data[d.data.length - 1]) {
                    var b = (k - g.axes[1].min) / (g.axes[1].max - g.axes[1].min) * g.plotHeight;
                    var h = g.plotHeight - b;
                    var f = h - 5;
                    var a = g.plotTop - 15;
                    if (j == -1) {
                        Ext.fly("chart-top-bg-" + e).removeCls("active");
                        Ext.fly("chart-bottom-bg-" + e).addCls("active");
                        Ext.get("chart-bottom-bg-" + e).setStyle("height", b + "px");
                        Ext.get("chart-bottom-bg-" + e).setStyle("top", f + "px")
                    } else {
                        Ext.fly("chart-bottom-bg-" + e).removeCls("active");
                        Ext.fly("chart-top-bg-" + e).addCls("active");
                        Ext.get("chart-top-bg-" + e).setStyle("height", h + "px");
                        Ext.get("chart-top-bg-" + e).setStyle("top", a + "px")
                    }
                }
            } else {
                Ext.fly("chart-top-bg-" + e).removeCls("active");
                Ext.fly("chart-bottom-bg-" + e).removeCls("active")
            }
        }
    },
    expand: function(b, c) {
        c = (c) ? "-" + c: "";
        var e = "show-more" + c + "-" + b;
        var a = "more" + c + "-" + b;
        var d = {
            duration: 200,
            useDisplay: true,
            easing: "ease"
        };
        if (Ext.fly(e).hasCls("expanded")) {
            Ext.fly(e).removeCls("expanded");
            Ext.get(a).slideOut("t", d)
        } else {
            Ext.each(Ext.query("#show-more-container-" + b + " .show-more.expanded"),
            function(f) {
                Ext.fly(f.id).removeCls("expanded");
                Ext.get(f.id.replace("show-", "")).slideOut("t", d)
            });
            Ext.fly(e).addCls("expanded");
            Ext.get(a).slideIn("t", d)
        }
    },
    updateSocialEntryTimes: function() {
        var a = this;
        Ext.each(Ext.query(".activity-entry .entry-time"),
        function(b) {
            var c = b.getAttribute("data-timestamp") * 1;
            Ext.fly(b.id).update(a.tplActivityEntry.formatTime(c))
        })
    },
    updateSocialActivityViewer: function(c, k) {
        var d = this;
        var j;
        var a;
        var e;
        var f;
        var g = 3;
        var h = 4;
        var b = 1500;
        if (!Registry.socialActivityDelays) {
            Registry.socialActivityDelays = {}
        }
        if (!Registry.socialActivityDelays[c]) {
            Registry.socialActivityDelays[c] = 0
        }
        for (e in k) {
            j = k[e];
            for (f in j) {
                a = j[f];
                a.instrumentID = c;
                a.eventType = e;
                a.eventID = Ext.id();
                new Ext.util.DelayedTask(function(l) {
                    var n = l.event;
                    d.addActivityEntry(n);
                    Registry.socialActivityDelays[n.instrumentID] -= b;
                    var m = Ext.getDom("activity-panel-" + n.instrumentID);
                    if (m) {
                        if (m.childNodes.length > h) {
                            Ext.get(m).last().remove()
                        }
                        if (m.childNodes.length > g) {
                            Ext.fly(m).addCls("scroll")
                        } else {
                            Ext.fly(m).removeCls("scroll")
                        }
                    }
                },
                null, [{
                    event: Ext.clone(a)
                }]).delay(Registry.socialActivityDelays[c]);
                Registry.socialActivityDelays[c] += b
            }
        }
    },
    addActivityEntry: function(c) {
        var a = Ext.fly("activity-panel-" + c.instrumentID);
        if (a) {
            var b;
            switch (this.selectedGameTemplate) {
            case "regular":
                b = this.tplActivityEntry;
                break;
            case "small":
                b = this.tplSmallActivityEntry;
                break
            }
            if (a.hasCls("empty")) {
                b.overwrite("activity-panel-" + c.instrumentID, c);
                a.removeCls("empty")
            } else {
                b.insertFirst("activity-panel-" + c.instrumentID, c)
            }
        }
    },
    selectPayout: function(d, b, a) {
        var h = b.split("-");
        var f = Ext.getDom("game-" + d);
        var c = Ext.get("payout-" + d);
        if (f) {
            f.setAttribute("data-payout", h[0]);
            f.setAttribute("data-rebate", h[1])
        }
        var e = this.formatPayout(h[0]);
        if (c) {
            c.dom.innerHTML = e;
            if (!a) {
                c.show({
                    duration: 1000,
                    useDisplay: true,
                    easing: "ease"
                })
            }
        }
        var g = Ext.fly("invoice-" + d);
        if (g && g.dom.getAttribute("data-active") == "true") {
            this.showInvoice(d)
        }
    },
    formatPayout: function(b) {
        var a;
        b = parseInt(b);
        switch (Registry.payoutDisplay) {
        case 1:
            a = this.getUserCurrencyInfo().currencySymbol + new Number(1 + b / 100).toFixed(2);
            break;
        case 2:
            a = b + "%";
            break;
        case 3:
            a = (100 + b) + "%";
            break
        }
        return a
    },
    showInvoice: function(j) {
        if (this.locked[j]) {
            return
        }
        if (Ext.fly("game-container-" + j).dom.getAttribute("data-disabled")) {
            this.showError(j, "Instrument is currently not tradable", true);
            return
        }
        var d = this.selectedExpiries[j];
        var f = Ext.get("invoice-" + j);
        var o = Ext.getDom("game-" + j);
        if (!o) {
            return
        }
        var e = {
            duration: 1000,
            useDisplay: true,
            easing: "ease"
        };
        var h = {
            direction: o.getAttribute("data-direction"),
            payout: o.getAttribute("data-payout"),
            formattedPayout: this.formatPayout(o.getAttribute("data-payout")),
            rebate: o.getAttribute("data-rebate"),
            expiry: d,
            instrumentID: j,
            last: this.getFixedQuote(j, this.instruments.getById(j).data.last)
        };
        this.hideConfirmation(j);
        Ext.fly("payout-wrapper-" + j).addCls("x-hidden");
        Ext.fly("game-" + j).dom.setAttribute("data-expiry", d);
        var n = Ext.fly("investment-amount-" + j);
        var c;
        if (n) {
            c = n.dom.value
        }
        f.dom.innerHTML = this.tplInvoice.apply(h);
        if (Ext.getDom("game-" + j).getAttribute("enabled") == "true") {
            $("#apply-" + j).removeClass("disabled")
        } else {
            $("#apply-" + j).addClass("disabled")
        }
        $("#investment-amount-" + j).combobox([]);
        var a = [];
        var m;
        var b = Registry.investmentLimits.minStake * 1;
        var p = Registry.investmentLimits.maxStake * 1;
        if (this.getGameType(j) == "2") {
            b = Registry.investmentLimits.minStake60sec * 1;
            p = Registry.investmentLimits.maxStake60sec * 1
        } else {
            if (this.getGameType(j) == "7") {
                b = Registry.investmentLimits.minStakeWeekend * 1;
                p = Registry.investmentLimits.maxStakeWeekend * 1
            } else {
                if (this.getGameType(j) == "11") {
                    b = Registry.investmentLimits.minStakeLongTerm * 1;
                    p = Registry.investmentLimits.maxStakeLongTerm * 1
                }
            }
        }
        this.instrumentInvestmentLimits[j] = {
            minStake: b,
            maxStake: p
        };
        var g;
        var l;
        for (g = 0; g < Registry.investmentOptions.length; g++) {
            m = Registry.investmentOptions[g] * 1;
            l = m * this.getUserCurrencyInfo().conversionRate;
            if (l >= b && l <= p) {
                a.push(m + "")
            }
        }
        $.combobox.instances["investment-amount-" + j].setSelectOptions(a);
        var k;
        if (n && c >= b && c <= p) {
            k = c
        } else {
            if (this.getGameType(j) === "2") {
                k = Registry.investmentDefaults.sixtySeconds
            } else {
                k = Registry.investmentDefaults.highLow
            }
        }
        if (k * this.getUserCurrencyInfo().conversionRate < b) {
            k = a[0]
        }
        Ext.fly("investment-amount-" + j).dom.value = k;
        this.setReturnAmount(j, parseInt(o.getAttribute("data-payout")), parseInt(o.getAttribute("data-rebate")));
        f.dom.setAttribute("data-active", "true");
        f.setVisibilityMode(Ext.Element.DISPLAY);
        f.show(e);
        Ext.fly("invoice-" + j).removeCls("x-hidden")
    },
    hideInvoice: function(a, b) {
        var c = Ext.get("invoice-" + a);
        this.setChartBackground(a, false);
        if (c) {
            c.dom.setAttribute("data-active", "false");
            c.setVisibilityMode(Ext.Element.DISPLAY);
            c.hide();
            Ext.fly("invoice-" + a).addCls("x-hidden")
        }
        if (b) {
            Ext.fly("payout-wrapper-" + a).addCls("x-hidden")
        } else {
            Ext.fly("payout-wrapper-" + a).removeCls("x-hidden")
        }
    },
    trade: function(instrumentID, params, isDoubleUp, tradeID) {
        if (Ext.getDom("game-" + instrumentID).getAttribute("enabled") == "false") {
            return
        }
        var game;
        if (!Trading.app.getController("User").forceLogin()) {
            return
        }
        if (this.locked[instrumentID]) {
            return
        }
        if (Registry.questionaryRequired == 1) {
            this.showError(instrumentID, Registry._["questionary-required"] + '<a class="questionary-button"' + Registry.questionnaireTargetUrl + 'href="' + Registry.questionnaireUrl + '">' + Registry._["questionary-required-button"] + "</a>", false);
            return
        }
        this.locked[instrumentID] = true;
        if (!isDoubleUp) {
            Ext.fly("loader-" + instrumentID).addCls("loading");
            Ext.fly("invoice-spot-" + instrumentID).removeCls("spot-" + instrumentID);
            Ext.fly("invoice-spot-" + instrumentID).removeCls("trend-up");
            Ext.fly("invoice-spot-" + instrumentID).removeCls("trend-down")
        } else {
            $("#trade-entry-info-loading-" + tradeID).addClass("loading").removeClass("x-hidden")
        }
        if (!params) {
            game = Ext.get("game-" + instrumentID).dom;
            params = {};
            params.instrumentID = instrumentID;
            params.payout = game.getAttribute("data-payout") * 1;
            params.rebate = game.getAttribute("data-rebate") * 1;
            params.direction = game.getAttribute("data-direction") * 1;
            params.expiry = game.getAttribute("data-expiry") * 1;
            params.stake = Math.round(Ext.fly("investment-amount-" + instrumentID).getValue() * this.getUserCurrencyInfo().conversionRate);
            params.userCurrency = Registry.userCurrency;
            params.userCurrencyStake = Ext.fly("investment-amount-" + instrumentID).getValue();
            params.strike = Ext.fly("invoice-spot-" + instrumentID).dom.innerHTML;
            params.gameType = this.getGameType(instrumentID);
            params.practice = this.practiceMode
        }
        if (typeof params.source === "undefined") {
            params.source = "Simplified Platform"
        }
        if (!this.verifyTrade(params, isDoubleUp)) {
            return
        }
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/user/trade",
            scope: this,
            params: params,
            success: function(response, options) {
                delete this.locked[instrumentID];
                response = Ext.decode(response.responseText);
                var params = options.params;
                if (isDoubleUp) {
                    $("#trade-entry-info-loading-" + tradeID).addClass("x-hidden").removeClass("loading")
                }
                if (response.success) {
                    tradeID = tradeID ? tradeID: response.tradeID;
                    this.showConfirmation(instrumentID, isDoubleUp, tradeID, response.allowTimedCancel);
                    var trade = Ext.create("Trading.model.Trade", {
                        tradeID: response.tradeID,
                        type: params.gameType,
                        instrumentID: params.instrumentID,
                        timestamp: response.timestamp,
                        expiry: params.expiry,
                        stake: params.stake,
                        userCurrency: params.userCurrency,
                        userCurrencyStake: params.userCurrencyStake,
                        strike: params.strike,
                        direction: params.direction,
                        payout: params.payout,
                        rebate: params.rebate,
                        status: 1,
                        allowClosePosition: response.allowClosePosition
                    });
                    Trading.app.getController("User").trade(trade);
                    var instrumentController = Trading.app.getController("Instrument");
                    var instrument = instrumentController.instruments.getById(instrumentID);
                    var isWeekendOptionActive = this.isWeekendOptionEnabled(instrument);
                    if (!isWeekendOptionActive) {
                        this.addTradeMarker(instrumentID, response.tradeID)
                    }
                } else {
                    if (response.details) {
                        this.processTradeErrorDetails(response.details)
                    }
                    this.showError(params.instrumentID, response.message, false, isDoubleUp, tradeID)
                }
            },
            failure: function(response) {
                delete this.locked[instrumentID];
                if (isDoubleUp) {
                    $("#trade-entry-info-loading-" + tradeID).addClass("x-hidden").removeClass("loading")
                }
                this.showError(instrumentID, Registry._["trading-error-network"], false, isDoubleUp, tradeID);
                eval(response.responseText)
            }
        })
    },
    processTradeErrorDetails: function(a) {
        if (a.frozen && Registry.frozenUrl.length) {
            var c = "frozen-window";
            var b = Ext.WindowMgr.get(c);
            if (!b) {
                b = new Ext.Window({
                    id: c,
                    title: Registry._["account-frozen-title"],
                    width: 655,
                    height: 600,
                    layout: "fit",
                    resizable: true,
                    items: [{
                        xtype: "component",
                        autoEl: {
                            tag: "iframe",
                            src: Registry.frozenUrl
                        }
                    }]
                })
            }
            b.show()
        }
    },
    verifyTrade: function(d, e) {
        var c = false;
        if (! (d.strike * 1)) {
            c = true;
            this.showError(d.instrumentID, Registry._["invalid-strike"])
        }
        d.stake *= 1;
        if (!e) {
            var a = this.instrumentInvestmentLimits[d.instrumentID].minStake;
            var b = this.instrumentInvestmentLimits[d.instrumentID].maxStake;
            if (d.stake < a) {
                c = true;
                this.showError(d.instrumentID, Registry._["min-trade"] + ": " + this.getUserCurrencyInfo().currencySymbol + Ext.util.Format.number(a / this.getUserCurrencyInfo().conversionRate, "0,000.00"))
            }
            if (d.stake > b) {
                c = true;
                this.showError(d.instrumentID, Registry._["max-trade"] + ": " + this.getUserCurrencyInfo().currencySymbol + Ext.util.Format.number(b / this.getUserCurrencyInfo().conversionRate, "0,000.00"))
            }
        }
        if (d.stake > Registry.wallet.credit) {
            c = true;
            this.showError(d.instrumentID, Registry._["deposit-required"])
        }
        return ! c
    },
    showConfirmation: function(a, f, h, g) {
        var j;
        if (f) {
            j = Ext.get("trade-entry-confirmation-message-" + h)
        } else {
            j = Ext.get("confirmation-message-" + a)
        }
        var b = '<div class="message-icon"></div><div class="message-title">' + Registry._["trading-message-trade-accepted"] + "</div>";
        if (!f) {
            this.hideInvoice(a, true)
        }
        var c = this;
        if (g && !f) {
            b += '<div class="message-body"><a id="cancel-trade-button' + h + '" class="button cancel-trade-button" href="#" onclick="Trading.app.getController(\'Game\').cancelTrade(\'' + a + "'," + h + '); return false;">' + Registry._.Cancel + ' <span id="cancel-timer-' + h + '">' + Registry.cancelTradePeriod + '</span></a><span class="loadable" id="cancel-loader-' + h + '">&nbsp;</span><div class="message-container evaluation-message" style="display: none;" id="response-message-' + h + '"></div></div>';
            var d = new Utils.countdown({
                seconds: parseInt(Registry.cancelTradePeriod),
                onUpdateStatus: function(l) {
                    var k = Ext.get("cancel-timer-" + h);
                    if (!k) {
                        d.stop()
                    } else {
                        Utils.cancelTradeCountdownProgress(k, l)
                    }
                },
                onCounterEnd: function() {
                    var k = Ext.get("cancel-timer-" + h);
                    var l = Ext.get("cancel-trade-button" + h);
                    if (l && k) {
                        l.addCls("disabled");
                        l.set({
                            onClick: "return false"
                        });
                        c.hideConfirmation(a, true, false, f, h, true)
                    }
                }
            });
            d.start()
        } else {
            this.hideConfirmation(a, true, false, f, h);
            var e = function() {
                j.un("click", e);
                c.hideConfirmation(a, false, true, f, h)
            };
            j.on("click", e)
        }
        j.setVisibilityMode(Ext.Element.DISPLAY);
        j.dom.innerHTML = b;
        j.addCls(g && !f ? "confirmation-and-cancel": "");
        j.show()
    },
    hideConfirmation: function(e, b, a, g, j, h) {
        var k;
        if (g) {
            k = Ext.get("trade-entry-confirmation-message-" + j)
        } else {
            k = Ext.get("confirmation-message-" + e)
        }
        var d = {
            duration: 1000,
            useDisplay: true,
            easing: "ease",
            listeners: {
                scope: this,
                afteranimate: function() {
                    delete this.locked[e];
                    var l = Ext.fly("invoice-" + e);
                    if (!g && l.dom.getAttribute("data-active") !== "true") {
                        Ext.fly("payout-wrapper-" + e).removeCls("x-hidden")
                    }
                }
            }
        };
        k.removeCls("trade-error");
        k.setVisibilityMode(Ext.Element.DISPLAY);
        var f = this;
        if (b) {
            var c = new Ext.util.DelayedTask(function() {
                if (g) {
                    delete f.tradeHideConfirmationTasks[j]
                } else {
                    delete f.instrumentHideConfirmationTasks[e]
                }
                k.hide(d)
            });
            if (!h) {
                c.delay(2500)
            } else {
                c.delay(0)
            }
            if (g) {
                this.tradeHideConfirmationTasks[j] = c
            } else {
                this.instrumentHideConfirmationTasks[e] = c
            }
        } else {
            k.hide();
            if (g) {
                if (this.tradeHideConfirmationTasks[j]) {
                    this.tradeHideConfirmationTasks[j].cancel();
                    delete this.tradeHideConfirmationTasks[j]
                }
            } else {
                if (this.instrumentHideConfirmationTasks[e]) {
                    this.instrumentHideConfirmationTasks[e].cancel();
                    delete this.instrumentHideConfirmationTasks[e]
                }
            }
            if (a && !g) {
                Ext.fly("payout-wrapper-" + e).removeCls("x-hidden")
            }
        }
    },
    cancelTrade: function(c, d, b) {
        Ext.get("cancel-timer-" + d).remove();
        Ext.get("cancel-trade-button" + d).addCls("disabled");
        Ext.get("cancel-trade-button" + d).set({
            onClick: "return false"
        });
        Ext.get("cancel-loader-" + d).addCls("loading");
        var a = this;
        Ext.Ajax.request({
            url: Registry.uriBase + "/ajax/user/cancel-trade-timed",
            scope: this,
            params: {
                id: d
            },
            success: function(f, g) {
                f = Ext.decode(f.responseText);
                if (f.success) {
                    if (b) {
                        $("#fp-confirmation-message .message-title").html(Registry._["cancelled-successfully"]);
                        $("#fp-confirmation-message .message-body").hide();
                        setTimeout(function() {
                            $("#fp-confirmation-message").fadeOut(500,
                            function() {
                                $("#fp-confirmation-message .message-title").removeClass("centered")
                            })
                        },
                        3000)
                    } else {
                        var j = Ext.get("confirmation-message-" + c);
                        var h = '<div class="message-icon"></div><div class="message-title">' + Registry._["cancelled-successfully"] + "</div>";
                        j.dom.innerHTML = h;
                        var k = function() {
                            j.un("click", k);
                            e.cancel();
                            a.hideConfirmation(c, false, true, null, d)
                        };
                        j.on("click", k);
                        a.hideConfirmation(c, true, false, null, d);
                        var e = new Ext.util.DelayedTask(function() {
                            j.un("click", k)
                        });
                        e.delay(2500)
                    }
                    new Ext.util.DelayedTask(Trading.app.getController("User").onPerformOperationSuccess, null, [{
                        tradeID: d,
                        status: "at",
                        timestamp: null,
                        estimatedReturn: null,
                        isCanceled: true
                    }]).delay(500);
                    Ext.fly("trade-" + d + "-close-position").hide();
                    Ext.fly("trade-" + d + "-double-up").hide();
                    Ext.fly("trade-" + d + "-hedge").hide();
                    if (Ext.fly("fp-trade-entry-indicator-" + d)) {
                        setTimeout(function() {
                            Ext.fly("fp-trade-entry-indicator-" + d).removeCls("trade-entry-indicator");
                            Ext.fly("fp-trade-entry-indicator-" + d).dom.innerHTML = "<span>Canceled</span>";
                            Ext.fly("fp-trade-entry-indicator-" + d).show()
                        },
                        500)
                    }
                } else {
                    if (b) {
                        $("#fp-confirmation-message .message-title").html(f.message.body);
                        $("#fp-confirmation-message .message-icon").hide();
                        $("#fp-confirmation-message .message-body").hide();
                        setTimeout(function() {
                            $("#fp-confirmation-message").fadeOut(500,
                            function() {
                                $("#fp-confirmation-message .message-title").removeClass("centered")
                            })
                        },
                        3000)
                    } else {
                        this.showError(c, f.message.body, false, false, d)
                    }
                }
            },
            failure: function() {}
        })
    },
    showError: function(e, b, a, h, f) {
        var c = this;
        if (h) {
            message = Ext.get("trade-entry-confirmation-message-" + f)
        } else {
            message = Ext.get("confirmation-message-" + e)
        }
        if (!h) {
            this.hideInvoice(e, true)
        }
        message.setVisibilityMode(Ext.Element.DISPLAY);
        message.dom.innerHTML = '<div class="error-message">' + b + "</div>";
        message.addCls("trade-error");
        message.show();
        var d = new Ext.util.DelayedTask(function() {
            delete c.locked[e];
            message.un("click", g);
            if (a || h) {
                c.hideConfirmation(e, true, true, h, f)
            } else {
                c.showInvoice(e)
            }
        });
        d.delay(5000);
        var g = function() {
            message.un("click", g);
            d.delay(0)
        };
        message.on("click", g)
    },
    quote: function(v, e, c, p, h, t) {
        var m = Trading.app.getController("Instrument");
        var u = m.instruments.getById(v);
        var b = this.isWeekendOptionEnabled(u);
        if (b) {
            return
        }
        e = e * 1;
        u.data.last = e;
        var l = "";
        var s = Registry.chartConfig.colors.line;
        var r = "chart-series-" + v;
        var f;
        var g = -1;
        if (p == 1) {
            l = "trend-up";
            s = Registry.chartConfig.colors.up
        } else {
            if (p == -1) {
                l = "trend-down";
                s = Registry.chartConfig.colors.down
            }
        }
        $("#game-" + v).attr("data-spot", e);
        this.updateFormattedSpot(v);
        $(".spot-trend-" + v).removeClass("trend-up trend-down").addClass(l);
        var j = Ext.query(".spot-" + v);
        var q;
        for (q = 0; q < j.length; q++) {
            Ext.fly(j[q]).dom.innerHTML = this.getFixedQuote(v, e);
            if (l) {
                Ext.fly(j[q]).removeCls(["trend-up", "trend-down"]);
                Ext.fly(j[q]).addCls(l)
            }
            if (Ext.fly(j[q]).hasCls("highlight")) {
                Ext.fly(j[q]).highlight()
            }
        }
        var k = this.charts[v];
        if (!k) {
            return
        }
        f = k.get(r);
        if (f.data.length && f.data[f.data.length - 1].marker.keep) {
            g = f.data[f.data.length - 1].tooltipData.tradeID
        }
        var a = Ext.WindowMgr.get("advanced-chart-window-" + v);
        if (a) {
            a.quote(c, e, p, g)
        }
        if (this.selectedGameTemplate == "financial") {
            var n = this.candlestickCharts[v];
            this.addPointToCandlestickChart(v, n, c, e);
            this.updateChartZoomRange(v)
        }
        this.stretchCharts(v);
        this.moveChartIndicator(v);
        if (this.lastQuotes[v] && (c - this.lastQuotes[v] < Registry.chartUpdateFrequency)) {
            var d = $("#chart-indicator-" + v);
            d.html(this.getFixedQuote(v, e));
            return
        }
        this.lastQuotes[v] = c;
        if (k) {
            var o = {
                x: c,
                y: e,
                marker: {
                    enabled: true,
                    fillColor: s,
                    lineColor: Registry.chartConfig.colors.guide,
                    lineWidth: 1,
                    keep: false
                }
            };
            if (f.data.length) {
                if (!f.data[f.data.length - 1].marker.keep) {
                    f.data[f.data.length - 1].update(o)
                } else {
                    if (c > f.data[f.data.length - 1].x) {
                        f.addPoint(o)
                    }
                }
            } else {
                f.addPoint(o)
            }
            this.colorBackground(v);
            k.get("chart-y-axis-" + v).removePlotLine("chart-guide-" + v);
            k.get("chart-y-axis-" + v).addPlotLine({
                id: "chart-guide-" + v,
                value: e,
                color: Registry.chartConfig.colors.guide,
                width: 1,
                dashStyle: "longdash"
            })
        }
        this.stretchCharts(v);
        this.moveChartIndicator(v);
        if (this.showGameInfo) {
            h = h ? this.getFixedQuote(v, h) : "-";
            t = t ? this.getFixedQuote(v, t) : "-";
            $("#ask-" + v).html(h);
            $("#fp-ask-" + v).html(h);
            $("#bid-" + v).html(t);
            $("#fp-bid-" + v).html(t)
        }
    },
    refreshPayouts: function() {
        var k = this;
        var c = this.getGames();
        var h;
        var f;
        var e;
        var a;
        var l;
        var m;
        var g;
        var j;
        var b;
        var o;
        var n;
        var d;
        Ext.each(c,
        function(p) {
            if (p.data.isOpen) {
                o = k.getGameType(p.data.instrumentID);
                n = o;
                if (n * 1 == 7) {
                    return
                }
                a = false;
                e = Ext.get("payouts-" + p.data.instrumentID).getValue().split("-");
                if (e.length == 2) {
                    p.payouts().each(function(r) {
                        if (r.data.gameType == n) {
                            d = r
                        }
                    });
                    l = d.payoutRanges().findBy(function(r) {
                        return ((r.data.payout == e[0]) && (r.data.rebate == e[1]))
                    });
                    if (l > -1) {
                        a = true
                    }
                }
                h = [];
                m = "";
                p.payouts().each(function(r) {
                    if (r.data.gameType == n) {
                        r.payoutRanges().each(function(s) {
                            f = false;
                            if (a) {
                                f = ((s.data.payout == e[0]) && (s.data.rebate == e[1]))
                            } else {
                                f = (s.data.payout == p.data.payout)
                            }
                            h.push({
                                payout: s.data.payout,
                                rebate: s.data.rebate,
                                selected: f
                            });
                            if (f) {
                                m = s.data.payout + "-" + s.data.rebate
                            }
                        })
                    }
                });
                if (m == "") {
                    if (h.length) {
                        j = h[0];
                        j.selected = true;
                        m = j.payout + "-" + j.rebate
                    }
                }
                var q = Ext.get("payouts-" + p.data.instrumentID).dom;
                q.options.length = 0;
                for (g = 0; g < h.length; g++) {
                    j = h[g];
                    b = new Option(j.payout + "% / " + j.rebate + "%", j.payout + "-" + j.rebate, j.selected);
                    b.setAttribute("hidden", "");
                    q.options[g] = b;
                    if (j.selected) {
                        q.selectedIndex = g
                    }
                }
                if (m) {
                    k.selectPayout(p.data.instrumentID, m)
                }
            }
        })
    },
    downloadSentiment: function() {
        var f = 1;
        var a = this;
        var d = this.time - (this.time % 60000);
        var b = new Date(d);
        var c = Ext.Date.format(b, "i") * 1;
        var e = (c % f);
        d = d - (e * 60000);
        Ext.data.JsonP.request({
            url: Registry.cdn + "/sentiment/" + (d / 1000) + ".json",
            callbackName: "sentiment",
            scope: this,
            success: function(g) {
                if (g) {
                    a.sentiment = g;
                    a.renderSentiment()
                }
            }
        })
    },
    renderSentiment: function() {
        if (!this.sentiment) {
            this.downloadSentiment();
            return
        }
        var b = this;
        var c;
        var f = this.getGames();
        var a;
        var e;
        var d;
        if (this.selectedGameTemplate == "financial") {
            d = this.tplFinancialViewSentiment
        } else {
            d = this.tplSentiment
        }
        Ext.each(f,
        function(g) {
            c = g.data.instrumentID;
            if (Ext.fly("game-extended-info-" + c)) {
                a = 50;
                e = 50;
                if (b.sentiment[c]) {
                    a = b.sentiment[c]["call"];
                    e = b.sentiment[c]["put"]
                }
                d.overwrite("game-extended-info-" + c, {
                    instrumentID: c,
                    above: a,
                    below: e
                })
            }
        })
    },
    hasAdvancedGamesEnabled: function(a) {
        var b = (Registry.advancedGamesConfig.game_above_below.indexOf(a) != -1 || Registry.advancedGamesConfig.game_range.indexOf(a) != -1 || Registry.advancedGamesConfig.game_touch.indexOf(a) != -1 || Registry.advancedGamesConfig.game_no_touch.indexOf(a) != -1);
        return (b && Registry.financialPanelEnabled)
    },
    hasAdvancedGames: function(a) {
        var f = this.hasAdvancedGamesEnabled(a);
        var d = Trading.app.getController("Instrument");
        var c = d.instruments.getById(a);
        var e = d.time;
        var b = false;
        c.tradingHours().each(function(g) {
            if (g.data.gameType < 3 || g.data.gameType > 6) {
                return
            }
            if (FinancialPanel.isOpenInConfig(g.data.gameType, a)) {
                g.tradingHourRanges().each(function(h) {
                    if (e > h.data.from && e <= h.data.to) {
                        b = true
                    }
                })
            }
        });
        return (f && b)
    },
    renderGameTypesMenu: function(e) {
        var b = this;
        var c = Trading.app.getController("Instrument").instruments.getById(e);
        var a = Trading.app.getController("Game").isWeekendOptionEnabled(c);
        var d;
        if (a) {
            d = {
                instrumentID: e,
                defaultGameType: 7,
                gameTypes: [{
                    name: Registry._["game-type-name-weekend-option"],
                    type: 7,
                    enabled: true
                }]
            }
        } else {
            d = {
                instrumentID: e,
                defaultGameType: b.getDefaultGameType(e),
                gameTypes: [{
                    name: Registry._["game-type-name-high-low"],
                    type: 1,
                    enabled: true
                }]
            };
            if (Registry.shortGames.indexOf(e) != -1) {
                d.gameTypes.push({
                    name: Registry._["game-type-name-60-sec"],
                    type: 2,
                    enabled: true
                })
            }
            if (b.hasAdvancedGamesEnabled(e)) {
                d.gameTypes.push({
                    name: Registry._["financial-panel-name"],
                    type: 3,
                    enabled: true
                })
            }
        }
        if (b.selectedGameTemplate == "regular") {
            return b.tplGameTypesMenu.apply(d)
        } else {
            if (b.selectedGameTemplate == "small") {
                return b.tplSmallGameTypesMenu.apply(d)
            } else {
                return b.tplGameTypesMenu.apply(d)
            }
        }
    },
    renderInstrumentInfo: function(a) {
        return this.tplInstrumentInfo.apply(a)
    },
    renderAskBidInfo: function(a) {
        return this.tplAskBidInfo.apply(a)
    },
    initTemplates: function() {
        var a = this;
        this.tplSentiment = new Ext.XTemplate('<div class="sentiment-header">' + Registry._["sentiment-traders-choice"] + "</div>", '<div class="cf">', '<span class="sentiment-label-above">' + Registry._["label-above"] + "</span>", '<div class="sentiment-bar cf">', '<div class="sentiment-bar-above" id="sentiment-bar-above-{instrumentID}" style="width: {above}%; overflow: hidden;">{above}%</div>', '<div class="sentiment-bar-below" id="sentiment-bar-below-{instrumentID}" style="width: {below}%; overflow: hidden;">{below}%</div>', "</div>", '<span class="sentiment-label-below">' + Registry._["label-below"] + "</span>", "</div>");
        this.tplFinancialViewSentiment = new Ext.XTemplate('<div class="sentiment-header">' + Registry._["sentiment-traders-choice"] + "</div>", '<div class="big-game-sentiment-container cf">', '<div class="sentiment-bar cf">', '<div class="sentiment-bar-above" id="sentiment-bar-above-{instrumentID}" style="width: {above}%; overflow: hidden;">{above}%</div>', '<div class="sentiment-bar-below" id="sentiment-bar-below-{instrumentID}" style="width: {below}%; overflow: hidden;">{below}%</div>', "</div>", "<br>", '<span class="sentiment-label-above">' + Registry._["label-above"] + "</span>", '<span class="sentiment-label-below">' + Registry._["label-below"] + "</span>", "</div>");
        this.tplPayouts = new Ext.XTemplate('<tpl for=".">', '<option value="{payout}-{rebate}" {[(values.selected) ? "selected=selected" : ""]}>{payout}% / {rebate}%</option>', "</tpl>");
        this.tplMore = new Ext.XTemplate('<table class="more-options">', "<tr>", "<td>" + Registry._.riskometer + ":</td>", '<td><select id="payouts-{instrumentID}" class="change-payout-box" onchange="Trading.app.getController(\'Game\').selectPayout(\'{instrumentID}\', this.value)">{[this.renderPayouts(values)]}</select></td>', '<td><div class="risk-o-meter-help" onclick="Trading.app.getController(\'User\').showRiskOMeterHelp(); return false;">&nbsp;</div></td>', "</tr>", "</table>", '<div class="game-extended-info" id="game-extended-info-{instrumentID}"></div>', {
            renderPayouts: function(c) {
                var d = [];
                var b = a.getDefaultGameType(c.instrumentID);
                a.instruments.getById(c.instrumentID).payouts().each(function(e) {
                    if (b == e.data.gameType) {
                        e.payoutRanges().each(function(f) {
                            d.push({
                                payout: f.data.payout,
                                rebate: f.data.rebate,
                                selected: (f.data.payout == e.data.payout)
                            })
                        })
                    }
                });
                return a.tplPayouts.apply(d)
            }
        });
        this.tplActivityEntryFunctions = {
            setPublicImage: function(b) {
                return Registry.socialImageUrlPattern.replace("[[[userID]]]", b) + "?v=" + Math.floor(new Date().getTime() / 10000)
            },
            formatTime: function(f) {
                var e = new Date();
                var d = new Date(f);
                var g = 60 * 1000;
                var j = g * 60;
                var h = j * 24;
                var c = h * 30;
                var b = h * 365;
                var l = e - d;
                var k;
                if (l < g) {
                    k = Math.round(l / 1000);
                    return (k > 1) ? k + " seconds ago": k + " second ago"
                } else {
                    if (l < j) {
                        k = Math.round(l / g);
                        return (k > 1) ? k + " minutes ago": k + " minute ago"
                    } else {
                        if (l < h) {
                            k = Math.round(l / j);
                            return (k > 1) ? k + " hours ago": k + " hour ago"
                        } else {
                            if (l < c) {
                                return "approximately " + Math.round(l / h) + " days ago"
                            } else {
                                if (l < b) {
                                    return "approximately " + Math.round(l / c) + " months ago"
                                } else {
                                    return "approximately " + Math.round(l / b) + " years ago"
                                }
                            }
                        }
                    }
                }
            },
            formatEventDesc: function(d) {
                var f = Registry.socialActivityEventTypes;
                var h;
                var c = 10;
                var g;
                var b;
                var e;
                switch (d.eventType) {
                case f.openPosition:
                    g = a.instruments.getById(d.instrumentID + "");
                    e = (d.direction * 1 == 1) ? "Call": "Put";
                    h = Registry._["activity-event-open-position"].replace("[[[option-name]]]", "<b>" + g.data.name + "</b>").replace("[[[option-type]]]", ' <span class="' + e.toLowerCase() + '">Binary ' + e + "</span>").replace("[[[expiry]]]", ' <span class="' + e.toLowerCase() + '">' + (d.strike * 1) + "</span>");
                    break;
                case f.closePosition:
                    b = Trading.app.getController("Game").getTradeStatus({
                        data: d
                    });
                    h = '<span class="gain">' + Registry._["activity-event-close-position"].replace("[[[amount]]]", (b.payoff).toFixed(2)) + "</span>";
                    break;
                case f.topDayPnl:
                    h = Registry._["activity-event-top-day-pnl"];
                    break;
                case f.topDayPnlFirst:
                    h = Registry._["activity-event-top-day-pnl-first"];
                    break;
                case f.topDayWinRatio:
                    h = Registry._["activity-event-top-day-win-ratio"];
                    break;
                case f.topDayWinRatioFirst:
                    h = Registry._["activity-event-top-day-win-ratio-first"];
                    break;
                case f.topWeekPnl:
                    h = Registry._["activity-event-top-week-pnl"];
                    break;
                case f.topWeekPnlFirst:
                    h = Registry._["activity-event-top-week-pnl-first"];
                    break;
                case f.topWeekWinRatio:
                    h = Registry._["activity-event-top-week-win-ratio"];
                    break;
                case f.topWeekWinRatioFirst:
                    h = Registry._["activity-event-top-week-win-ratio-first"];
                    break;
                case f.likedTrade:
                    h = Registry._["activity-event-like-trade"];
                    break;
                default:
                    h = d.eventType
                }
                h = h.replace("[[[nickname]]]", "<b>" + d.nickname + "</b>").replace("[[[limit]]]", c);
                return h
            }
        };
        this.tplActivityEntry = new Ext.XTemplate('<li id="activity-entry-{eventID}" class="activity-entry trade-entry">', '<div class="social-user-img-container">', '<img id="advanced-social-trade-img-{eventID}" class="social-user-img" src="{userID:this.setPublicImage}" />', '<img class="social-user-arrow-img {[(values.direction) ? "" : "x-hidden"]}" src=\'{[(values.direction == 1) ? "images/small-green-arrow-up-10x11.png" : "images/small-red-arrow-down-10x11.png"]}\' />', "</div>", '<div class="activity-entry-info-container">', "<span>{[this.formatEventDesc(values)]}</span>", "<br>", '<span id="activity-entry-time-{eventID}" class="entry-time" data-timestamp="{timestamp}">{timestamp:this.formatTime}</span>', "</div>", '<a href="#" class="activity-entry-extend-link" onclick="Trading.app.getController(\'Game\').showAdvancedChart(\'{instrumentID}\'); return false;">{[((values.eventType == Registry.socialActivityEventTypes.openPosition) || (values.eventType == Registry.socialActivityEventTypes.closePosition)) ? "View on chart" : ""]}</a>', "</li>", this.tplActivityEntryFunctions);
        this.tplSmallActivityEntry = new Ext.XTemplate('<li id="activity-entry-{eventID}" class="small-activity-entry trade-entry">', '<div class="social-user-img-container">', '<img id="advanced-social-trade-img-{eventID}" class="social-user-img" src="{userID:this.setPublicImage}" />', '<img class="social-user-arrow-img {[(values.direction) ? "" : "x-hidden"]}" src=\'{[(values.direction == 1) ? "images/small-green-arrow-up-10x11.png" : "images/small-red-arrow-down-10x11.png"]}\' />', "</div>", '<div class="small-activity-entry-info-container">', "<span>{[this.formatEventDesc(values)]}</span>", "<br>", '<span id="activity-entry-time-{eventID}" class="entry-time" data-timestamp="{timestamp}">{timestamp:this.formatTime}</span>', '<a href="#" class="small-activity-entry-extend-link" onclick="Trading.app.getController(\'Game\').showAdvancedChart(\'{instrumentID}\'); return false;">{[((values.eventType == Registry.socialActivityEventTypes.openPosition) || (values.eventType == Registry.socialActivityEventTypes.closePosition)) ? "View on chart" : ""]}</a>', "</div>", "</li>", this.tplActivityEntryFunctions);
        this.tplActivity = new Ext.XTemplate('<ul id="activity-panel-{instrumentID}" class="activity-panel empty {[Registry["socialUser"] ? "" : "x-hidden"]}" >', '<li class="loading-activity">', "<span>Loading Social Activity</span>", '<span class="loadable loading">&nbsp;</span>', "</li>", "</ul>", '<div class="activity-panel-enable-social-container {[Registry["socialUser"] ? "x-hidden" : ""]}">', '<div class="advanced-chart-social-enable-mask"></div>', '<div class="advanced-chart-social-enable-msg">', '<a href="' + Registry.socialUrl + '" onclick="return Trading.app.getController(\'User\').forceLogin();">' + Registry._["social-settings-enable-social"] + "</a> " + Registry._["social-enable-social-activity"], "</div>", "</div>", {});
        this.SmalltplActivity = new Ext.XTemplate('<ul id="activity-panel-{instrumentID}" class="small-activity-panel empty {[Registry["socialUser"] ? "" : "x-hidden"]}" >', '<li class="loading-activity">', "<span>Loading Social Activity</span>", '<span class="loadable loading">&nbsp;</span>', "</li>", "</ul>", '<div class="activity-panel-enable-social-container {[Registry["socialUser"] ? "x-hidden" : ""]}">', '<div class="advanced-chart-social-enable-mask"></div>', '<div class="advanced-chart-social-enable-msg">', '<a href="' + Registry.socialUrl + '" onclick="return Trading.app.getController(\'User\').forceLogin();">' + Registry._["social-settings-enable-social"] + "</a> " + Registry._["social-enable-social-activity"], "</div>", "</div>", {});
        this.tplProgressBar = new Ext.XTemplate('<div id="progress-bar-{instrumentID}" class="x-progress x-progress-default">', '<div class="x-progress-text x-progress-text-back progress-bar-text" id="progress-bar-text-{instrumentID}-bottom"></div>', '<div id="progress-bar-{instrumentID}-value" class="x-progress-bar">', '<div class="x-progress-text" id="progress-bar-text-{instrumentID}-top"></div>', "</div>", "</div>");
        this.tplInvoice = new Ext.XTemplate('<div class="message-container">', "<table>", "<tr><td>" + Registry._["trade-info-to-close"] + ':</td><td><div class="close-button" onclick="Trading.app.getController(\'Game\').hideInvoice(\'{instrumentID}\')"></div>{direction:this.formatDirection} <span id="invoice-spot-{instrumentID}" class="spot-{instrumentID}">{last}</span></td></tr>', "<tr><td>" + Registry._["trade-info-expires"] + ":</td><td>{expiry:this.formatExpiry}</td></tr>", '<tr><td valign="middle">' + Registry._["trade-info-investment"] + ':</td><td><div class="investment-amount-wrapper {[this.longCurrencySymbolClass()]}"><span class="invoice-currency-symbol">{[this.formatCurrencySymbol()]}</span><input type="text" class="investment-amount" id="investment-amount-{instrumentID}" onchange="Utils.validateStake(event, this); Trading.app.getController(\'Game\').setReturnAmount(\'{instrumentID}\', {payout}, {rebate})" onkeyup="Utils.validateStake(event, this); Trading.app.getController(\'Game\').setReturnAmount(\'{instrumentID}\', {payout}, {rebate})" onpaste="Utils.validateStake(event, this); Trading.app.getController(\'Game\').setReturnAmount(\'{instrumentID}\', {payout}, {rebate})" onblur="Utils.validateStake(event, this); Trading.app.getController(\'Game\').setReturnAmount(\'{instrumentID}\', {payout}, {rebate})" /></div></td></tr>', "<tr><td>" + Registry._["in-the-money"] + ':</td><td class="cf"><span id="invoice-payout-{instrumentID}">{formattedPayout}</span></td></tr>', "<tr><td>" + Registry._["out-the-money"] + ':</td><td><span id="invoice-rebate-{instrumentID}">{rebate}%</span></td></tr>', '<tr><td class="apply-wrapper" colspan="2"><a href="#" onclick="Trading.app.getController(\'Game\').trade(\'{instrumentID}\'); return false;" class="button button-trade" id="apply-{instrumentID}">' + Registry._["button-trade"] + '</a><span class="loadable" id="loader-{instrumentID}">&nbsp;</span></td></tr>', "</table>", "</div>", {
            formatExpiry: function(c) {
                var b = new Date(c * 1);
                return Ext.Date.format(b, "d-M H:i")
            },
            formatDirection: function(b) {
                return (b == "-1") ? '<div class="put-small-icon"></div>': '<div class="call-small-icon"></div>'
            },
            formatCurrencySymbol: function() {
                var c = Trading.app.getController("Game");
                var b = c.getUserCurrencyInfo().currencySymbol;
                return b
            },
            longCurrencySymbolClass: function() {
                var c = Trading.app.getController("Game");
                var b = c.getUserCurrencyInfo().currencySymbol;
                return (b.length > 1) ? "long-currency-symbol": ""
            }
        });
        this.tplGameIndicators = new Ext.XTemplate('<ul id="game-indicators-menu-{instrumentID}" class="game-indicators-menu">', '<tpl for="indicators">', '<li id="game-indicator-{parent.instrumentID}-{type}" title="{title}" class="{[(xindex == 1) ? "first" : ""]} {[(xcount == xindex) ? "last" : ""]}">', '<span class="game-indicator-icon {type}">&nbsp;</span>', "<span>{name}</span>", "</li>", "</tpl>", "</ul>");
        this.tplGameTypesMenu = new Ext.XTemplate('<ul id="game-types-menu-{instrumentID}" class="game-types-menu">', '<tpl for="gameTypes">', '<li id="game-type-{parent.instrumentID}-{type}" class="{[(xindex == 1) ? "first" : ""]} {[(xcount == xindex) ? "last" : ""]} {[(parent.defaultGameType == values.type) ? "active" : ""]} {[(values.enabled) ? "" : "disabled"]}" onclick="Trading.app.getController(\'Game\').setGameType(\'{parent.instrumentID}\', {type}, {enabled}); if ({type} != 3) { Ext.select(\'#game-types-menu-{parent.instrumentID} li.active\').first().removeCls(\'active\'); Ext.fly(\'game-type-{parent.instrumentID}-{type}\').addCls(\'active\'); }">', '<a href="#" onclick="return false;">', '<span class="game-type-icon-{type}">&nbsp;</span>', "<strong>{name}</strong>", "</a>", '<tpl if="values.type == 7">', '<div class="game-type-weekend-option-help" onclick="Trading.app.getController(\'User\').showWeekendOptionHelp(); return false;">&nbsp;</div>', "</tpl>", "</li>", "</tpl>", "</ul>");
        this.tplSmallGameTypesMenu = new Ext.XTemplate('<ul id="game-types-menu-{instrumentID}" class="small-game-types-menu">', '<tpl for="gameTypes">', '<li id="game-type-{parent.instrumentID}-{type}" class="{[(xindex == 1) ? "first" : ""]} {[(xcount == xindex) ? "last" : ""]} {[(parent.defaultGameType == values.type) ? "active" : ""]} {[(values.enabled) ? "" : "disabled"]}" onclick="Trading.app.getController(\'Game\').setGameType(\'{parent.instrumentID}\', {type}, {enabled}); if ({type} != 3) { Ext.select(\'#game-types-menu-{parent.instrumentID} li.active\').first().removeCls(\'active\'); Ext.fly(\'game-type-{parent.instrumentID}-{type}\').addCls(\'active\'); }">', '<a href="#" onclick="return false;">', "<strong>{name}</strong>", "</a>", "</li>", "</tpl>", "</ul>");
        this.tplInstrumentInfo = new Ext.XTemplate('<h4><b>{name}{[values.futureExpirationDate ? "-" + values.futureExpirationDate : ""]}</b></h4>', "<p>{[this.htmlEscape(values.description)]}</p>", "<br/>", "<span><b>" + Registry._["expiry-formula"] + ": </b></span>", "<span>{[this.htmlEscape(values.expiry)]}</span>", "<br/>", "<br/>", "<span><b>" + Registry._["feed-source"] + ": </b></span>", "<span>{provider}</span>", {
            htmlEscape: function(b) {
                return Utils.htmlEscape(b)
            }
        });
        this.tplAskBidInfo = new Ext.XTemplate("<h4><b>" + Registry._["strike-rate"] + "</b></h4>", "<p>" + Utils.htmlEscape(Registry._["strike-rate-text"]) + "</p>", "<br/>", "<h4><b>" + Registry._["ask-bid-rates"] + "</b></h4>", "<p>" + Utils.htmlEscape(Registry._["ask-bid-rates-text"]) + "</p>");
        this.gameTemplateFunctions = {
            renderProgressBar: function(b) {
                return a.tplProgressBar.apply(b)
            },
            renderMore: function(b) {
                return a.tplMore.apply(b)
            },
            renderActivity: function(b) {
                if (a.selectedGameTemplate == "regular") {
                    return a.tplActivity.apply(b)
                } else {
                    return a.SmalltplActivity.apply(b)
                }
            },
            renderQuestion: function(b) {
                return Registry._["game-question"].replace("[[[instrument]]]", '<span class="question-instrument-name">' + b + "</span>")
            },
            renderGameTypesMenu: function(b) {
                return a.renderGameTypesMenu(b)
            },
            renderInstrumentInfo: function(b) {
                return a.renderInstrumentInfo(b)
            },
            renderAskBidInfo: function(b) {
                return a.renderAskBidInfo(b)
            },
            renderIndicators: function(b) {
                return a.renderIndicators(b, a.getDefaultGameType(b), false)
            },
            getDefaultGameType: function(b) {
                return a.getDefaultGameType(b)
            },
            formatInstrumentName: function(b) {
                var c = 11;
                if (a.selectedGameTemplate == "financial") {
                    c = 10
                }
                if (b.length <= c) {
                    return b
                } else {
                    return (b.substr(0, c) + "...")
                }
            },
            renderFormattedSpot: function(b, c) {
                return c ? a.formatSpot(b, c) : "-"
            },
            showGameInfo: function() {
                return a.showGameInfo
            }
        };
        this.tplGame = new Ext.XTemplate("<!-- game begins -->", '<div class="game" id="game-{instrumentID}" data-spot="{last}" data-payout="{payout}" data-rebate="{rebate}" data-game-type="{[this.getDefaultGameType(values.instrumentID)]}">', '<div class="cf game-row">', '<a class="instrument-name {[(values.starred) ? "starred" : ""]}" id="instrument-name-{instrumentID}" href="#" onclick="Trading.app.getController(\'Game\').star(\'{instrumentID}\'); return false;" title="{name}">{name:this.formatInstrumentName}</a>', '<tpl if="values.description && this.showGameInfo()">', '<span id="game-info-{instrumentID}" class="game-info-icon instrument-desc"  tooltip-content="{[this.renderInstrumentInfo(values)]}">&nbsp;</span>', "</tpl>", "{[this.renderGameTypesMenu(values.instrumentID)]}", '<select class="game-expiry-box" id="game-expiry-box-{instrumentID}" onchange="Trading.app.getController(\'Game\').selectExpiry(\'{instrumentID}\', this.value, true)"><option value="">xxx</option></select>', '<span class="game-expiry-label" id="game-expiry-label-{instrumentID}">' + Registry._["game-label-expiry"] + ":</span>", '<ul class="game-short-expiry-options" id="game-short-expiry-options-{instrumentID}">', "</ul>", '<div class="game-short-expiry-tooltip" id="game-short-expiry-tooltip-{instrumentID}"></div>', '<div class="game-short-expiry-tooltip-arrow" id="game-short-expiry-tooltip-arrow-{instrumentID}"></div>', "</div>", '<div class="cf game-row game-row-2">', '<span class="game-description"><span class="instrument-icon instrument-icon-{instrumentID}"></span>{name:this.renderQuestion}</span>', '<div class="closing-progress-bar-container x-hidden" id="closing-progress-bar-container-{instrumentID}">{[this.renderProgressBar(values)]}</div>', '<span class="time-to-trade-label x-hidden" id="time-to-trade-label-{instrumentID}">' + Registry._["game-label-time-remaining"] + ":</span>", "</div>", '<div class="cf game-main-content">', '<div class="chart-indicator" id="chart-indicator-{instrumentID}"></div>', '<div class="chart-bg top" id="chart-top-bg-{instrumentID}"></div>', '<div class="chart-bg bottom" id="chart-bottom-bg-{instrumentID}"></div>', '<div class="chart-wrapper" id="chart-wrapper-{instrumentID}"></div>', '<div id="show-more-container-{instrumentID}" class="show-more-container">', '<a href="#" onclick="Trading.app.getController(\'Game\').expand({instrumentID}); return false;" class="show-more" id="show-more-{instrumentID}">', '<span class="show-more-icon">&nbsp;</span>', "<span>" + Registry._.more + "</span>", "</a>", '<a href="#" onclick="Trading.app.getController(\'Game\').expand({instrumentID}, \'activity\'); return false;" class="show-more" style="{[Trading.app.getController("Game").isGameSocial(values.instrumentID) ? "" : "display: none;"]}" id="show-more-activity-{instrumentID}">', '<span class="show-more-icon more-activity">&nbsp;</span>', "<span>" + Registry._.social + "</span>", "</a>", '<a href="#" onclick="Trading.app.getController(\'Game\').showAdvancedChart(\'{instrumentID}\'); return false;" class="show-more" id="show-more-chart-{instrumentID}">', '<span class="show-more-icon more-advanced-chart">&nbsp;</span>', "<span>Chart</span>", "</a>", '<tpl if="this.showGameInfo()">', '<div id="ask-bid-container-{instrumentID}" class="ask-bid-container">', '<span class="game-info-icon ask-bid-desc"  tooltip-content="{[this.renderAskBidInfo(values)]}">&nbsp;</span>', '<div class="ask-bid-value"><span>' + Registry._.Bid + ':</span>&nbsp;<span id="bid-{instrumentID}">-</span></div>', '<div class="ask-bid-value"><span>' + Registry._.Ask + ':</span>&nbsp;<span id="ask-{instrumentID}">-</span></div>', "</div>", "</tpl>", "</div>", '<div class="game-form-wrapper cf">', '<div class="game-form-buttons-wrapper">', "<a href=\"#\" onclick=\"Trading.app.getController('Game').direction('{instrumentID}', 1); return false;\" onmouseover=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', 1, true); return false;\" onmouseout=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', false, true); return false;\" class=\"button button-medium direction-button call\">" + Registry._["label-above"] + "</a>", '<span class="spot formatted-spot-{instrumentID} highlight">{[this.renderFormattedSpot(values.instrumentID, values.last)]}</span>', "<a href=\"#\" onclick=\"Trading.app.getController('Game').direction('{instrumentID}', -1); return false;\" onmouseover=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', -1, true); return false;\" onmouseout=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', false, true); return false;\" class=\"button button-medium direction-button put\">" + Registry._["label-below"] + "</a>", "</div>", '<div class="game-form-invoice-wrapper" id="game-form-invoice-wrapper-{instrumentID}">', '<div class="payout" id="payout-wrapper-{instrumentID}">', '<div id="payout-{instrumentID}">{payout}%</div>', '<div class="payout-text">', "<span>" + Registry._["trade-info-payout"] + "</span>", '<span id="game-indicators-{instrumentID}">{[this.renderIndicators(values.instrumentID)]}</span>', "</div>", "</div>", '<div class="invoice" style="display: none;" id="invoice-{instrumentID}" data-active="false"></div>', '<div class="message-container confirmation-message" style="display: none;" id="confirmation-message-{instrumentID}"></div>', "</div>", "</div>", "</div>", '<div class="cf more" id="more-{instrumentID}">{[this.renderMore(values)]}</div>', '<div class="cf more" id="more-activity-{instrumentID}">{[this.renderActivity(values)]}</div>', "</div>", "<!-- game ends -->", this.gameTemplateFunctions);
        this.gameClosedTemplateFunctions = {
            formatOpensAt: function(b) {
                var c = Trading.app.getController("Game");
                return c.formatOpensAt(b)
            }
        };
        this.tplGameClosed = new Ext.XTemplate("<!-- game closed begins -->", '<div class="game" id="game-{instrumentID}">', '<div class="cf game-row game-row-3 closed-game">', '<a class="instrument-name {[(values.starred) ? "starred" : ""]}" id="instrument-name-{instrumentID}" href="#" onclick="Trading.app.getController(\'Game\').star(\'{instrumentID}\'); return false;">{name}</a>', '<span class="game-closed-message">{opensAt:this.formatOpensAt}</span>', "</div>", "</div>", "<!-- game closed ends -->", this.gameClosedTemplateFunctions);
        this.tplSmallGameClosed = new Ext.XTemplate("<!-- game closed begins -->", '<div class="small-game" id="game-{instrumentID}">', '<div class="cf small-game-row small-game-row-3 closed-small-game">', '<a class="instrument-name {[(values.starred) ? "starred" : ""]}" id="instrument-name-{instrumentID}" href="#" onclick="Trading.app.getController(\'Game\').star(\'{instrumentID}\'); return false;">{name}</a>', '<span class="small-game-closed-message">{opensAt:this.formatOpensAt}</span>', "</div>", "</div>", "<!-- game closed ends -->", this.gameClosedTemplateFunctions);
        this.tplFinancialViewGameClosed = new Ext.XTemplate("<!-- game closed begins -->", '<div class="game" id="game-{instrumentID}">', '<div class="cf game-row game-row-3 closed-game">', '<a class="instrument-name instrument-name-closed" id="instrument-name-{instrumentID}" href="#" onclick="Trading.app.getController(\'Game\').star(\'{instrumentID}\'); return false;">{name}</a>', '<span class="game-closed-message">{opensAt:this.formatOpensAt}</span>', "</div>", "</div>", "<!-- game closed ends -->", this.gameClosedTemplateFunctions);
        this.tplSmallGame = new Ext.XTemplate("<!-- small game begins -->", '<div class="small-game  {[this.showGameInfo() ? "game-info" : ""]}" id="game-{instrumentID}" data-spot="{last}" data-payout="{payout}" data-rebate="{rebate}" data-game-type="{[this.getDefaultGameType(values.instrumentID)]}">', '<div class="small-game-header">', '<div class="small-game-header-left">', '<a class="small-instrument-name instrument-name {[(values.starred) ? "starred" : ""]}" id="instrument-name-{instrumentID}" href="#" onclick="Trading.app.getController(\'Game\').star(\'{instrumentID}\'); return false;" title="{name}"><span>{name:this.formatInstrumentName}</span></a>', '<tpl if="values.description && this.showGameInfo()">', '<span id="game-info-{instrumentID}" class="game-info-icon instrument-desc"  tooltip-content="{[this.renderInstrumentInfo(values)]}">&nbsp;</span>', "</tpl>", "</div>", '<div class="small-game-header-right">', "{[this.renderGameTypesMenu(values.instrumentID)]}", "</div>", "</div>", '<div class="small-game-second-row">', '<select class="game-expiry-box" id="game-expiry-box-{instrumentID}" onchange="Trading.app.getController(\'Game\').selectExpiry(\'{instrumentID}\', this.value, true)"><option value="">xxx</option></select>', '<span class="game-expiry-label" id="game-expiry-label-{instrumentID}">' + Registry._["game-label-expiry"] + ":</span>", '<ul class="game-short-expiry-options small-game-short-expiry" id="game-short-expiry-options-{instrumentID}">', "</ul>", '<span class="game-expiry-label" id="game-short-expiry-tooltip-arrow-{instrumentID}">' + Registry._["game-label-expiry"] + ":</span>", "</div>", '<div class="small-game-content">', '<div class="small-game-content-row">', '<span class="game-description"><span class="instrument-icon instrument-icon-{instrumentID}"></span>{name:this.renderQuestion}</span>', "</div>", '<div class="small-game-content-row">', '<div class="game-form-wrapper small-game-form-wrapper" >', '<div class="small-game-form-buttons-wrapper">', "<a href=\"#\" onclick=\"Trading.app.getController('Game').direction('{instrumentID}', 1); return false;\" onmouseover=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', 1, true); return false;\" onmouseout=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', false, true); return false;\" class=\"button button-medium direction-button call\">" + Registry._["label-above"] + "</a>", '<span class="spot formatted-spot-{instrumentID} highlight">{[this.renderFormattedSpot(values.instrumentID, values.last)]}</span>', "<a href=\"#\" onclick=\"Trading.app.getController('Game').direction('{instrumentID}', -1); return false;\" onmouseover=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', -1, true); return false;\" onmouseout=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', false, true); return false;\" class=\"button button-medium direction-button put\">" + Registry._["label-below"] + "</a>", "</div>", '<div class="game-form-invoice-wrapper" id="game-form-invoice-wrapper-{instrumentID}"  style="display: block;">', '<span class="time-to-trade-label x-hidden" style="display: none;" id="time-to-trade-label-{instrumentID}">' + Registry._["game-label-time-remaining"] + ":</span>", '<div class="small-payout" id="payout-wrapper-{instrumentID}">', '<div class="closing-progress-bar-container x-hidden" id="closing-progress-bar-container-{instrumentID}">{[this.renderProgressBar(values)]}</div>', '<div class="payout-value" id="payout-{instrumentID}">{payout}%</div>', '<div class="payout-text">', "<span>" + Registry._["trade-info-payout"] + "</span>", '<span id="game-indicators-{instrumentID}">{[this.renderIndicators(values.instrumentID)]}</span>', "</div>", "</div>", '<div class="invoice" style="display: none;" id="invoice-{instrumentID}" data-active="false"></div>', '<div class="message-container confirmation-message" style="display: none;" id="confirmation-message-{instrumentID}"></div>', "</div>", "</div>", "</div>", '<div class="small-game-content-row small-game-chart">', '<div class="chart-bg top" id="chart-top-bg-{instrumentID}"></div>', '<div class="chart-bg bottom" id="chart-bottom-bg-{instrumentID}"></div>', '<div class="chart-wrapper small-chart-wrapper" id="chart-wrapper-{instrumentID}"></div>', '<div class="chart-indicator" id="chart-indicator-{instrumentID}"></div>', "</div>", '<div class="small-game-content-row">', '<div class="{[this.showGameInfo() ? "small-show-more-ask-bid-container" : ""]}">', '<div id="show-more-container-{instrumentID}" class="small-show-more-container">', '<a href="#" onclick="Trading.app.getController(\'Game\').expand({instrumentID}); return false;" class="show-more" id="show-more-{instrumentID}">', '<span class="show-more-icon">&nbsp;</span>', "<span>" + Registry._.more + "</span>", "</a>", '<a href="#" onclick="Trading.app.getController(\'Game\').expand({instrumentID}, \'activity\'); return false;" class="show-more" style="{[Trading.app.getController("Game").isGameSocial(values.instrumentID) ? "" : "display: none;"]}" id="show-more-activity-{instrumentID}">', '<span class="show-more-icon more-activity">&nbsp;</span>', "<span>" + Registry._.social + "</span>", "</a>", '<a href="#" onclick="Trading.app.getController(\'Game\').showAdvancedChart(\'{instrumentID}\'); return false;" class="show-more" id="show-more-chart-{instrumentID}">', '<span class="show-more-icon more-advanced-chart">&nbsp;</span>', "<span>Chart</span>", "</a>", "</div>", '<tpl if="this.showGameInfo()">', '<div id="ask-bid-container-{instrumentID}" class="ask-bid-container">', '<span class="game-info-icon ask-bid-desc"  tooltip-content="{[this.renderAskBidInfo(values)]}">&nbsp;</span>', '<div class="ask-bid-value"><span>' + Registry._.Bid + ':</span>&nbsp;<span id="bid-{instrumentID}">-</span></div>', '<div class="ask-bid-value"><span>' + Registry._.Ask + ':</span>&nbsp;<span id="ask-{instrumentID}">-</span></div>', "</div>", "</tpl>", "</div>", "</div>", '<div class="cf more small-more" id="more-{instrumentID}">{[this.renderMore(values)]}</div>', '<div class="cf more small-more-activity" id="more-activity-{instrumentID}">{[this.renderActivity(values)]}</div>', "</div>", "</div>", "<!-- small game ends -->", this.gameTemplateFunctions);
        this.tplGames = new Ext.XTemplate('<div class="games">', '<tpl for=".">', '<div class="{[(xindex == 1) ? "first" : ""]} {[(xcount == xindex) ? "last" : ""]}" id="game-container-{[values.data.instrumentID]}" data-state="{[(values.data.isOpen) ? "open" : "closed"]}">{[this.renderGame(values)]}</div>', "</tpl>", "</div>", {
            renderGame: function(b) {
                var c = (b.data.isOpen) ? a.tplGame: a.tplGameClosed;
                return c.apply(b.data)
            }
        });
        this.tplSmallGameContainers = new Ext.XTemplate('<div class="game-small-containers">', '<tpl for=".">', '<div id="games-container-{[xindex]}">{[this.renderSmallGames(values)]}</div>', "</tpl>", "</div>", {
            renderSmallGames: function(b) {
                var c = a.tplSmallGames;
                return c.apply(b)
            }
        });
        this.tplSmallGames = new Ext.XTemplate('<div class="smallGames">', '<tpl for=".">', '<div id="game-container-{[values.data.instrumentID]}" data-state="{[(values.data.isOpen) ? "open" : "closed"]}">{[this.renderGame(values)]}</div>', "</tpl>", "</div>", {
            renderGame: function(b) {
                var c = (b.data.isOpen) ? a.tplSmallGame: a.tplSmallGameClosed;
                return c.apply(b.data)
            }
        });
        this.tplFinancialViewGame = new Ext.XTemplate('<h3 id="game-{instrumentID}"  data-spot="{last}" data-payout="{payout}" data-rebate="{rebate}" data-game-type="{[this.getDefaultGameType(values.instrumentID)]}">', '<span class="instrument-name {[(values.starred) ? "starred" : ""]}" id="instrument-name-{instrumentID}" href="#" onclick="var event = arguments[0] || window.event; event.stopPropagation(); Trading.app.getController(\'Game\').star(\'{instrumentID}\'); return false;">&nbsp</span>\n<div class="list-instrument-name-container" title="{name}"><span class="instrument-name-text">{name:this.formatInstrumentName}</span></div>', '<span class="list-spot spot-trend-{instrumentID} header-spot formatted-spot-{instrumentID} highlight">{[this.renderFormattedSpot(values.instrumentID, values.last)]}</span>', '<div class="list-progress-bar closing-progress-bar-container x-hidden" id="closing-progress-bar-container-{instrumentID}" style="{[(values.isOpen) ? "" : "visibility: hidden;"]}">{[this.renderProgressBar(values)]}</div>', '<span class="drag-drop">&nbsp</span>', "</h3>", "<div>{[this.renderFinancialViewGameBox(values)]}</div>", {
            renderFinancialViewGameBox: function(b) {
                return a.tplFinancialViewGameBox.apply(b)
            }
        },
        this.gameTemplateFunctions);
        this.tplFinancialViewGameBox = new Ext.XTemplate('<div class="big-game-right-row-2">', '<div class="game-form-buttons-wrapper">', "<a href=\"#\" onclick=\"Trading.app.getController('Game').direction('{instrumentID}', -1); return false;\" onmouseover=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', -1, true); return false;\" onmouseout=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', false, true); return false;\" class=\"button button-medium direction-button call {[this.renderLanguageClass()]}\">" + Registry._["label-above"] + "</a>", '<span class="spot spot-trend-{instrumentID} formatted-spot-{instrumentID} highlight">{[this.renderFormattedSpot(values.instrumentID, values.last)]}</span>', "<a href=\"#\" onclick=\"Trading.app.getController('Game').direction('{instrumentID}', 1); return false;\" onmouseover=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', 1, true); return false;\" onmouseout=\"Trading.app.getController('Game').setChartBackground('{instrumentID}', false, true); return false;\" class=\"button button-medium direction-button put {[this.renderLanguageClass()]}\">" + Registry._["label-below"] + "</a>", "</div>", "</div>", '<div class="big-game-right-row">', '<div class="game-form-invoice-wrapper" id="game-form-invoice-wrapper-{instrumentID}">', '<div class="payout" id="payout-wrapper-{instrumentID}">', '<div id="payout-{instrumentID}">{payout}%</div>', '<div class="payout-text">', "<span>" + Registry._["trade-info-payout"] + "</span>", '<span id="game-indicators-{instrumentID}">{[this.renderIndicators(values.instrumentID)]}</span>', "</div>", "</div>", '<div class="invoice" style="display: none;" id="invoice-{instrumentID}" data-active="false"></div>', '<div class="message-container confirmation-message" style="display: none;" id="confirmation-message-{instrumentID}"></div>', "</div>", "</div>", {
            renderLanguageClass: function() {
                return "lang-" + Registry.lang
            }
        },
        this.gameTemplateFunctions);
        this.tplFinancialViewChartWrapper = new Ext.XTemplate('<div class="chart-indicator" id="chart-indicator-{instrumentID}"></div>', '<div class="chart-plot-bg"></div>', '<div class="chart-bg top" id="chart-top-bg-{instrumentID}"></div>', '<div class="chart-bg bottom" id="chart-bottom-bg-{instrumentID}"></div>', '<div class="bottom-container {[this.showGameInfo() ? "ask-bid-and-sentiment" : ""]}">', '<div class="game-extended-info" id="game-extended-info-{instrumentID}"></div>', '<tpl if="this.showGameInfo()">', '<div id="ask-bid-container-{instrumentID}" class="ask-bid-container">', '<span class="game-info-icon ask-bid-desc"  tooltip-content="{[this.renderAskBidInfo(values)]}">&nbsp;</span>', '<div class="ask-bid-value"><span>' + Registry._.Bid + ':</span>&nbsp;<span id="bid-{instrumentID}">-</span></div>', '<div class="ask-bid-value"><span>' + Registry._.Ask + ':</span>&nbsp;<span id="ask-{instrumentID}">-</span></div>', "</div>", "</tpl>", "</div>", '<div class="big-game-chart-wrapper chart-wrapper chart-wrapper-hidden" id="chart-wrapper-{instrumentID}" style="visibility: hidden;"></div>', '<div class="big-game-chart-wrapper chart-wrapper chart-wrapper-hidden" id="chart-candlestick-wrapper-{instrumentID}" style="display: block;"></div>', '<div class="top-container {[this.showGameInfo() ? "menu-and-name" : ""]}">', '<div class="top-container-select-div">', '<select class="instrument-name-list" style="display:none;">', "<option>USD</option>", "<option>USD</option>", "<option>USD</option>", "</select>", "</div>", '<tpl if="this.showGameInfo()">', '<div class="instrument-name-container">', '<div class="instrument-name-on-chart" id="instrument-name-{instrumentID}"><span id="instrument-name-{instrumentID}">{name:this.formatInstrumentName}</span></div>', '<tpl if="values.description">', '<span class="game-info-icon instrument-desc"  tooltip-content="{[this.renderInstrumentInfo(values)]}">&nbsp;</span>', "</tpl>", "</div>", "</tpl>", '<div class="big-gamebox-menu-icons">', '<a class="menu-icons increase-icon {[this.renderDisabledIncreaseIcon()]}" id="financial-view-increase-icon" href="#" onclick="Trading.app.getController(\'Game\').zoomChart(\'in\'); return false;"></a>', '<a class="menu-icons reduce-icon {[this.renderDisabledReduceIcon()]}" id="financial-view-reduce-icon" href="#" onclick="Trading.app.getController(\'Game\').zoomChart(\'out\'); return false;"></a>', '<a class="menu-icons adv-chart-icon {[this.renderAdvancedChartIcon()]}" id="financial-view-advanced-chart-icon" href="#" onclick="Trading.app.getController(\'Game\').toggleFinancialViewChart(); return false;"></a>', '<a class="menu-icons social-icon {[this.renderActiveSocialIcon()]}" href="#" style="{[this.hideSocialIcon()]}" id="financial-view-social-icon" onclick="$(\'#show-social-trades-indicators-checkmark\').trigger(\'click\'); return false;"></a>', "</div>", "</div>", {
            renderDisabledIncreaseIcon: function() {
                return (a.zoomLevelIndex === a.zoomLevels.length - 1) ? "disabled": ""
            },
            renderDisabledReduceIcon: function() {
                return (a.zoomLevelIndex === 0) ? "disabled": ""
            },
            renderAdvancedChartIcon: function() {
                return (a.selectedChartType === "line") ? "candlestick": "line"
            },
            renderActiveSocialIcon: function() {
                return ($("#show-social-trades-indicators-checkmark").attr("checked") === "checked") ? "active": ""
            },
            hideSocialIcon: function(b) {
                if (!Registry.userID || a.selectedChartType !== "line") {
                    return "display: none;"
                }
            },
            formatInstrumentName: function(b) {
                var c = 11;
                if (a.selectedGameTemplate == "financial") {
                    c = 10
                }
                if (b.length <= c) {
                    return b
                } else {
                    return (b.substr(0, c) + "...")
                }
            },
            renderInstrumentInfo: function(b) {
                return a.renderInstrumentInfo(b)
            },
            renderAskBidInfo: function(b) {
                return a.renderAskBidInfo(b)
            },
            showGameInfo: function() {
                return a.showGameInfo
            }
        });
        this.tplFinancialViewGameExpiry = new Ext.XTemplate("{[this.renderFinancialViewGameTypesMenu(values)]}", '<select class="game-expiry-box" id="game-expiry-box-{instrumentID}" onchange="Trading.app.getController(\'Game\').selectExpiry(\'{instrumentID}\', this.value, true)"><option value="">xxx</option></select>', '<span class="game-expiry-label" id="game-expiry-label-{instrumentID}">' + Registry._["game-label-expiry"] + ":</span>", '<ul class="game-short-expiry-options" id="game-short-expiry-options-{instrumentID}">', "</ul>", '<div class="game-short-expiry-tooltip" id="game-short-expiry-tooltip-{instrumentID}"></div>', '<div class="game-short-expiry-tooltip-arrow" id="game-short-expiry-tooltip-arrow-{instrumentID}"></div>', '<select onchange="Trading.app.getController("Game").selectExpiry("1", this.value, true)" id="game-expiry-box-{instrumentID}" class="game-expiry-box" style="display: none;">', "</select>", '<span id="game-expiry-label-{instrumentID}" class="game-expiry-label" style="display: none;">Expiry:</span>', {
            renderFinancialViewGameTypesMenu: function(b) {
                return a.renderGameTypesMenu(b.instrumentID)
            }
        });
        this.tplFinancialView = new Ext.XTemplate('<div class="big-gamebox">', '<div class="big-gamebox content-right">', '<div id="about" class="nano">', '<div class="nano-content">', '<ul id="accordion" class="sortable-list">', '<tpl for=".">', '<li class="sortable-item" id="game-container-{data.instrumentID}" data-state="{[(values.data.isOpen) ? "open" : "closed"]}">', "{[this.renderFinancialViewGame(values)]}", "</li>", "</tpl>", "</ul>", "</div>", "</div>", "</div>", '<div class="big-gamebox content-left">', '<div class="cf game-row big-game-row big-game-row-first" id="expiry-container">', '<div id="financial-game-expiry-wrapper">', "{[this.renderFinancialViewGameExpiry(values)]}", "</div>", "</div>", '<div class="cf game-row big-game-chart-row" id="chart-container">', '<div class="chart-wrapper-container" id="chart-wrapper">', "{[this.renderFinancialViewChartWrapper(values)]}", "</div>", "</div>", '<div class="cf game-row big-game-chart-row" id="closed-game-container" style="display: none;">', '<div class="closed-wrapper-container" id="closed-game-wrapper">', "{[this.renderFinancialViewGameClosedWrapper(values)]}", "</div>", "</div>", "</div>", "</div>", '<iframe class="sentiment-iframe" src="' + Registry.scheme + "://widgets." + Registry.domain + "/" + Registry.lang + '/widget/sentiment?types=1,2,3,4&openByDefault=1,2,3,4&numberOfRows=4&showSentiment=1&selectInstrumentOnClick=1&customCSS=financial-view-class">', "</iframe>", {
            renderFinancialViewGame: function(b) {
                return a.tplFinancialViewGame.apply(b.data)
            },
            renderFinancialViewChartWrapper: function(b) {
                return a.tplFinancialViewChartWrapper.apply(b[0].data)
            },
            renderFinancialViewGameExpiry: function(b) {
                return a.tplFinancialViewGameExpiry.apply(b[0].data)
            },
            renderFinancialViewGameClosedWrapper: function(b) {
                if (!b[0].data.isOpen) {
                    return a.tplFinancialViewGameClosed.apply(b[0].data)
                } else {
                    return ""
                }
            }
        },
        this.gameTemplateFunctions);
        this.tplPagination = new Ext.XTemplate('<ul id="pagination" class="cf horizontal-list" style="float: right; margin: 10px 0;">', '<tpl for=".">', '<li class="{[(xcount == xindex) ? "last" : ""]}"><a href="#" onclick="Trading.app.getController(\'Game\').loadPage({page}); return false;" class="button {[(values.pressed) ? "pressed" : ""]}">{label}</a></li>', "</tpl>", "</ul>")
    },
    toggleFinancialViewChart: function() {
        if (!this.chartsRendered) {
            return
        }
        var a = this.selectedGameID;
        if ($("#chart-wrapper-" + a).css("display") === "block") {
            this.showFinancialViewCandleStickChart();
            this.selectedChartType = "candlestick";
            $("#financial-view-advanced-chart-icon").removeClass("candlestick").addClass("line")
        } else {
            this.showFinancialViewLineChart();
            this.selectedChartType = "line";
            $("#financial-view-advanced-chart-icon").removeClass("line").addClass("candlestick")
        }
        this.moveChartIndicator(a);
        this.colorBackground(a)
    },
    showFinancialViewLineChart: function() {
        var a = this.selectedGameID;
        $("#chart-wrapper-" + a).removeClass("chart-wrapper-hidden");
        $("#chart-wrapper-" + a).css("visibility", "visible");
        $("#chart-wrapper-" + a).show();
        $("#chart-candlestick-wrapper-" + a).addClass("chart-wrapper-hidden");
        $("#chart-candlestick-wrapper-" + a).css("visibility", "hidden");
        $("#chart-candlestick-wrapper-" + a).hide();
        if (Registry.userID) {
            $("#financial-view-social-icon").show()
        }
        Utils.setCookie(this.chartTypeCookieKey, "line", 365, "/")
    },
    showFinancialViewCandleStickChart: function() {
        var a = this.selectedGameID;
        $("#chart-wrapper-" + a).addClass("chart-wrapper-hidden");
        $("#chart-wrapper-" + a).css("visibility", "hidden");
        $("#chart-wrapper-" + a).hide();
        $("#chart-candlestick-wrapper-" + a).removeClass("chart-wrapper-hidden");
        $("#chart-candlestick-wrapper-" + a).css("visibility", "visible");
        $("#chart-candlestick-wrapper-" + a).show();
        if (Registry.userID) {
            $("#financial-view-social-icon").hide()
        }
        Utils.setCookie(this.chartTypeCookieKey, "candlestick", 365, "/")
    },
    zoomChart: function(a) {
        if (a === "in") {
            if (this.zoomLevelIndex < this.zoomLevels.length - 1) {
                this.zoomLevelIndex++;
                $("#financial-view-reduce-icon").removeClass("disabled");
                if (this.zoomLevelIndex === this.zoomLevels.length - 1) {
                    $("#financial-view-increase-icon").addClass("disabled")
                }
            }
        } else {
            if (a === "out") {
                if (this.zoomLevelIndex > 0) {
                    this.zoomLevelIndex--;
                    $("#financial-view-increase-icon").removeClass("disabled");
                    if (this.zoomLevelIndex === 0) {
                        $("#financial-view-reduce-icon").addClass("disabled")
                    }
                }
            }
        }
        this.updateChartZoomRange(this.selectedGameID)
    },
    formatOpensAt: function(a) {
        a = new Date(a);
        var d = Ext.Date.format(a, "Y-m-d");
        var b = Ext.Date.format(a, "H:i");
        var e = Registry._["closed-game-opens-at"] + " " + Ext.Date.format(a, "M d, H:i");
        var c = new Date(this.time);
        if (d == Ext.Date.format(c, "Y-m-d")) {
            e = Registry._["closed-game-opens-today-at"] + " " + b
        } else {
            c.setTime(c.getTime() + 86400000);
            if (d == Ext.Date.format(c, "Y-m-d")) {
                e = Registry._["closed-game-opens-tomorrow-at"] + " " + b
            }
        }
        return e
    },
    showAdvancedChart: function(a) {
        var d = "advanced-chart-window-" + a;
        var c = Ext.WindowMgr.get(d);
        if (Registry.mode == "no-charts") {
            return
        }
        if (!c) {
            var b = this.instruments.getById(a + "");
            c = Ext.create("Trading.view.AdvancedChart", {
                id: d,
                instrumentID: a,
                title: b.data.name,
                time: this.time
            })
        }
        c.show()
    },
    setReturnAmount: function(d, c, g) {
        var a = Ext.fly("investment-amount-" + d).dom.value;
        if (!a) {
            a = 0
        }
        var b = Ext.util.Format.number(a * (c + 100) / 100, "0,000.00");
        var f = Ext.util.Format.number(a * g / 100, "0,000.00");
        var e = this.formatPayout(c);
        Ext.fly("invoice-payout-" + d).dom.innerHTML = this.getUserCurrencyInfo().currencySymbol + b + " (" + e + ")";
        Ext.fly("invoice-rebate-" + d).dom.innerHTML = this.getUserCurrencyInfo().currencySymbol + f + " (" + g + "%)"
    },
    getGameType: function(b) {
        if (this.selectedGameTypes[b]) {
            Ext.getDom("game-" + b).setAttribute("data-game-type", this.selectedGameTypes[b]);
            if (Ext.select("#game-types-menu-" + b + " li.active").first()) {
                Ext.select("#game-types-menu-" + b + " li.active").first().removeCls("active");
                var a = this.selectedGameTypes[b];
                if (a == 11) {
                    a = 1
                }
                Ext.fly("game-type-" + b + "-" + a).addCls("active")
            }
        } else {
            this.selectedGameTypes[b] = Ext.getDom("game-" + b).getAttribute("data-game-type")
        }
        return Ext.getDom("game-" + b).getAttribute("data-game-type")
    },
    setGameType: function(c, a, b) {
        if (!b) {
            return
        }
        if (a != 3) {
            Ext.getDom("game-" + c).setAttribute("data-game-type", a);
            this.selectedGameTypes[c] = a + "";
            this.renderExpiryBoxes(c);
            this.renderIndicators(c, a, true)
        } else {
            if (!this.hasAdvancedGames(c)) {
                FinancialPanel.showDisabledMessage(c)
            } else {
                $(".trade-box-adv").show();
                FinancialPanel.init(c)
            }
        }
    },
    addTradeMarker: function(d, l) {
        var e = this;
        var h = e.charts[d];
        if (!h) {
            return
        }
        var b = "chart-series-" + d;
        var c = h.get(b);
        var k = Ext.get("game-" + d).dom;
        var g = Ext.fly("invoice-spot-" + d).dom.innerHTML * 1;
        var j = {
            x: e.time,
            y: g
        };
        var f = c.data.length;
        var a = {
            data: {
                index: f,
                instrumentID: d,
                tradeID: l,
                timestamp: j.x,
                direction: k.getAttribute("data-direction"),
                payout: k.getAttribute("data-payout"),
                rebate: k.getAttribute("data-rebate"),
                expiry: k.getAttribute("data-expiry"),
                stake: Ext.fly("investment-amount-" + d).getValue(),
                strike: g,
                expired: false
            }
        };
        c.data[c.data.length - 1].marker = {
            enabled: false
        };
        c.addPoint(j);
        e.moveChartIndicator(d);
        e.setTradeMarker(a);
        e.fixTradesMarkersPosition();
        e.setTradesMarkersVisibility(this.showTradesMarkers.myTrades);
        e.setTradesMarkersVisibility(this.showTradesMarkers.social, true, false)
    },
    updateTradeMarker: function(f, b, g) {
        var h = this.charts[f];
        var l = b.data.tradeID;
        var k;
        var d;
        var e;
        var a;
        var c = Ext.WindowMgr.get("advanced-chart-window-" + f);
        if (h && h.tradesMarkers) {
            k = h.tradesMarkers[l];
            if (k && k.marker) {
                b.data.social = (h.socialTrades && !Ext.isEmpty(h.socialTrades[l]));
                e = this.getTradeStatus(b);
                d = e.symbol;
                a = (e.payoff).toFixed(2);
                var j = Ext.getDom("trade-marker-symbol-" + l);
                if (j) {
                    j.setAttribute("href", d)
                } else {
                    console.log("could not find marker for ID: " + l)
                }
                if (c) {
                    c.updateTradeMarker(b)
                }
                k.tooltipData.returnedAmount = a;
                k.update(k, false);
                if (g || !j) {
                    k.marker.enabled = false;
                    delete h.tradesMarkers[l]
                }
            }
        }
    },
    updatePoint: function(f, c, j) {
        var g = this.charts[f];
        if (!g) {
            return
        }
        var d = g.get("chart-series-" + f);
        var e;
        var k;
        for (e = d.data.length - 1; e >= 0 && d.data[e].x > c; e--) {}
        k = d.data[e];
        k.x = c;
        k.y = j;
        k.update(k);
        var h = null;
        var b = Ext.WindowMgr.get("advanced-chart-window-" + f);
        if (b) {
            var a = b.lineChart;
            d = a.get("advanced-chart-line-series-" + f);
            for (e = d.data.length - 1; e >= 0 && d.data[e].x > c; e--) {}
            k = d.data[e];
            k.x = c;
            k.y = j;
            k.update(k);
            h = b.candlestickChart
        } else {
            h = this.candlestickCharts[f]
        }
        if (!h) {
            return
        }
        d = h.get("advanced-chart-candlestick-series-" + f);
        var k;
        for (e = d.data.length - 1; e >= 0 && d.data[e].x >= c; e--) {}
        k = d.data[e];
        k.close = j;
        if (j > k.high) {
            k.high = j
        }
        if (j < k.low) {
            k.low = j
        }
        d.data[e].update(k)
    },
    selectTradeMarker: function(c, f, b) {
        var d = this.charts[c];
        if (d && d.tradesMarkers) {
            var a = d.tradesMarkers[f];
            if (a && a.marker && this.showTradesMarkers.myTrades) {
                a.select(b, true);
                var e = Ext.WindowMgr.get("advanced-chart-window-" + c);
                if (e) {
                    e.selectTradeMarker(f, b)
                }
            }
        }
    },
    markSocialTrades: function(g, e, m) {
        var f = e.length - 1;
        var h = Trading.app.getController("Game");
        var b = Ext.WindowMgr.get("advanced-chart-window-" + g);
        var k = h.charts[g];
        var n;
        var d;
        var l;
        var j;
        var c;
        var a;
        if (!k.socialTrades) {
            k.socialTrades = {};
            k.lastSocialTradeID = 0
        }
        Ext.each(m,
        function(o) {
            a = {};
            if (o.data.instrumentID == g) {
                if (o.data.gameType == "7") {
                    return
                }
                n = o.data.tradeID * 1;
                d = Ext.isEmpty(k.socialTrades[n]);
                c = (e[0].x >= o.data.timestamp);
                j = ((!o.data.show) || c);
                if (j) {
                    if (!d) {
                        if (typeof(k.tradesMarkers[n]) != "undefined" && k.tradesMarkers[n].marker) {
                            k.tradesMarkers[n].marker.enabled = false
                        }
                        if (b) {
                            b.removeSocialEntry(o, c)
                        }
                        if (!c) {
                            delete k.socialTrades[n]
                        }
                    }
                } else {
                    if (d) {
                        if (n < k.lastSocialTradeID) {
                            return
                        }
                        for (f = e.length - 1; f >= 0; f--) {
                            if (o.data.timestamp > e[f].x) {
                                o.data.index = f;
                                o.data.social = true;
                                h.setTradeMarker(o);
                                if (b) {
                                    b.addSocialEntry(o)
                                }
                                k.socialTrades[n] = o;
                                a[(o.data.expired) ? Registry.socialActivityEventTypes.closePosition: Registry.socialActivityEventTypes.openPosition] = [o.data];
                                h.updateSocialActivityViewer(g, a);
                                k.lastSocialTradeID = n;
                                break
                            }
                        }
                    } else {
                        l = (!(k.socialTrades[n].data.expired) && o.data.expired);
                        if (l) {
                            h.updateTradeMarker(g, o, false);
                            if (b) {
                                b.updateSocialEntry(o)
                            }
                            k.socialTrades[n] = o;
                            a[Registry.socialActivityEventTypes.closePosition] = [o.data];
                            h.updateSocialActivityViewer(g, a)
                        }
                    }
                }
            }
        })
    },
    markTrades: function(b, d) {
        var c = d.length - 1;
        var a = Trading.app.getController("Game");
        Ext.each(Trading.app.getController("User").trades.data.items,
        function(e) {
            if (e.data.instrumentID == b && e.data.type < 3) {
                for (c = d.length - 1; c >= 0; c--) {
                    if (e.data.timestamp > d[c][0]) {
                        e.data.index = c;
                        a.setTradeMarker(e);
                        break
                    }
                }
            }
        })
    },
    setTradeMarker: function(c) {
        var b = this;
        var o = c.data;
        var u = o.instrumentID;
        var k = b.charts[u];
        var q = "chart-series-" + u;
        var h = k.get(q);
        var j = o.tradeID;
        var f = o.payout * 1;
        var s = o.rebate * 1;
        var t = o.direction * 1;
        var g = o.expiry * 1;
        var e = o.stake * 1;
        var a = o.strike * 1;
        var r = Registry.chartConfig.colors.marker;
        var p;
        var n;
        var d = false;
        var m;
        if (o.expired && (Ext.isEmpty(o.expiryPrice))) {
            return
        }
        m = this.getTradeStatus(c);
        p = m.symbol;
        if (c.data.social) {
            d = {
                userID: c.data.userID,
                nickname: c.data.nickname
            }
        }
        var l = {
            x: o.timestamp,
            y: a,
            marker: {
                enabled: true,
                fillColor: r,
                lineColor: Registry.chartConfig.colors.guide,
                symbol: "url(" + p + ")",
                lineWidth: 1,
                radius: 2,
                keep: true,
                states: {
                    hover: {
                        fillColor: r,
                        lineColor: Registry.chartConfig.colors.guide,
                        symbol: p
                    },
                    select: {
                        fillColor: r,
                        lineColor: Registry.chartConfig.colors.guide,
                        radius: 2,
                        symbol: p
                    }
                }
            },
            tooltipData: {
                tradeID: j,
                expiry: g,
                stake: e,
                direction: t,
                payout: f,
                rebate: s,
                social: d
            },
            events: {
                click: function() {
                    this.select(true);
                    return false
                },
                select: function() {
                    k.tooltip.refresh([this])
                },
                unselect: function() {
                    k.tooltip.hide()
                }
            },
            cursor: "pointer"
        };
        if (!k.tradesMarkers) {
            k.tradesMarkers = {}
        }
        if (o.expired && m.payoff !== null) {
            n = (m.payoff).toFixed(2);
            l.tooltipData.returnedAmount = n
        }
        h.data[o.index].update(l);
        k.tradesMarkers[j] = h.data[o.index];
        k.redraw();
        Ext.each(Ext.query("#chart-wrapper-" + u + " image"),
        function(v) {
            if (Ext.isEmpty(v.id)) {
                v.id = "trade-marker-symbol-" + j
            }
        });
        b.fixTradesMarkersPosition();
        b.setTradesMarkersVisibility(this.showTradesMarkers.myTrades);
        b.setTradesMarkersVisibility(this.showTradesMarkers.social, true, false)
    },
    fixTradesMarkersPosition: function(b) {
        var a = new Ext.util.DelayedTask(function() {
            var k = Trading.app.getController("Game");
            var d;
            var e;
            var f;
            var h = (b) ? "advanced-": "";
            var g;
            var j;
            var c;
            for (d in k.charts) {
                e = k.charts[d];
                if (e && e.tradesMarkers) {
                    for (f in e.tradesMarkers) {
                        g = Ext.getDom(h + "trade-marker-symbol-" + f);
                        if (g) {
                            j = e.tradesMarkers[f].tooltipData.social;
                            if (j) {
                                c = (b) ? "translate(-10,-27)": "translate(-7,-18)"
                            } else {
                                c = (b) ? "translate(-3,-14)": "translate(-3,-14)"
                            }
                            g.setAttribute("transform", c);
                            g.setAttribute("class", "pin")
                        }
                    }
                }
            }
        });
        a.delay(1000)
    },
    toggleTradesMarkers: function(c, d, b) {
        if (!d) {
            if (!b) {
                b = (c) ? !this.showTradesMarkers.social: !this.showTradesMarkers.myTrades
            }
            if (c) {
                this.showTradesMarkers.social = b
            } else {
                this.showTradesMarkers.myTrades = b
            }
        }
        this.setTradesMarkersVisibility(b, c, d);
        if (!c && !d) {
            this.setTradesMarkersVisibility(b, false, true)
        }
        var a = $("#financial-view-social-icon");
        if (a.length) {
            if ($("#show-social-trades-indicators-checkmark").attr("checked") === "checked") {
                a.addClass("active")
            } else {
                a.removeClass("active")
            }
        }
    },
    setTradesMarkersVisibility: function(c, b, n) {
        var g = this.charts;
        var k;
        var o;
        var f;
        var d;
        var a = (c) ? "visible": "hidden";
        var j = (n) ? "advanced-": "";
        var e;
        var m;
        var l;
        var h;
        for (f in g) {
            k = g[f];
            m = k.socialTrades;
            e = (b) ? k.socialTrades: k.tradesMarkers;
            if (e) {
                for (o in e) {
                    if (!b) {
                        l = false;
                        for (h in m) {
                            if (o == h) {
                                l = true;
                                break
                            }
                        }
                        if (l) {
                            continue
                        }
                    }
                    d = Ext.fly(j + "trade-marker-symbol-" + o);
                    if (d) {
                        d.setStyle("visibility", a)
                    }
                }
            }
        }
    },
    getTradeStatus: function(a, n) {
        var g = (n) ? Registry.chartConfig.advanced.markers: Registry.chartConfig.base.markers;
        var h = a.data.strike * 1;
        var m = a.data.expiryPrice * 1;
        var k = a.data.direction * 1;
        var b = a.data.stake * 1;
        var j = a.data.payout * 1;
        var o = a.data.rebate * 1;
        var l = a.data.expired;
        var p = h - m;
        var c;
        var f;
        var d;
        var e = true;
        if (!l) {
            c = (k == 1) ? g.trades.symbols.open.call: g.trades.symbols.open.put;
            f = null;
            d = "open";
            e = false
        } else {
            if (p * k < 0) {
                c = (k == 1) ? g.trades.symbols.inTheMoney.call: g.trades.symbols.inTheMoney.put;
                f = b + (b * j / 100);
                d = "in"
            } else {
                if (p * k > 0) {
                    c = (k == 1) ? g.trades.symbols.out.call: g.trades.symbols.out.put;
                    f = (b * o / 100);
                    d = "out"
                } else {
                    c = (k == 1) ? g.trades.symbols.at.call: g.trades.symbols.at.put;
                    f = b;
                    d = "at"
                }
            }
        }
        if (a.data.social) {
            c = (l) ? g.trades.symbols.close.social: g.trades.symbols.open.social
        }
        return {
            status: d,
            symbol: c,
            payoff: f,
            closed: e
        }
    },
    renderIndicators: function(c, a, b) {
        var e = {
            instrumentID: c,
            indicators: []
        };
        if (this.isGameSellBack(c, a)) {
            e.indicators.push({
                name: Registry._["trade-action-sell-back"],
                type: "sell-back-ind",
                title: Registry._["sell-back-indicator-title"]
            })
        }
        if (this.isGameRollOver(c)) {
            e.indicators.push({
                name: Registry._["roll-over"],
                type: "roll-over-ind",
                title: Registry._["roll-over-indicator-title"]
            })
        }
        if (this.isGameDoubleUp(c, a)) {
            e.indicators.push({
                name: Registry._.hedge,
                type: "hedge-ind",
                title: Registry._["hedge-indicator-title"]
            });
            e.indicators.push({
                name: Registry._["double-up"],
                type: "double-up-ind",
                title: Registry._["double-up-indicator-title"]
            })
        }
        var d = this.tplGameIndicators.apply(e);
        if (b) {
            Ext.fly("game-indicators-" + c).dom.innerHTML = d
        } else {
            return d
        }
    },
    getDefaultGameType: function(d) {
        var e = Trading.app.getController("Instrument");
        var c = e.instruments.getById(d);
        var b = this.isWeekendOptionEnabled(c);
        if (b) {
            return 7
        }
        if (Registry.shortGames.indexOf(d) == -1) {
            return 1
        } else {
            var a = e.instruments.getById(d).data.defaultGameType;
            if (a < 1 || a > 2) {
                a = 1
            }
            return a
        }
    },
    isGameSocial: function(a) {
        return (Registry.socialSite && (Registry.socialInstruments.indexOf(a) != -1))
    },
    isGameSellBack: function(b, a) {
        return ((a == 1 || a == 2) && (Registry.tradeOperationsConfig.sellbackInstruments.indexOf(b.toString()) != -1))
    },
    isGameDoubleUp: function(b, a) {
        if (typeof Registry.tradeOperationsConfig.doubleupInstruments !== "undefined") {
            return ((a == 1 || a == 2) && (Registry.tradeOperationsConfig.doubleupInstruments.indexOf(b.toString()) != -1))
        } else {
            return false
        }
    },
    isGameRollOver: function(a) {
        return false
    },
    getUserCurrencyInfo: function() {
        return Registry.currenciesInfo[Registry.userCurrency]
    },
    updateFormattedSpot: function(a) {
        var b = $("#game-" + a).attr("data-spot");
        if (!b) {
            return
        }
        b = this.formatSpot(a, b);
        $(".formatted-spot-" + a).html(b)
    },
    formatSpot: function(d, f) {
        f = this.getFixedQuote(d, f);
        var b = f.length - 3;
        var e = f.length - 2;
        if (f.charAt(b) === ".") {
            b++
        } else {
            if (f.charAt(e) === ".") {
                b--;
                e--
            }
        }
        var c = f.substring(b, e + 1);
        var a = f.substring(0, b) + '<span class="spot-large-digits">' + c + "</span>" + f.substring(e + 1, f.length - 1) + '<span class="spot-last-digit">' + f.charAt(f.length - 1) + "</span>";
        return a
    },
    getFixedQuote: function(c, b) {
        var a = this.instruments.getById(c).data.precision * 1;
        return new Number(b * 1).toFixed(a)
    }
});
Ext.define("Ext.data.HasManyAssociation", {
    extend: "Ext.data.Association",
    requires: ["Ext.util.Inflector"],
    alias: "association.hasmany",
    constructor: function(c) {
        var d = this,
        a, b;
        d.callParent(arguments);
        d.name = d.name || Ext.util.Inflector.pluralize(d.associatedName.toLowerCase());
        a = d.ownerModel.prototype;
        b = d.name;
        Ext.applyIf(d, {
            storeName: b + "Store",
            foreignKey: d.ownerName.toLowerCase() + "_id"
        });
        a[b] = d.createStore()
    },
    createStore: function() {
        var g = this,
        h = g.associatedModel,
        c = g.storeName,
        d = g.foreignKey,
        a = g.primaryKey,
        f = g.filterProperty,
        b = g.autoLoad,
        e = g.storeConfig || {};
        return function() {
            var m = this,
            k, l, j = {};
            if (m[c] === undefined) {
                if (f) {
                    l = {
                        property: f,
                        value: m.get(f),
                        exactMatch: true
                    }
                } else {
                    l = {
                        property: d,
                        value: m.get(a),
                        exactMatch: true
                    }
                }
                j[d] = m.get(a);
                k = Ext.apply({},
                e, {
                    model: h,
                    filters: [l],
                    remoteFilter: false,
                    modelDefaults: j
                });
                m[c] = Ext.create("Ext.data.Store", k);
                if (b) {
                    m[c].load()
                }
            }
            return m[c]
        }
    },
    read: function(c, a, e) {
        var d = c[this.name](),
        b;
        d.add(a.read(e).records);
        b = this.associatedModel.prototype.associations.findBy(function(f) {
            return f.type === "belongsTo" && f.associatedName === c.$className
        });
        if (b) {
            d.data.each(function(f) {
                f[b.instanceName] = c
            })
        }
    }
});
Ext.define("Trading.model.TradingHours", {
    extend: "Ext.data.Model",
    fields: [{
        name: "gameType",
        type: "string"
    }],
    idProperty: "gameType",
    hasMany: [{
        model: "Trading.model.TradingHourRanges",
        name: "tradingHourRanges"
    }],
    belongsTo: {
        model: "Trading.model.Instrument",
        name: "instrument"
    }
});
Ext.define("Trading.model.Payouts", {
    extend: "Ext.data.Model",
    fields: [{
        name: "gameType",
        type: "string"
    },
    "payout", "rebate"],
    idProperty: "gameType",
    hasMany: [{
        model: "Trading.model.PayoutRanges",
        name: "payoutRanges"
    }],
    belongsTo: {
        model: "Trading.model.Instrument",
        name: "instrument"
    }
});
Ext.define("Trading.model.Instrument", {
    extend: "Ext.data.Model",
    fields: [{
        name: "instrumentID",
        type: "string"
    },
    "name", "nameEnglish", "description", "expiry", "futureExpirationDate", "provider", "last", "isOpen", "opensAt", "closesAt", "type", "exchange", {
        name: "order",
        type: "int"
    },
    "payout", "rebate", "defaultGameType", "precision"],
    idProperty: "instrumentID",
    hasMany: [{
        model: "Trading.model.TradingHours",
        name: "tradingHours",
        associationKey: "tradingHours"
    },
    {
        model: "Trading.model.Payouts",
        name: "payouts",
        associationKey: "payouts"
    }],
    proxy: {
        type: "rest",
        url: "ajax/instrument/fetch-advanced",
        reader: {
            type: "json",
            root: "instruments"
        }
    },
    loadSubClasses: function(a) {
        this.payouts().removeAll();
        this.payouts().add(a.payouts);
        this.payouts().each(function(b) {
            if (b.data.payoutRanges) {
                if (b.data.gameType == 1) {
                    this.data.payout = b.data.payout;
                    this.data.rebate = b.data.rebate
                }
                b.payoutRanges().removeAll();
                b.payoutRanges().add(b.data.payoutRanges)
            }
        });
        this.tradingHours().removeAll();
        this.tradingHours().add(a.tradingHours);
        this.tradingHours().each(function(b) {
            if (b.data.tradingHourRanges) {
                b.tradingHourRanges().removeAll();
                b.tradingHourRanges().add(b.data.tradingHourRanges)
            }
        })
    }
});
Ext.define("Trading.controller.Instrument", {
    extend: "Ext.app.Controller",
    models: ["Instrument", "TradingHours", "TradingHourRanges", "Payouts", "PayoutRanges"],
    instruments: null,
    time: 0,
    loaded: false,
    lastPayouts: 0,
    lastTopPicks: 0,
    lastShortGames: 0,
    lastAssets: 0,
    init: function() {
        this.time = Registry.time;
        this.lastPayouts = Registry.time;
        this.instruments = Ext.create("Ext.data.Store", {
            model: "Trading.model.Instrument"
        });
        this.instruments.getProxy().url = "/" + Registry.currentLang + "/ajax/instrument/fetch-advanced";
        this.instruments.load({
            scope: this,
            callback: function() {
                this.loaded = true;
                this.updateUserPayouts();
                this.process();
                if (Registry.customIndexView) {
                    return
                }
                Trading.app.getController("Game").render();
                Trading.app.getController("User").renderTrades()
            }
        })
    },
    updateUserPayouts: function() {
        if (this.loaded) {
            this.instruments.each(function(b) {
                var a = 0;
                var c = 0;
                b.payouts().each(function(d) {
                    if (typeof Registry.payoutDeltas != "string" && Registry.payoutDeltas[d.data.gameType]) {
                        d.data.payout = d.data.payout * 1 + Registry.payoutDeltas[d.data.gameType];
                        d.payoutRanges().each(function(e) {
                            e.data.payout = e.data.payout * 1 + Registry.payoutDeltas[d.data.gameType]
                        })
                    }
                    if (d.data.gameType == 1) {
                        a = d.data.payout;
                        c = d.data.rebate
                    }
                });
                b.data.payout = a;
                b.data.rebate = c
            })
        }
    },
    process: function() {
        var a = this;
        if (this.loaded) {
            this.instruments.each(function(f) {
                var e = false;
                var c = 0;
                var b = 0;
                var h = (Registry.weekendGames.indexOf(f.data.instrumentID) != -1);
                f.tradingHours().each(function(j) {
                    if (j.data.gameType == 1 || (j.data.gameType == 7 && h)) {
                        j.tradingHourRanges().each(function(m) {
                            var l = a.time;
                            var o = m.data.from;
                            var n = m.data.to;
                            var k = false;
                            if (l < o && (c == 0 || o < c)) {
                                k = true
                            } else {
                                if (l >= o && l < n) {
                                    e = true;
                                    k = true
                                }
                            }
                            if (k) {
                                c = o;
                                b = n
                            }
                            return ! k
                        })
                    }
                });
                f.data.isOpen = e;
                f.data.opensAt = c;
                f.data.closesAt = b;
                var d = 0;
                var g = 0;
                f.payouts().each(function(j) {
                    if (j.data.gameType == 1) {
                        d = j.data.payout;
                        g = j.data.rebate
                    }
                });
                f.data.payout = d;
                f.data.rebate = g
            })
        }
    },
    setTime: function(b, a) {
        this.time = b;
        if (a) {
            this.process()
        }
    },
    update: function(j, h, g, c, d) {
        var f = 0;
        if (this.loaded) {
            var e = j.substr(4);
            j = this.instruments.getById(e);
            if (j) {
                if (j.data.last) {
                    var a = h * 1;
                    var b = j.data.last * 1;
                    if (a > b) {
                        f = 1
                    } else {
                        if (a < b) {
                            f = -1
                        }
                    }
                }
                FinancialPanel.quote(e, h, g, f, c, d);
                Trading.app.getController("Game").quote(e, h, g, f, c, d);
                Trading.app.getController("User").quote(e, h)
            }
        }
    },
    payouts: function(a) {
        if (a > this.lastPayouts) {
            this.lastPayouts = a;
            this.downloadPayouts(a)
        }
    },
    toppicks: function(a) {
        if (a > this.lastTopPicks) {
            this.lastTopPicks = a;
            this.downloadTopPicks(a)
        }
    },
    assets: function(a) {
        if (a > this.lastAssets) {
            this.lastAssets = a;
            this.downloadAssets(a)
        }
    },
    shortgames: function(a) {
        if (a > this.lastShortGames) {
            this.lastShortGames = a;
            this.downloadShortGames(a)
        }
    },
    updateGameData: function() {
        this.instruments.load({
            scope: this,
            callback: function() {
                this.process();
                Ext.Ajax.request({
                    url: Registry.uriBase + "/ajax/index/get-games-info",
                    success: function(a) {
                        a = Ext.decode(a.responseText);
                        Registry.shortGames = a.gamesInfo.shortGames;
                        Registry.featured = a.gamesInfo.featured;
                        Registry.tradeOperationsConfig = a.gamesInfo.tradeOperationsConfig;
                        var b = Trading.app.getController("Game");
                        if (b.currentFilter == "featured" || (Ext.isArray(b.currentFilter) && b.currentFilter[0].property == "featured")) {
                            b.render()
                        }
                    }
                })
            }
        })
    },
    downloadPayouts: function(d) {
        var c;
        var b;
        var e;
        var a = (Registry.env == "production") ? Registry.cdn + "/payouts/": Registry.cdnBase + "/tmp/";
        a += "new/" + Registry.alias + "/" + (d / 1000) + ".json";
        Ext.data.JsonP.request({
            url: a,
            callbackName: "payouts",
            scope: this,
            success: function(f) {
                for (b in f) {
                    e = f[b];
                    c = this.instruments.getById(b);
                    if (c) {
                        c.payouts().removeAll();
                        c.payouts().add(e);
                        c.payouts().each(function(g) {
                            if (g.data.payoutRanges) {
                                if (g.data.gameType == 1) {
                                    c.data.payout = g.data.payout;
                                    c.data.rebate = g.data.rebate
                                }
                                g.payoutRanges().removeAll();
                                g.payoutRanges().add(g.data.payoutRanges)
                            }
                        })
                    }
                }
                this.updateUserPayouts();
                if (Registry.customIndexView) {
                    if (typeof(FX1) != "undefined") {
                        FX1.updatePayout()
                    }
                }
                Trading.app.getController("Game").refreshPayouts()
            }
        })
    },
    downloadTopPicks: function(b) {
        var a = (Registry.env == "production") ? Registry.cdn + "/toppicks/": Registry.cdnBase + "/tmp/toppicks/";
        a += Registry.alias + "/" + b + ".json";
        $.getJSON(a,
        function(c) {
            Registry.featured = c;
            var d = Trading.app.getController("Game");
            if (d.currentFilter == "featured" || (Ext.isArray(d.currentFilter) && d.currentFilter[0].property == "featured")) {
                d.render()
            }
        })
    },
    downloadShortGames: function(b) {
        var a = (Registry.env == "production") ? Registry.cdn + "/shortgames/": Registry.cdnBase + "/tmp/shortgames/";
        a += Registry.alias + "/" + b + ".json";
        $.getJSON(a,
        function(c) {
            Registry.shortGames = c;
            var d = Trading.app.getController("Game");
            d.render()
        })
    },
    downloadAssets: function(c) {
        var b = (Registry.env == "production") ? Registry.cdn + "/assets_and_payouts/": Registry.cdnBase + "/tmp/assets_and_payouts/";
        b += Registry.alias + "/" + c + ".json";
        var a = this;
        $.getJSON(b,
        function(f) {
            var d;
            var e = [];
            var j = [];
            var n = (typeof a.instruments !== "undefined" && typeof a.instruments.data !== "undefined" && typeof a.instruments.data.items !== "undefined") ? a.instruments.data.items: [];
            for (d in n) {
                j[n[d].data.instrumentID] = n[d]
            }
            n = null;
            var m;
            var l = ["name", "nameEnglish", "description", "expiry", "type", "precision", "order", "defaultGameType", "provider", "futureExpirationDate"];
            for (d in f) {
                m = Ext.create("Trading.model.Instrument", f[d]);
                m.loadSubClasses(f[d]);
                m.raw = f[d];
                var h = m.data.instrumentID;
                var g;
                if (typeof j[h] !== "undefined") {
                    for (g in l) {
                        m.data[l[g]] = j[h].data[l[g]]
                    }
                    e.push(m)
                } else {}
            }
            a.instruments.loadData(e);
            a.updateUserPayouts();
            a.process();
            if (Registry.customIndexView) {
                return
            }
            var k = Trading.app.getController("Game");
            k.render()
        })
    }
});
Ext.require("Ext.data.JsonP");
Ext.require("Ext.XTemplate");
Ext.require("Ext.window.MessageBox");
Ext.require("Ext.slider.Single");
Ext.application({
    name: "Trading",
    appFolder: "/app",
    controllers: ["Feed", "Clock", "Instrument", "User", "Game", "Expiry", "Filter"],
    launch: function() {
        Trading.app = this;
        Utils.initButtons();
        new Ext.util.DelayedTask(function() {
            Trading.app.loadWidgets()
        }).delay(1000);
        new Ext.util.DelayedTask(function() {
            location.reload(true)
        }).delay(1000 * 3600 * 6)
    },
    loadWidgets: function() {
        var e;
        if (Registry.banner && !Ext.isEmpty(Registry.banner)) {
            e = (Registry.banner.type == "main") ? "main-banner": "secondary-banner";
            Ext.fly(e + "-container").addCls("active-banner");
            if (Registry.banner.format == "swf") {
                swfobject.embedSWF(Registry.banner.url, e, "100%", "100%", "9.0.0", false, {},
                {
                    wmode: "transparent",
                    allowScriptAccess: "always"
                })
            } else {
                if (Registry.banner.format == "png" || Registry.banner.format == "jpg" || Registry.banner.format == "gif") {
                    Ext.getDom(e).setAttribute("style", "background: url('" + Registry.banner.url + "?v=" + Math.floor(new Date().getTime()) + "') no-repeat; width: 100%; height: 100%;");
                    var d = Registry.banner.target;
                    var b = document.createElement("a");
                    b.setAttribute("href", d.url);
                    b.setAttribute("style", "position: relative; display: inline-block; left: " + d.points[0].x + "px; top: " + d.points[0].y + "px; width: " + (d.points[1].x - d.points[0].x) + "px; height: " + (d.points[1].y - d.points[0].y) + "px;");
                    if (Registry.banner.height) {
                        Ext.fly(e + "-container").setStyle("height", Registry.banner.height + "px")
                    }
                    Ext.getDom(e).appendChild(b)
                } else {
                    if (Registry.banner.format == "html") {
                        var c = document.createElement("iframe");
                        c.setAttribute("src", Registry.banner.url);
                        c.setAttribute("width", "100%");
                        c.setAttribute("height", "100%");
                        if (Registry.banner.height) {
                            Ext.fly(e + "-container").setStyle("height", Registry.banner.height + "px");
                            c.setAttribute("height", Registry.banner.height + "px")
                        }
                        Ext.getDom(e).appendChild(c)
                    }
                }
            }
        }
        if (Registry.intro && !Ext.isEmpty(Registry.intro)) {
            jwplayer.key = "ub6rI+BePVpo/oWHwrYoWlUv3juw7RYeXabBcF05PeY=";
            jwplayer("intro").setup({
                sources: [{
                    file: Registry.intro.movie + ".mp4"
                },
                {
                    file: Registry.intro.movie + ".webm"
                }],
                image: Registry.intro.movie + ".jpg",
                width: 300,
                height: 225
            })
        }
    }
});
